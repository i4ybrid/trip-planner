
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Trip
 * 
 */
export type Trip = $Result.DefaultSelection<Prisma.$TripPayload>
/**
 * Model TripMember
 * 
 */
export type TripMember = $Result.DefaultSelection<Prisma.$TripMemberPayload>
/**
 * Model Invite
 * 
 */
export type Invite = $Result.DefaultSelection<Prisma.$InvitePayload>
/**
 * Model InviteChannel
 * 
 */
export type InviteChannel = $Result.DefaultSelection<Prisma.$InviteChannelPayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model Vote
 * 
 */
export type Vote = $Result.DefaultSelection<Prisma.$VotePayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model TripMessage
 * 
 */
export type TripMessage = $Result.DefaultSelection<Prisma.$TripMessagePayload>
/**
 * Model MessageReaction
 * 
 */
export type MessageReaction = $Result.DefaultSelection<Prisma.$MessageReactionPayload>
/**
 * Model MessageReadReceipt
 * 
 */
export type MessageReadReceipt = $Result.DefaultSelection<Prisma.$MessageReadReceiptPayload>
/**
 * Model MediaItem
 * 
 */
export type MediaItem = $Result.DefaultSelection<Prisma.$MediaItemPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model PushSubscription
 * 
 */
export type PushSubscription = $Result.DefaultSelection<Prisma.$PushSubscriptionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TripStatus: {
  IDEA: 'IDEA',
  PLANNING: 'PLANNING',
  CONFIRMED: 'CONFIRMED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type TripStatus = (typeof TripStatus)[keyof typeof TripStatus]


export const MemberRole: {
  MASTER: 'MASTER',
  ORGANIZER: 'ORGANIZER',
  MEMBER: 'MEMBER',
  VIEWER: 'VIEWER'
};

export type MemberRole = (typeof MemberRole)[keyof typeof MemberRole]


export const MemberStatus: {
  INVITED: 'INVITED',
  DECLINED: 'DECLINED',
  MAYBE: 'MAYBE',
  CONFIRMED: 'CONFIRMED',
  REMOVED: 'REMOVED'
};

export type MemberStatus = (typeof MemberStatus)[keyof typeof MemberStatus]


export const InviteStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  DECLINED: 'DECLINED',
  EXPIRED: 'EXPIRED',
  REVOKED: 'REVOKED'
};

export type InviteStatus = (typeof InviteStatus)[keyof typeof InviteStatus]


export const BookingStatus: {
  PROPOSED: 'PROPOSED',
  CONFIRMED: 'CONFIRMED',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const MessageType: {
  TEXT: 'TEXT',
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO',
  SYSTEM: 'SYSTEM'
};

export type MessageType = (typeof MessageType)[keyof typeof MessageType]

}

export type TripStatus = $Enums.TripStatus

export const TripStatus: typeof $Enums.TripStatus

export type MemberRole = $Enums.MemberRole

export const MemberRole: typeof $Enums.MemberRole

export type MemberStatus = $Enums.MemberStatus

export const MemberStatus: typeof $Enums.MemberStatus

export type InviteStatus = $Enums.InviteStatus

export const InviteStatus: typeof $Enums.InviteStatus

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type MessageType = $Enums.MessageType

export const MessageType: typeof $Enums.MessageType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.trip`: Exposes CRUD operations for the **Trip** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trips
    * const trips = await prisma.trip.findMany()
    * ```
    */
  get trip(): Prisma.TripDelegate<ExtArgs>;

  /**
   * `prisma.tripMember`: Exposes CRUD operations for the **TripMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TripMembers
    * const tripMembers = await prisma.tripMember.findMany()
    * ```
    */
  get tripMember(): Prisma.TripMemberDelegate<ExtArgs>;

  /**
   * `prisma.invite`: Exposes CRUD operations for the **Invite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invites
    * const invites = await prisma.invite.findMany()
    * ```
    */
  get invite(): Prisma.InviteDelegate<ExtArgs>;

  /**
   * `prisma.inviteChannel`: Exposes CRUD operations for the **InviteChannel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InviteChannels
    * const inviteChannels = await prisma.inviteChannel.findMany()
    * ```
    */
  get inviteChannel(): Prisma.InviteChannelDelegate<ExtArgs>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs>;

  /**
   * `prisma.vote`: Exposes CRUD operations for the **Vote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Votes
    * const votes = await prisma.vote.findMany()
    * ```
    */
  get vote(): Prisma.VoteDelegate<ExtArgs>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs>;

  /**
   * `prisma.tripMessage`: Exposes CRUD operations for the **TripMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TripMessages
    * const tripMessages = await prisma.tripMessage.findMany()
    * ```
    */
  get tripMessage(): Prisma.TripMessageDelegate<ExtArgs>;

  /**
   * `prisma.messageReaction`: Exposes CRUD operations for the **MessageReaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageReactions
    * const messageReactions = await prisma.messageReaction.findMany()
    * ```
    */
  get messageReaction(): Prisma.MessageReactionDelegate<ExtArgs>;

  /**
   * `prisma.messageReadReceipt`: Exposes CRUD operations for the **MessageReadReceipt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageReadReceipts
    * const messageReadReceipts = await prisma.messageReadReceipt.findMany()
    * ```
    */
  get messageReadReceipt(): Prisma.MessageReadReceiptDelegate<ExtArgs>;

  /**
   * `prisma.mediaItem`: Exposes CRUD operations for the **MediaItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MediaItems
    * const mediaItems = await prisma.mediaItem.findMany()
    * ```
    */
  get mediaItem(): Prisma.MediaItemDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.pushSubscription`: Exposes CRUD operations for the **PushSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PushSubscriptions
    * const pushSubscriptions = await prisma.pushSubscription.findMany()
    * ```
    */
  get pushSubscription(): Prisma.PushSubscriptionDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Trip: 'Trip',
    TripMember: 'TripMember',
    Invite: 'Invite',
    InviteChannel: 'InviteChannel',
    Activity: 'Activity',
    Vote: 'Vote',
    Booking: 'Booking',
    TripMessage: 'TripMessage',
    MessageReaction: 'MessageReaction',
    MessageReadReceipt: 'MessageReadReceipt',
    MediaItem: 'MediaItem',
    Notification: 'Notification',
    PushSubscription: 'PushSubscription'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "trip" | "tripMember" | "invite" | "inviteChannel" | "activity" | "vote" | "booking" | "tripMessage" | "messageReaction" | "messageReadReceipt" | "mediaItem" | "notification" | "pushSubscription"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Trip: {
        payload: Prisma.$TripPayload<ExtArgs>
        fields: Prisma.TripFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TripFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TripFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          findFirst: {
            args: Prisma.TripFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TripFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          findMany: {
            args: Prisma.TripFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>[]
          }
          create: {
            args: Prisma.TripCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          createMany: {
            args: Prisma.TripCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TripCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>[]
          }
          delete: {
            args: Prisma.TripDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          update: {
            args: Prisma.TripUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          deleteMany: {
            args: Prisma.TripDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TripUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TripUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          aggregate: {
            args: Prisma.TripAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrip>
          }
          groupBy: {
            args: Prisma.TripGroupByArgs<ExtArgs>
            result: $Utils.Optional<TripGroupByOutputType>[]
          }
          count: {
            args: Prisma.TripCountArgs<ExtArgs>
            result: $Utils.Optional<TripCountAggregateOutputType> | number
          }
        }
      }
      TripMember: {
        payload: Prisma.$TripMemberPayload<ExtArgs>
        fields: Prisma.TripMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TripMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TripMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMemberPayload>
          }
          findFirst: {
            args: Prisma.TripMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TripMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMemberPayload>
          }
          findMany: {
            args: Prisma.TripMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMemberPayload>[]
          }
          create: {
            args: Prisma.TripMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMemberPayload>
          }
          createMany: {
            args: Prisma.TripMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TripMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMemberPayload>[]
          }
          delete: {
            args: Prisma.TripMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMemberPayload>
          }
          update: {
            args: Prisma.TripMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMemberPayload>
          }
          deleteMany: {
            args: Prisma.TripMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TripMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TripMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMemberPayload>
          }
          aggregate: {
            args: Prisma.TripMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTripMember>
          }
          groupBy: {
            args: Prisma.TripMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<TripMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.TripMemberCountArgs<ExtArgs>
            result: $Utils.Optional<TripMemberCountAggregateOutputType> | number
          }
        }
      }
      Invite: {
        payload: Prisma.$InvitePayload<ExtArgs>
        fields: Prisma.InviteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InviteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InviteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          findFirst: {
            args: Prisma.InviteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InviteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          findMany: {
            args: Prisma.InviteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>[]
          }
          create: {
            args: Prisma.InviteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          createMany: {
            args: Prisma.InviteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InviteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>[]
          }
          delete: {
            args: Prisma.InviteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          update: {
            args: Prisma.InviteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          deleteMany: {
            args: Prisma.InviteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InviteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InviteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          aggregate: {
            args: Prisma.InviteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvite>
          }
          groupBy: {
            args: Prisma.InviteGroupByArgs<ExtArgs>
            result: $Utils.Optional<InviteGroupByOutputType>[]
          }
          count: {
            args: Prisma.InviteCountArgs<ExtArgs>
            result: $Utils.Optional<InviteCountAggregateOutputType> | number
          }
        }
      }
      InviteChannel: {
        payload: Prisma.$InviteChannelPayload<ExtArgs>
        fields: Prisma.InviteChannelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InviteChannelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteChannelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InviteChannelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteChannelPayload>
          }
          findFirst: {
            args: Prisma.InviteChannelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteChannelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InviteChannelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteChannelPayload>
          }
          findMany: {
            args: Prisma.InviteChannelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteChannelPayload>[]
          }
          create: {
            args: Prisma.InviteChannelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteChannelPayload>
          }
          createMany: {
            args: Prisma.InviteChannelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InviteChannelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteChannelPayload>[]
          }
          delete: {
            args: Prisma.InviteChannelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteChannelPayload>
          }
          update: {
            args: Prisma.InviteChannelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteChannelPayload>
          }
          deleteMany: {
            args: Prisma.InviteChannelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InviteChannelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InviteChannelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteChannelPayload>
          }
          aggregate: {
            args: Prisma.InviteChannelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInviteChannel>
          }
          groupBy: {
            args: Prisma.InviteChannelGroupByArgs<ExtArgs>
            result: $Utils.Optional<InviteChannelGroupByOutputType>[]
          }
          count: {
            args: Prisma.InviteChannelCountArgs<ExtArgs>
            result: $Utils.Optional<InviteChannelCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      Vote: {
        payload: Prisma.$VotePayload<ExtArgs>
        fields: Prisma.VoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          findFirst: {
            args: Prisma.VoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          findMany: {
            args: Prisma.VoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>[]
          }
          create: {
            args: Prisma.VoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          createMany: {
            args: Prisma.VoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>[]
          }
          delete: {
            args: Prisma.VoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          update: {
            args: Prisma.VoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          deleteMany: {
            args: Prisma.VoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          aggregate: {
            args: Prisma.VoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVote>
          }
          groupBy: {
            args: Prisma.VoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoteCountArgs<ExtArgs>
            result: $Utils.Optional<VoteCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      TripMessage: {
        payload: Prisma.$TripMessagePayload<ExtArgs>
        fields: Prisma.TripMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TripMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TripMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMessagePayload>
          }
          findFirst: {
            args: Prisma.TripMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TripMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMessagePayload>
          }
          findMany: {
            args: Prisma.TripMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMessagePayload>[]
          }
          create: {
            args: Prisma.TripMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMessagePayload>
          }
          createMany: {
            args: Prisma.TripMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TripMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMessagePayload>[]
          }
          delete: {
            args: Prisma.TripMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMessagePayload>
          }
          update: {
            args: Prisma.TripMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMessagePayload>
          }
          deleteMany: {
            args: Prisma.TripMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TripMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TripMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMessagePayload>
          }
          aggregate: {
            args: Prisma.TripMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTripMessage>
          }
          groupBy: {
            args: Prisma.TripMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<TripMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.TripMessageCountArgs<ExtArgs>
            result: $Utils.Optional<TripMessageCountAggregateOutputType> | number
          }
        }
      }
      MessageReaction: {
        payload: Prisma.$MessageReactionPayload<ExtArgs>
        fields: Prisma.MessageReactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageReactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageReactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReactionPayload>
          }
          findFirst: {
            args: Prisma.MessageReactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageReactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReactionPayload>
          }
          findMany: {
            args: Prisma.MessageReactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReactionPayload>[]
          }
          create: {
            args: Prisma.MessageReactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReactionPayload>
          }
          createMany: {
            args: Prisma.MessageReactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageReactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReactionPayload>[]
          }
          delete: {
            args: Prisma.MessageReactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReactionPayload>
          }
          update: {
            args: Prisma.MessageReactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReactionPayload>
          }
          deleteMany: {
            args: Prisma.MessageReactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageReactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageReactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReactionPayload>
          }
          aggregate: {
            args: Prisma.MessageReactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageReaction>
          }
          groupBy: {
            args: Prisma.MessageReactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageReactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageReactionCountArgs<ExtArgs>
            result: $Utils.Optional<MessageReactionCountAggregateOutputType> | number
          }
        }
      }
      MessageReadReceipt: {
        payload: Prisma.$MessageReadReceiptPayload<ExtArgs>
        fields: Prisma.MessageReadReceiptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageReadReceiptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadReceiptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageReadReceiptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadReceiptPayload>
          }
          findFirst: {
            args: Prisma.MessageReadReceiptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadReceiptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageReadReceiptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadReceiptPayload>
          }
          findMany: {
            args: Prisma.MessageReadReceiptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadReceiptPayload>[]
          }
          create: {
            args: Prisma.MessageReadReceiptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadReceiptPayload>
          }
          createMany: {
            args: Prisma.MessageReadReceiptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageReadReceiptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadReceiptPayload>[]
          }
          delete: {
            args: Prisma.MessageReadReceiptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadReceiptPayload>
          }
          update: {
            args: Prisma.MessageReadReceiptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadReceiptPayload>
          }
          deleteMany: {
            args: Prisma.MessageReadReceiptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageReadReceiptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageReadReceiptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadReceiptPayload>
          }
          aggregate: {
            args: Prisma.MessageReadReceiptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageReadReceipt>
          }
          groupBy: {
            args: Prisma.MessageReadReceiptGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageReadReceiptGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageReadReceiptCountArgs<ExtArgs>
            result: $Utils.Optional<MessageReadReceiptCountAggregateOutputType> | number
          }
        }
      }
      MediaItem: {
        payload: Prisma.$MediaItemPayload<ExtArgs>
        fields: Prisma.MediaItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaItemPayload>
          }
          findFirst: {
            args: Prisma.MediaItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaItemPayload>
          }
          findMany: {
            args: Prisma.MediaItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaItemPayload>[]
          }
          create: {
            args: Prisma.MediaItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaItemPayload>
          }
          createMany: {
            args: Prisma.MediaItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaItemPayload>[]
          }
          delete: {
            args: Prisma.MediaItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaItemPayload>
          }
          update: {
            args: Prisma.MediaItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaItemPayload>
          }
          deleteMany: {
            args: Prisma.MediaItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MediaItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaItemPayload>
          }
          aggregate: {
            args: Prisma.MediaItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMediaItem>
          }
          groupBy: {
            args: Prisma.MediaItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaItemCountArgs<ExtArgs>
            result: $Utils.Optional<MediaItemCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      PushSubscription: {
        payload: Prisma.$PushSubscriptionPayload<ExtArgs>
        fields: Prisma.PushSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PushSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PushSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.PushSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PushSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          findMany: {
            args: Prisma.PushSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[]
          }
          create: {
            args: Prisma.PushSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          createMany: {
            args: Prisma.PushSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PushSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.PushSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          update: {
            args: Prisma.PushSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.PushSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PushSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PushSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.PushSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePushSubscription>
          }
          groupBy: {
            args: Prisma.PushSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PushSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PushSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<PushSubscriptionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    memberships: number
    createdTrips: number
    activities: number
    votes: number
    messages: number
    mediaItems: number
    notifications: number
    sentInvites: number
    messageReactions: number
    messageReadReceipts: number
    pushSubscriptions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberships?: boolean | UserCountOutputTypeCountMembershipsArgs
    createdTrips?: boolean | UserCountOutputTypeCountCreatedTripsArgs
    activities?: boolean | UserCountOutputTypeCountActivitiesArgs
    votes?: boolean | UserCountOutputTypeCountVotesArgs
    messages?: boolean | UserCountOutputTypeCountMessagesArgs
    mediaItems?: boolean | UserCountOutputTypeCountMediaItemsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    sentInvites?: boolean | UserCountOutputTypeCountSentInvitesArgs
    messageReactions?: boolean | UserCountOutputTypeCountMessageReactionsArgs
    messageReadReceipts?: boolean | UserCountOutputTypeCountMessageReadReceiptsArgs
    pushSubscriptions?: boolean | UserCountOutputTypeCountPushSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedTripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMediaItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessageReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageReactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessageReadReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageReadReceiptWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPushSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PushSubscriptionWhereInput
  }


  /**
   * Count Type TripCountOutputType
   */

  export type TripCountOutputType = {
    members: number
    invites: number
    activities: number
    bookings: number
    messages: number
    mediaItems: number
    notifications: number
  }

  export type TripCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | TripCountOutputTypeCountMembersArgs
    invites?: boolean | TripCountOutputTypeCountInvitesArgs
    activities?: boolean | TripCountOutputTypeCountActivitiesArgs
    bookings?: boolean | TripCountOutputTypeCountBookingsArgs
    messages?: boolean | TripCountOutputTypeCountMessagesArgs
    mediaItems?: boolean | TripCountOutputTypeCountMediaItemsArgs
    notifications?: boolean | TripCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * TripCountOutputType without action
   */
  export type TripCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCountOutputType
     */
    select?: TripCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TripCountOutputType without action
   */
  export type TripCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripMemberWhereInput
  }

  /**
   * TripCountOutputType without action
   */
  export type TripCountOutputTypeCountInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteWhereInput
  }

  /**
   * TripCountOutputType without action
   */
  export type TripCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * TripCountOutputType without action
   */
  export type TripCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * TripCountOutputType without action
   */
  export type TripCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripMessageWhereInput
  }

  /**
   * TripCountOutputType without action
   */
  export type TripCountOutputTypeCountMediaItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaItemWhereInput
  }

  /**
   * TripCountOutputType without action
   */
  export type TripCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type InviteCountOutputType
   */

  export type InviteCountOutputType = {
    channels: number
  }

  export type InviteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channels?: boolean | InviteCountOutputTypeCountChannelsArgs
  }

  // Custom InputTypes
  /**
   * InviteCountOutputType without action
   */
  export type InviteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteCountOutputType
     */
    select?: InviteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InviteCountOutputType without action
   */
  export type InviteCountOutputTypeCountChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteChannelWhereInput
  }


  /**
   * Count Type ActivityCountOutputType
   */

  export type ActivityCountOutputType = {
    votes: number
    bookings: number
    mediaItems: number
  }

  export type ActivityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    votes?: boolean | ActivityCountOutputTypeCountVotesArgs
    bookings?: boolean | ActivityCountOutputTypeCountBookingsArgs
    mediaItems?: boolean | ActivityCountOutputTypeCountMediaItemsArgs
  }

  // Custom InputTypes
  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCountOutputType
     */
    select?: ActivityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoteWhereInput
  }

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountMediaItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaItemWhereInput
  }


  /**
   * Count Type TripMessageCountOutputType
   */

  export type TripMessageCountOutputType = {
    edits: number
    reactions: number
    readReceipts: number
  }

  export type TripMessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edits?: boolean | TripMessageCountOutputTypeCountEditsArgs
    reactions?: boolean | TripMessageCountOutputTypeCountReactionsArgs
    readReceipts?: boolean | TripMessageCountOutputTypeCountReadReceiptsArgs
  }

  // Custom InputTypes
  /**
   * TripMessageCountOutputType without action
   */
  export type TripMessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMessageCountOutputType
     */
    select?: TripMessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TripMessageCountOutputType without action
   */
  export type TripMessageCountOutputTypeCountEditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripMessageWhereInput
  }

  /**
   * TripMessageCountOutputType without action
   */
  export type TripMessageCountOutputTypeCountReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageReactionWhereInput
  }

  /**
   * TripMessageCountOutputType without action
   */
  export type TripMessageCountOutputTypeCountReadReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageReadReceiptWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    avatarUrl: string | null
    phone: string | null
    venmo: string | null
    paypal: string | null
    zelle: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    avatarUrl: string | null
    phone: string | null
    venmo: string | null
    paypal: string | null
    zelle: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    avatarUrl: number
    phone: number
    venmo: number
    paypal: number
    zelle: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatarUrl?: true
    phone?: true
    venmo?: true
    paypal?: true
    zelle?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatarUrl?: true
    phone?: true
    venmo?: true
    paypal?: true
    zelle?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatarUrl?: true
    phone?: true
    venmo?: true
    paypal?: true
    zelle?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    avatarUrl: string | null
    phone: string | null
    venmo: string | null
    paypal: string | null
    zelle: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    avatarUrl?: boolean
    phone?: boolean
    venmo?: boolean
    paypal?: boolean
    zelle?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    memberships?: boolean | User$membershipsArgs<ExtArgs>
    createdTrips?: boolean | User$createdTripsArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    votes?: boolean | User$votesArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    mediaItems?: boolean | User$mediaItemsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    sentInvites?: boolean | User$sentInvitesArgs<ExtArgs>
    messageReactions?: boolean | User$messageReactionsArgs<ExtArgs>
    messageReadReceipts?: boolean | User$messageReadReceiptsArgs<ExtArgs>
    pushSubscriptions?: boolean | User$pushSubscriptionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    avatarUrl?: boolean
    phone?: boolean
    venmo?: boolean
    paypal?: boolean
    zelle?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    avatarUrl?: boolean
    phone?: boolean
    venmo?: boolean
    paypal?: boolean
    zelle?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberships?: boolean | User$membershipsArgs<ExtArgs>
    createdTrips?: boolean | User$createdTripsArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    votes?: boolean | User$votesArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    mediaItems?: boolean | User$mediaItemsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    sentInvites?: boolean | User$sentInvitesArgs<ExtArgs>
    messageReactions?: boolean | User$messageReactionsArgs<ExtArgs>
    messageReadReceipts?: boolean | User$messageReadReceiptsArgs<ExtArgs>
    pushSubscriptions?: boolean | User$pushSubscriptionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      memberships: Prisma.$TripMemberPayload<ExtArgs>[]
      createdTrips: Prisma.$TripPayload<ExtArgs>[]
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      votes: Prisma.$VotePayload<ExtArgs>[]
      messages: Prisma.$TripMessagePayload<ExtArgs>[]
      mediaItems: Prisma.$MediaItemPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      sentInvites: Prisma.$InvitePayload<ExtArgs>[]
      messageReactions: Prisma.$MessageReactionPayload<ExtArgs>[]
      messageReadReceipts: Prisma.$MessageReadReceiptPayload<ExtArgs>[]
      pushSubscriptions: Prisma.$PushSubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      avatarUrl: string | null
      phone: string | null
      venmo: string | null
      paypal: string | null
      zelle: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    memberships<T extends User$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripMemberPayload<ExtArgs>, T, "findMany"> | Null>
    createdTrips<T extends User$createdTripsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdTripsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findMany"> | Null>
    activities<T extends User$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany"> | Null>
    votes<T extends User$votesArgs<ExtArgs> = {}>(args?: Subset<T, User$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends User$messagesArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripMessagePayload<ExtArgs>, T, "findMany"> | Null>
    mediaItems<T extends User$mediaItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$mediaItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaItemPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    sentInvites<T extends User$sentInvitesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentInvitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findMany"> | Null>
    messageReactions<T extends User$messageReactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$messageReactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReactionPayload<ExtArgs>, T, "findMany"> | Null>
    messageReadReceipts<T extends User$messageReadReceiptsArgs<ExtArgs> = {}>(args?: Subset<T, User$messageReadReceiptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReadReceiptPayload<ExtArgs>, T, "findMany"> | Null>
    pushSubscriptions<T extends User$pushSubscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$pushSubscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly venmo: FieldRef<"User", 'String'>
    readonly paypal: FieldRef<"User", 'String'>
    readonly zelle: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.memberships
   */
  export type User$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMember
     */
    select?: TripMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMemberInclude<ExtArgs> | null
    where?: TripMemberWhereInput
    orderBy?: TripMemberOrderByWithRelationInput | TripMemberOrderByWithRelationInput[]
    cursor?: TripMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripMemberScalarFieldEnum | TripMemberScalarFieldEnum[]
  }

  /**
   * User.createdTrips
   */
  export type User$createdTripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    where?: TripWhereInput
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    cursor?: TripWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * User.activities
   */
  export type User$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * User.votes
   */
  export type User$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    where?: VoteWhereInput
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    cursor?: VoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * User.messages
   */
  export type User$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMessage
     */
    select?: TripMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMessageInclude<ExtArgs> | null
    where?: TripMessageWhereInput
    orderBy?: TripMessageOrderByWithRelationInput | TripMessageOrderByWithRelationInput[]
    cursor?: TripMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripMessageScalarFieldEnum | TripMessageScalarFieldEnum[]
  }

  /**
   * User.mediaItems
   */
  export type User$mediaItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaItem
     */
    select?: MediaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaItemInclude<ExtArgs> | null
    where?: MediaItemWhereInput
    orderBy?: MediaItemOrderByWithRelationInput | MediaItemOrderByWithRelationInput[]
    cursor?: MediaItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaItemScalarFieldEnum | MediaItemScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.sentInvites
   */
  export type User$sentInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    where?: InviteWhereInput
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    cursor?: InviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * User.messageReactions
   */
  export type User$messageReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReactionInclude<ExtArgs> | null
    where?: MessageReactionWhereInput
    orderBy?: MessageReactionOrderByWithRelationInput | MessageReactionOrderByWithRelationInput[]
    cursor?: MessageReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageReactionScalarFieldEnum | MessageReactionScalarFieldEnum[]
  }

  /**
   * User.messageReadReceipts
   */
  export type User$messageReadReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReadReceipt
     */
    select?: MessageReadReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadReceiptInclude<ExtArgs> | null
    where?: MessageReadReceiptWhereInput
    orderBy?: MessageReadReceiptOrderByWithRelationInput | MessageReadReceiptOrderByWithRelationInput[]
    cursor?: MessageReadReceiptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageReadReceiptScalarFieldEnum | MessageReadReceiptScalarFieldEnum[]
  }

  /**
   * User.pushSubscriptions
   */
  export type User$pushSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    where?: PushSubscriptionWhereInput
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    cursor?: PushSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Trip
   */

  export type AggregateTrip = {
    _count: TripCountAggregateOutputType | null
    _min: TripMinAggregateOutputType | null
    _max: TripMaxAggregateOutputType | null
  }

  export type TripMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    destination: string | null
    startDate: Date | null
    endDate: Date | null
    coverImage: string | null
    status: $Enums.TripStatus | null
    tripMasterId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TripMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    destination: string | null
    startDate: Date | null
    endDate: Date | null
    coverImage: string | null
    status: $Enums.TripStatus | null
    tripMasterId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TripCountAggregateOutputType = {
    id: number
    name: number
    description: number
    destination: number
    startDate: number
    endDate: number
    coverImage: number
    status: number
    tripMasterId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TripMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    destination?: true
    startDate?: true
    endDate?: true
    coverImage?: true
    status?: true
    tripMasterId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TripMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    destination?: true
    startDate?: true
    endDate?: true
    coverImage?: true
    status?: true
    tripMasterId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TripCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    destination?: true
    startDate?: true
    endDate?: true
    coverImage?: true
    status?: true
    tripMasterId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TripAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trip to aggregate.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trips
    **/
    _count?: true | TripCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TripMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TripMaxAggregateInputType
  }

  export type GetTripAggregateType<T extends TripAggregateArgs> = {
        [P in keyof T & keyof AggregateTrip]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrip[P]>
      : GetScalarType<T[P], AggregateTrip[P]>
  }




  export type TripGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripWhereInput
    orderBy?: TripOrderByWithAggregationInput | TripOrderByWithAggregationInput[]
    by: TripScalarFieldEnum[] | TripScalarFieldEnum
    having?: TripScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TripCountAggregateInputType | true
    _min?: TripMinAggregateInputType
    _max?: TripMaxAggregateInputType
  }

  export type TripGroupByOutputType = {
    id: string
    name: string
    description: string | null
    destination: string | null
    startDate: Date | null
    endDate: Date | null
    coverImage: string | null
    status: $Enums.TripStatus
    tripMasterId: string
    createdAt: Date
    updatedAt: Date
    _count: TripCountAggregateOutputType | null
    _min: TripMinAggregateOutputType | null
    _max: TripMaxAggregateOutputType | null
  }

  type GetTripGroupByPayload<T extends TripGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TripGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TripGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TripGroupByOutputType[P]>
            : GetScalarType<T[P], TripGroupByOutputType[P]>
        }
      >
    >


  export type TripSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    destination?: boolean
    startDate?: boolean
    endDate?: boolean
    coverImage?: boolean
    status?: boolean
    tripMasterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tripMaster?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Trip$membersArgs<ExtArgs>
    invites?: boolean | Trip$invitesArgs<ExtArgs>
    activities?: boolean | Trip$activitiesArgs<ExtArgs>
    bookings?: boolean | Trip$bookingsArgs<ExtArgs>
    messages?: boolean | Trip$messagesArgs<ExtArgs>
    mediaItems?: boolean | Trip$mediaItemsArgs<ExtArgs>
    notifications?: boolean | Trip$notificationsArgs<ExtArgs>
    _count?: boolean | TripCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trip"]>

  export type TripSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    destination?: boolean
    startDate?: boolean
    endDate?: boolean
    coverImage?: boolean
    status?: boolean
    tripMasterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tripMaster?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trip"]>

  export type TripSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    destination?: boolean
    startDate?: boolean
    endDate?: boolean
    coverImage?: boolean
    status?: boolean
    tripMasterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TripInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tripMaster?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Trip$membersArgs<ExtArgs>
    invites?: boolean | Trip$invitesArgs<ExtArgs>
    activities?: boolean | Trip$activitiesArgs<ExtArgs>
    bookings?: boolean | Trip$bookingsArgs<ExtArgs>
    messages?: boolean | Trip$messagesArgs<ExtArgs>
    mediaItems?: boolean | Trip$mediaItemsArgs<ExtArgs>
    notifications?: boolean | Trip$notificationsArgs<ExtArgs>
    _count?: boolean | TripCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TripIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tripMaster?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TripPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Trip"
    objects: {
      tripMaster: Prisma.$UserPayload<ExtArgs>
      members: Prisma.$TripMemberPayload<ExtArgs>[]
      invites: Prisma.$InvitePayload<ExtArgs>[]
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      messages: Prisma.$TripMessagePayload<ExtArgs>[]
      mediaItems: Prisma.$MediaItemPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      destination: string | null
      startDate: Date | null
      endDate: Date | null
      coverImage: string | null
      status: $Enums.TripStatus
      tripMasterId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trip"]>
    composites: {}
  }

  type TripGetPayload<S extends boolean | null | undefined | TripDefaultArgs> = $Result.GetResult<Prisma.$TripPayload, S>

  type TripCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TripFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TripCountAggregateInputType | true
    }

  export interface TripDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Trip'], meta: { name: 'Trip' } }
    /**
     * Find zero or one Trip that matches the filter.
     * @param {TripFindUniqueArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TripFindUniqueArgs>(args: SelectSubset<T, TripFindUniqueArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Trip that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TripFindUniqueOrThrowArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TripFindUniqueOrThrowArgs>(args: SelectSubset<T, TripFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Trip that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripFindFirstArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TripFindFirstArgs>(args?: SelectSubset<T, TripFindFirstArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Trip that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripFindFirstOrThrowArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TripFindFirstOrThrowArgs>(args?: SelectSubset<T, TripFindFirstOrThrowArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Trips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trips
     * const trips = await prisma.trip.findMany()
     * 
     * // Get first 10 Trips
     * const trips = await prisma.trip.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tripWithIdOnly = await prisma.trip.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TripFindManyArgs>(args?: SelectSubset<T, TripFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Trip.
     * @param {TripCreateArgs} args - Arguments to create a Trip.
     * @example
     * // Create one Trip
     * const Trip = await prisma.trip.create({
     *   data: {
     *     // ... data to create a Trip
     *   }
     * })
     * 
     */
    create<T extends TripCreateArgs>(args: SelectSubset<T, TripCreateArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Trips.
     * @param {TripCreateManyArgs} args - Arguments to create many Trips.
     * @example
     * // Create many Trips
     * const trip = await prisma.trip.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TripCreateManyArgs>(args?: SelectSubset<T, TripCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trips and returns the data saved in the database.
     * @param {TripCreateManyAndReturnArgs} args - Arguments to create many Trips.
     * @example
     * // Create many Trips
     * const trip = await prisma.trip.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trips and only return the `id`
     * const tripWithIdOnly = await prisma.trip.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TripCreateManyAndReturnArgs>(args?: SelectSubset<T, TripCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Trip.
     * @param {TripDeleteArgs} args - Arguments to delete one Trip.
     * @example
     * // Delete one Trip
     * const Trip = await prisma.trip.delete({
     *   where: {
     *     // ... filter to delete one Trip
     *   }
     * })
     * 
     */
    delete<T extends TripDeleteArgs>(args: SelectSubset<T, TripDeleteArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Trip.
     * @param {TripUpdateArgs} args - Arguments to update one Trip.
     * @example
     * // Update one Trip
     * const trip = await prisma.trip.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TripUpdateArgs>(args: SelectSubset<T, TripUpdateArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Trips.
     * @param {TripDeleteManyArgs} args - Arguments to filter Trips to delete.
     * @example
     * // Delete a few Trips
     * const { count } = await prisma.trip.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TripDeleteManyArgs>(args?: SelectSubset<T, TripDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trips
     * const trip = await prisma.trip.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TripUpdateManyArgs>(args: SelectSubset<T, TripUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trip.
     * @param {TripUpsertArgs} args - Arguments to update or create a Trip.
     * @example
     * // Update or create a Trip
     * const trip = await prisma.trip.upsert({
     *   create: {
     *     // ... data to create a Trip
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trip we want to update
     *   }
     * })
     */
    upsert<T extends TripUpsertArgs>(args: SelectSubset<T, TripUpsertArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Trips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripCountArgs} args - Arguments to filter Trips to count.
     * @example
     * // Count the number of Trips
     * const count = await prisma.trip.count({
     *   where: {
     *     // ... the filter for the Trips we want to count
     *   }
     * })
    **/
    count<T extends TripCountArgs>(
      args?: Subset<T, TripCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TripCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TripAggregateArgs>(args: Subset<T, TripAggregateArgs>): Prisma.PrismaPromise<GetTripAggregateType<T>>

    /**
     * Group by Trip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TripGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TripGroupByArgs['orderBy'] }
        : { orderBy?: TripGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TripGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTripGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Trip model
   */
  readonly fields: TripFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Trip.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TripClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tripMaster<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    members<T extends Trip$membersArgs<ExtArgs> = {}>(args?: Subset<T, Trip$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripMemberPayload<ExtArgs>, T, "findMany"> | Null>
    invites<T extends Trip$invitesArgs<ExtArgs> = {}>(args?: Subset<T, Trip$invitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findMany"> | Null>
    activities<T extends Trip$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Trip$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany"> | Null>
    bookings<T extends Trip$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Trip$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends Trip$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Trip$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripMessagePayload<ExtArgs>, T, "findMany"> | Null>
    mediaItems<T extends Trip$mediaItemsArgs<ExtArgs> = {}>(args?: Subset<T, Trip$mediaItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaItemPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends Trip$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Trip$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Trip model
   */ 
  interface TripFieldRefs {
    readonly id: FieldRef<"Trip", 'String'>
    readonly name: FieldRef<"Trip", 'String'>
    readonly description: FieldRef<"Trip", 'String'>
    readonly destination: FieldRef<"Trip", 'String'>
    readonly startDate: FieldRef<"Trip", 'DateTime'>
    readonly endDate: FieldRef<"Trip", 'DateTime'>
    readonly coverImage: FieldRef<"Trip", 'String'>
    readonly status: FieldRef<"Trip", 'TripStatus'>
    readonly tripMasterId: FieldRef<"Trip", 'String'>
    readonly createdAt: FieldRef<"Trip", 'DateTime'>
    readonly updatedAt: FieldRef<"Trip", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Trip findUnique
   */
  export type TripFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip findUniqueOrThrow
   */
  export type TripFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip findFirst
   */
  export type TripFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trips.
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trips.
     */
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Trip findFirstOrThrow
   */
  export type TripFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trips.
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trips.
     */
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Trip findMany
   */
  export type TripFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trips to fetch.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trips.
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Trip create
   */
  export type TripCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * The data needed to create a Trip.
     */
    data: XOR<TripCreateInput, TripUncheckedCreateInput>
  }

  /**
   * Trip createMany
   */
  export type TripCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trips.
     */
    data: TripCreateManyInput | TripCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Trip createManyAndReturn
   */
  export type TripCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Trips.
     */
    data: TripCreateManyInput | TripCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Trip update
   */
  export type TripUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * The data needed to update a Trip.
     */
    data: XOR<TripUpdateInput, TripUncheckedUpdateInput>
    /**
     * Choose, which Trip to update.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip updateMany
   */
  export type TripUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trips.
     */
    data: XOR<TripUpdateManyMutationInput, TripUncheckedUpdateManyInput>
    /**
     * Filter which Trips to update
     */
    where?: TripWhereInput
  }

  /**
   * Trip upsert
   */
  export type TripUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * The filter to search for the Trip to update in case it exists.
     */
    where: TripWhereUniqueInput
    /**
     * In case the Trip found by the `where` argument doesn't exist, create a new Trip with this data.
     */
    create: XOR<TripCreateInput, TripUncheckedCreateInput>
    /**
     * In case the Trip was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TripUpdateInput, TripUncheckedUpdateInput>
  }

  /**
   * Trip delete
   */
  export type TripDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter which Trip to delete.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip deleteMany
   */
  export type TripDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trips to delete
     */
    where?: TripWhereInput
  }

  /**
   * Trip.members
   */
  export type Trip$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMember
     */
    select?: TripMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMemberInclude<ExtArgs> | null
    where?: TripMemberWhereInput
    orderBy?: TripMemberOrderByWithRelationInput | TripMemberOrderByWithRelationInput[]
    cursor?: TripMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripMemberScalarFieldEnum | TripMemberScalarFieldEnum[]
  }

  /**
   * Trip.invites
   */
  export type Trip$invitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    where?: InviteWhereInput
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    cursor?: InviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * Trip.activities
   */
  export type Trip$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Trip.bookings
   */
  export type Trip$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Trip.messages
   */
  export type Trip$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMessage
     */
    select?: TripMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMessageInclude<ExtArgs> | null
    where?: TripMessageWhereInput
    orderBy?: TripMessageOrderByWithRelationInput | TripMessageOrderByWithRelationInput[]
    cursor?: TripMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripMessageScalarFieldEnum | TripMessageScalarFieldEnum[]
  }

  /**
   * Trip.mediaItems
   */
  export type Trip$mediaItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaItem
     */
    select?: MediaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaItemInclude<ExtArgs> | null
    where?: MediaItemWhereInput
    orderBy?: MediaItemOrderByWithRelationInput | MediaItemOrderByWithRelationInput[]
    cursor?: MediaItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaItemScalarFieldEnum | MediaItemScalarFieldEnum[]
  }

  /**
   * Trip.notifications
   */
  export type Trip$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Trip without action
   */
  export type TripDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
  }


  /**
   * Model TripMember
   */

  export type AggregateTripMember = {
    _count: TripMemberCountAggregateOutputType | null
    _avg: TripMemberAvgAggregateOutputType | null
    _sum: TripMemberSumAggregateOutputType | null
    _min: TripMemberMinAggregateOutputType | null
    _max: TripMemberMaxAggregateOutputType | null
  }

  export type TripMemberAvgAggregateOutputType = {
    paymentAmount: Decimal | null
  }

  export type TripMemberSumAggregateOutputType = {
    paymentAmount: Decimal | null
  }

  export type TripMemberMinAggregateOutputType = {
    id: string | null
    tripId: string | null
    userId: string | null
    role: $Enums.MemberRole | null
    status: $Enums.MemberStatus | null
    paymentStatus: string | null
    paymentAmount: Decimal | null
    paymentConfirmedAt: Date | null
    joinedAt: Date | null
  }

  export type TripMemberMaxAggregateOutputType = {
    id: string | null
    tripId: string | null
    userId: string | null
    role: $Enums.MemberRole | null
    status: $Enums.MemberStatus | null
    paymentStatus: string | null
    paymentAmount: Decimal | null
    paymentConfirmedAt: Date | null
    joinedAt: Date | null
  }

  export type TripMemberCountAggregateOutputType = {
    id: number
    tripId: number
    userId: number
    role: number
    status: number
    paymentStatus: number
    paymentAmount: number
    paymentConfirmedAt: number
    joinedAt: number
    _all: number
  }


  export type TripMemberAvgAggregateInputType = {
    paymentAmount?: true
  }

  export type TripMemberSumAggregateInputType = {
    paymentAmount?: true
  }

  export type TripMemberMinAggregateInputType = {
    id?: true
    tripId?: true
    userId?: true
    role?: true
    status?: true
    paymentStatus?: true
    paymentAmount?: true
    paymentConfirmedAt?: true
    joinedAt?: true
  }

  export type TripMemberMaxAggregateInputType = {
    id?: true
    tripId?: true
    userId?: true
    role?: true
    status?: true
    paymentStatus?: true
    paymentAmount?: true
    paymentConfirmedAt?: true
    joinedAt?: true
  }

  export type TripMemberCountAggregateInputType = {
    id?: true
    tripId?: true
    userId?: true
    role?: true
    status?: true
    paymentStatus?: true
    paymentAmount?: true
    paymentConfirmedAt?: true
    joinedAt?: true
    _all?: true
  }

  export type TripMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TripMember to aggregate.
     */
    where?: TripMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripMembers to fetch.
     */
    orderBy?: TripMemberOrderByWithRelationInput | TripMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TripMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TripMembers
    **/
    _count?: true | TripMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TripMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TripMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TripMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TripMemberMaxAggregateInputType
  }

  export type GetTripMemberAggregateType<T extends TripMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateTripMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTripMember[P]>
      : GetScalarType<T[P], AggregateTripMember[P]>
  }




  export type TripMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripMemberWhereInput
    orderBy?: TripMemberOrderByWithAggregationInput | TripMemberOrderByWithAggregationInput[]
    by: TripMemberScalarFieldEnum[] | TripMemberScalarFieldEnum
    having?: TripMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TripMemberCountAggregateInputType | true
    _avg?: TripMemberAvgAggregateInputType
    _sum?: TripMemberSumAggregateInputType
    _min?: TripMemberMinAggregateInputType
    _max?: TripMemberMaxAggregateInputType
  }

  export type TripMemberGroupByOutputType = {
    id: string
    tripId: string
    userId: string
    role: $Enums.MemberRole
    status: $Enums.MemberStatus
    paymentStatus: string | null
    paymentAmount: Decimal | null
    paymentConfirmedAt: Date | null
    joinedAt: Date
    _count: TripMemberCountAggregateOutputType | null
    _avg: TripMemberAvgAggregateOutputType | null
    _sum: TripMemberSumAggregateOutputType | null
    _min: TripMemberMinAggregateOutputType | null
    _max: TripMemberMaxAggregateOutputType | null
  }

  type GetTripMemberGroupByPayload<T extends TripMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TripMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TripMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TripMemberGroupByOutputType[P]>
            : GetScalarType<T[P], TripMemberGroupByOutputType[P]>
        }
      >
    >


  export type TripMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    userId?: boolean
    role?: boolean
    status?: boolean
    paymentStatus?: boolean
    paymentAmount?: boolean
    paymentConfirmedAt?: boolean
    joinedAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tripMember"]>

  export type TripMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    userId?: boolean
    role?: boolean
    status?: boolean
    paymentStatus?: boolean
    paymentAmount?: boolean
    paymentConfirmedAt?: boolean
    joinedAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tripMember"]>

  export type TripMemberSelectScalar = {
    id?: boolean
    tripId?: boolean
    userId?: boolean
    role?: boolean
    status?: boolean
    paymentStatus?: boolean
    paymentAmount?: boolean
    paymentConfirmedAt?: boolean
    joinedAt?: boolean
  }

  export type TripMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TripMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TripMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TripMember"
    objects: {
      trip: Prisma.$TripPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tripId: string
      userId: string
      role: $Enums.MemberRole
      status: $Enums.MemberStatus
      paymentStatus: string | null
      paymentAmount: Prisma.Decimal | null
      paymentConfirmedAt: Date | null
      joinedAt: Date
    }, ExtArgs["result"]["tripMember"]>
    composites: {}
  }

  type TripMemberGetPayload<S extends boolean | null | undefined | TripMemberDefaultArgs> = $Result.GetResult<Prisma.$TripMemberPayload, S>

  type TripMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TripMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TripMemberCountAggregateInputType | true
    }

  export interface TripMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TripMember'], meta: { name: 'TripMember' } }
    /**
     * Find zero or one TripMember that matches the filter.
     * @param {TripMemberFindUniqueArgs} args - Arguments to find a TripMember
     * @example
     * // Get one TripMember
     * const tripMember = await prisma.tripMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TripMemberFindUniqueArgs>(args: SelectSubset<T, TripMemberFindUniqueArgs<ExtArgs>>): Prisma__TripMemberClient<$Result.GetResult<Prisma.$TripMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TripMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TripMemberFindUniqueOrThrowArgs} args - Arguments to find a TripMember
     * @example
     * // Get one TripMember
     * const tripMember = await prisma.tripMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TripMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, TripMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TripMemberClient<$Result.GetResult<Prisma.$TripMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TripMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMemberFindFirstArgs} args - Arguments to find a TripMember
     * @example
     * // Get one TripMember
     * const tripMember = await prisma.tripMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TripMemberFindFirstArgs>(args?: SelectSubset<T, TripMemberFindFirstArgs<ExtArgs>>): Prisma__TripMemberClient<$Result.GetResult<Prisma.$TripMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TripMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMemberFindFirstOrThrowArgs} args - Arguments to find a TripMember
     * @example
     * // Get one TripMember
     * const tripMember = await prisma.tripMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TripMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, TripMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__TripMemberClient<$Result.GetResult<Prisma.$TripMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TripMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TripMembers
     * const tripMembers = await prisma.tripMember.findMany()
     * 
     * // Get first 10 TripMembers
     * const tripMembers = await prisma.tripMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tripMemberWithIdOnly = await prisma.tripMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TripMemberFindManyArgs>(args?: SelectSubset<T, TripMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TripMember.
     * @param {TripMemberCreateArgs} args - Arguments to create a TripMember.
     * @example
     * // Create one TripMember
     * const TripMember = await prisma.tripMember.create({
     *   data: {
     *     // ... data to create a TripMember
     *   }
     * })
     * 
     */
    create<T extends TripMemberCreateArgs>(args: SelectSubset<T, TripMemberCreateArgs<ExtArgs>>): Prisma__TripMemberClient<$Result.GetResult<Prisma.$TripMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TripMembers.
     * @param {TripMemberCreateManyArgs} args - Arguments to create many TripMembers.
     * @example
     * // Create many TripMembers
     * const tripMember = await prisma.tripMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TripMemberCreateManyArgs>(args?: SelectSubset<T, TripMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TripMembers and returns the data saved in the database.
     * @param {TripMemberCreateManyAndReturnArgs} args - Arguments to create many TripMembers.
     * @example
     * // Create many TripMembers
     * const tripMember = await prisma.tripMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TripMembers and only return the `id`
     * const tripMemberWithIdOnly = await prisma.tripMember.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TripMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, TripMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripMemberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TripMember.
     * @param {TripMemberDeleteArgs} args - Arguments to delete one TripMember.
     * @example
     * // Delete one TripMember
     * const TripMember = await prisma.tripMember.delete({
     *   where: {
     *     // ... filter to delete one TripMember
     *   }
     * })
     * 
     */
    delete<T extends TripMemberDeleteArgs>(args: SelectSubset<T, TripMemberDeleteArgs<ExtArgs>>): Prisma__TripMemberClient<$Result.GetResult<Prisma.$TripMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TripMember.
     * @param {TripMemberUpdateArgs} args - Arguments to update one TripMember.
     * @example
     * // Update one TripMember
     * const tripMember = await prisma.tripMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TripMemberUpdateArgs>(args: SelectSubset<T, TripMemberUpdateArgs<ExtArgs>>): Prisma__TripMemberClient<$Result.GetResult<Prisma.$TripMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TripMembers.
     * @param {TripMemberDeleteManyArgs} args - Arguments to filter TripMembers to delete.
     * @example
     * // Delete a few TripMembers
     * const { count } = await prisma.tripMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TripMemberDeleteManyArgs>(args?: SelectSubset<T, TripMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TripMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TripMembers
     * const tripMember = await prisma.tripMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TripMemberUpdateManyArgs>(args: SelectSubset<T, TripMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TripMember.
     * @param {TripMemberUpsertArgs} args - Arguments to update or create a TripMember.
     * @example
     * // Update or create a TripMember
     * const tripMember = await prisma.tripMember.upsert({
     *   create: {
     *     // ... data to create a TripMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TripMember we want to update
     *   }
     * })
     */
    upsert<T extends TripMemberUpsertArgs>(args: SelectSubset<T, TripMemberUpsertArgs<ExtArgs>>): Prisma__TripMemberClient<$Result.GetResult<Prisma.$TripMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TripMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMemberCountArgs} args - Arguments to filter TripMembers to count.
     * @example
     * // Count the number of TripMembers
     * const count = await prisma.tripMember.count({
     *   where: {
     *     // ... the filter for the TripMembers we want to count
     *   }
     * })
    **/
    count<T extends TripMemberCountArgs>(
      args?: Subset<T, TripMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TripMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TripMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TripMemberAggregateArgs>(args: Subset<T, TripMemberAggregateArgs>): Prisma.PrismaPromise<GetTripMemberAggregateType<T>>

    /**
     * Group by TripMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TripMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TripMemberGroupByArgs['orderBy'] }
        : { orderBy?: TripMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TripMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTripMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TripMember model
   */
  readonly fields: TripMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TripMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TripMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trip<T extends TripDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TripDefaultArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TripMember model
   */ 
  interface TripMemberFieldRefs {
    readonly id: FieldRef<"TripMember", 'String'>
    readonly tripId: FieldRef<"TripMember", 'String'>
    readonly userId: FieldRef<"TripMember", 'String'>
    readonly role: FieldRef<"TripMember", 'MemberRole'>
    readonly status: FieldRef<"TripMember", 'MemberStatus'>
    readonly paymentStatus: FieldRef<"TripMember", 'String'>
    readonly paymentAmount: FieldRef<"TripMember", 'Decimal'>
    readonly paymentConfirmedAt: FieldRef<"TripMember", 'DateTime'>
    readonly joinedAt: FieldRef<"TripMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TripMember findUnique
   */
  export type TripMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMember
     */
    select?: TripMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMemberInclude<ExtArgs> | null
    /**
     * Filter, which TripMember to fetch.
     */
    where: TripMemberWhereUniqueInput
  }

  /**
   * TripMember findUniqueOrThrow
   */
  export type TripMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMember
     */
    select?: TripMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMemberInclude<ExtArgs> | null
    /**
     * Filter, which TripMember to fetch.
     */
    where: TripMemberWhereUniqueInput
  }

  /**
   * TripMember findFirst
   */
  export type TripMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMember
     */
    select?: TripMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMemberInclude<ExtArgs> | null
    /**
     * Filter, which TripMember to fetch.
     */
    where?: TripMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripMembers to fetch.
     */
    orderBy?: TripMemberOrderByWithRelationInput | TripMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TripMembers.
     */
    cursor?: TripMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TripMembers.
     */
    distinct?: TripMemberScalarFieldEnum | TripMemberScalarFieldEnum[]
  }

  /**
   * TripMember findFirstOrThrow
   */
  export type TripMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMember
     */
    select?: TripMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMemberInclude<ExtArgs> | null
    /**
     * Filter, which TripMember to fetch.
     */
    where?: TripMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripMembers to fetch.
     */
    orderBy?: TripMemberOrderByWithRelationInput | TripMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TripMembers.
     */
    cursor?: TripMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TripMembers.
     */
    distinct?: TripMemberScalarFieldEnum | TripMemberScalarFieldEnum[]
  }

  /**
   * TripMember findMany
   */
  export type TripMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMember
     */
    select?: TripMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMemberInclude<ExtArgs> | null
    /**
     * Filter, which TripMembers to fetch.
     */
    where?: TripMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripMembers to fetch.
     */
    orderBy?: TripMemberOrderByWithRelationInput | TripMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TripMembers.
     */
    cursor?: TripMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripMembers.
     */
    skip?: number
    distinct?: TripMemberScalarFieldEnum | TripMemberScalarFieldEnum[]
  }

  /**
   * TripMember create
   */
  export type TripMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMember
     */
    select?: TripMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a TripMember.
     */
    data: XOR<TripMemberCreateInput, TripMemberUncheckedCreateInput>
  }

  /**
   * TripMember createMany
   */
  export type TripMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TripMembers.
     */
    data: TripMemberCreateManyInput | TripMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TripMember createManyAndReturn
   */
  export type TripMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMember
     */
    select?: TripMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TripMembers.
     */
    data: TripMemberCreateManyInput | TripMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TripMember update
   */
  export type TripMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMember
     */
    select?: TripMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a TripMember.
     */
    data: XOR<TripMemberUpdateInput, TripMemberUncheckedUpdateInput>
    /**
     * Choose, which TripMember to update.
     */
    where: TripMemberWhereUniqueInput
  }

  /**
   * TripMember updateMany
   */
  export type TripMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TripMembers.
     */
    data: XOR<TripMemberUpdateManyMutationInput, TripMemberUncheckedUpdateManyInput>
    /**
     * Filter which TripMembers to update
     */
    where?: TripMemberWhereInput
  }

  /**
   * TripMember upsert
   */
  export type TripMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMember
     */
    select?: TripMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the TripMember to update in case it exists.
     */
    where: TripMemberWhereUniqueInput
    /**
     * In case the TripMember found by the `where` argument doesn't exist, create a new TripMember with this data.
     */
    create: XOR<TripMemberCreateInput, TripMemberUncheckedCreateInput>
    /**
     * In case the TripMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TripMemberUpdateInput, TripMemberUncheckedUpdateInput>
  }

  /**
   * TripMember delete
   */
  export type TripMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMember
     */
    select?: TripMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMemberInclude<ExtArgs> | null
    /**
     * Filter which TripMember to delete.
     */
    where: TripMemberWhereUniqueInput
  }

  /**
   * TripMember deleteMany
   */
  export type TripMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TripMembers to delete
     */
    where?: TripMemberWhereInput
  }

  /**
   * TripMember without action
   */
  export type TripMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMember
     */
    select?: TripMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMemberInclude<ExtArgs> | null
  }


  /**
   * Model Invite
   */

  export type AggregateInvite = {
    _count: InviteCountAggregateOutputType | null
    _min: InviteMinAggregateOutputType | null
    _max: InviteMaxAggregateOutputType | null
  }

  export type InviteMinAggregateOutputType = {
    id: string | null
    tripId: string | null
    token: string | null
    email: string | null
    phone: string | null
    status: $Enums.InviteStatus | null
    expiresAt: Date | null
    sentById: string | null
    createdAt: Date | null
  }

  export type InviteMaxAggregateOutputType = {
    id: string | null
    tripId: string | null
    token: string | null
    email: string | null
    phone: string | null
    status: $Enums.InviteStatus | null
    expiresAt: Date | null
    sentById: string | null
    createdAt: Date | null
  }

  export type InviteCountAggregateOutputType = {
    id: number
    tripId: number
    token: number
    email: number
    phone: number
    status: number
    expiresAt: number
    sentById: number
    createdAt: number
    _all: number
  }


  export type InviteMinAggregateInputType = {
    id?: true
    tripId?: true
    token?: true
    email?: true
    phone?: true
    status?: true
    expiresAt?: true
    sentById?: true
    createdAt?: true
  }

  export type InviteMaxAggregateInputType = {
    id?: true
    tripId?: true
    token?: true
    email?: true
    phone?: true
    status?: true
    expiresAt?: true
    sentById?: true
    createdAt?: true
  }

  export type InviteCountAggregateInputType = {
    id?: true
    tripId?: true
    token?: true
    email?: true
    phone?: true
    status?: true
    expiresAt?: true
    sentById?: true
    createdAt?: true
    _all?: true
  }

  export type InviteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invite to aggregate.
     */
    where?: InviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invites to fetch.
     */
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invites
    **/
    _count?: true | InviteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InviteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InviteMaxAggregateInputType
  }

  export type GetInviteAggregateType<T extends InviteAggregateArgs> = {
        [P in keyof T & keyof AggregateInvite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvite[P]>
      : GetScalarType<T[P], AggregateInvite[P]>
  }




  export type InviteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteWhereInput
    orderBy?: InviteOrderByWithAggregationInput | InviteOrderByWithAggregationInput[]
    by: InviteScalarFieldEnum[] | InviteScalarFieldEnum
    having?: InviteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InviteCountAggregateInputType | true
    _min?: InviteMinAggregateInputType
    _max?: InviteMaxAggregateInputType
  }

  export type InviteGroupByOutputType = {
    id: string
    tripId: string
    token: string
    email: string | null
    phone: string | null
    status: $Enums.InviteStatus
    expiresAt: Date
    sentById: string
    createdAt: Date
    _count: InviteCountAggregateOutputType | null
    _min: InviteMinAggregateOutputType | null
    _max: InviteMaxAggregateOutputType | null
  }

  type GetInviteGroupByPayload<T extends InviteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InviteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InviteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InviteGroupByOutputType[P]>
            : GetScalarType<T[P], InviteGroupByOutputType[P]>
        }
      >
    >


  export type InviteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    token?: boolean
    email?: boolean
    phone?: boolean
    status?: boolean
    expiresAt?: boolean
    sentById?: boolean
    createdAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
    sentBy?: boolean | UserDefaultArgs<ExtArgs>
    channels?: boolean | Invite$channelsArgs<ExtArgs>
    _count?: boolean | InviteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invite"]>

  export type InviteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    token?: boolean
    email?: boolean
    phone?: boolean
    status?: boolean
    expiresAt?: boolean
    sentById?: boolean
    createdAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
    sentBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invite"]>

  export type InviteSelectScalar = {
    id?: boolean
    tripId?: boolean
    token?: boolean
    email?: boolean
    phone?: boolean
    status?: boolean
    expiresAt?: boolean
    sentById?: boolean
    createdAt?: boolean
  }

  export type InviteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
    sentBy?: boolean | UserDefaultArgs<ExtArgs>
    channels?: boolean | Invite$channelsArgs<ExtArgs>
    _count?: boolean | InviteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InviteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
    sentBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invite"
    objects: {
      trip: Prisma.$TripPayload<ExtArgs>
      sentBy: Prisma.$UserPayload<ExtArgs>
      channels: Prisma.$InviteChannelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tripId: string
      token: string
      email: string | null
      phone: string | null
      status: $Enums.InviteStatus
      expiresAt: Date
      sentById: string
      createdAt: Date
    }, ExtArgs["result"]["invite"]>
    composites: {}
  }

  type InviteGetPayload<S extends boolean | null | undefined | InviteDefaultArgs> = $Result.GetResult<Prisma.$InvitePayload, S>

  type InviteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InviteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InviteCountAggregateInputType | true
    }

  export interface InviteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invite'], meta: { name: 'Invite' } }
    /**
     * Find zero or one Invite that matches the filter.
     * @param {InviteFindUniqueArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InviteFindUniqueArgs>(args: SelectSubset<T, InviteFindUniqueArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invite that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InviteFindUniqueOrThrowArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InviteFindUniqueOrThrowArgs>(args: SelectSubset<T, InviteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteFindFirstArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InviteFindFirstArgs>(args?: SelectSubset<T, InviteFindFirstArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteFindFirstOrThrowArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InviteFindFirstOrThrowArgs>(args?: SelectSubset<T, InviteFindFirstOrThrowArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invites
     * const invites = await prisma.invite.findMany()
     * 
     * // Get first 10 Invites
     * const invites = await prisma.invite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inviteWithIdOnly = await prisma.invite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InviteFindManyArgs>(args?: SelectSubset<T, InviteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invite.
     * @param {InviteCreateArgs} args - Arguments to create a Invite.
     * @example
     * // Create one Invite
     * const Invite = await prisma.invite.create({
     *   data: {
     *     // ... data to create a Invite
     *   }
     * })
     * 
     */
    create<T extends InviteCreateArgs>(args: SelectSubset<T, InviteCreateArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invites.
     * @param {InviteCreateManyArgs} args - Arguments to create many Invites.
     * @example
     * // Create many Invites
     * const invite = await prisma.invite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InviteCreateManyArgs>(args?: SelectSubset<T, InviteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invites and returns the data saved in the database.
     * @param {InviteCreateManyAndReturnArgs} args - Arguments to create many Invites.
     * @example
     * // Create many Invites
     * const invite = await prisma.invite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invites and only return the `id`
     * const inviteWithIdOnly = await prisma.invite.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InviteCreateManyAndReturnArgs>(args?: SelectSubset<T, InviteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invite.
     * @param {InviteDeleteArgs} args - Arguments to delete one Invite.
     * @example
     * // Delete one Invite
     * const Invite = await prisma.invite.delete({
     *   where: {
     *     // ... filter to delete one Invite
     *   }
     * })
     * 
     */
    delete<T extends InviteDeleteArgs>(args: SelectSubset<T, InviteDeleteArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invite.
     * @param {InviteUpdateArgs} args - Arguments to update one Invite.
     * @example
     * // Update one Invite
     * const invite = await prisma.invite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InviteUpdateArgs>(args: SelectSubset<T, InviteUpdateArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invites.
     * @param {InviteDeleteManyArgs} args - Arguments to filter Invites to delete.
     * @example
     * // Delete a few Invites
     * const { count } = await prisma.invite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InviteDeleteManyArgs>(args?: SelectSubset<T, InviteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invites
     * const invite = await prisma.invite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InviteUpdateManyArgs>(args: SelectSubset<T, InviteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invite.
     * @param {InviteUpsertArgs} args - Arguments to update or create a Invite.
     * @example
     * // Update or create a Invite
     * const invite = await prisma.invite.upsert({
     *   create: {
     *     // ... data to create a Invite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invite we want to update
     *   }
     * })
     */
    upsert<T extends InviteUpsertArgs>(args: SelectSubset<T, InviteUpsertArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteCountArgs} args - Arguments to filter Invites to count.
     * @example
     * // Count the number of Invites
     * const count = await prisma.invite.count({
     *   where: {
     *     // ... the filter for the Invites we want to count
     *   }
     * })
    **/
    count<T extends InviteCountArgs>(
      args?: Subset<T, InviteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InviteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InviteAggregateArgs>(args: Subset<T, InviteAggregateArgs>): Prisma.PrismaPromise<GetInviteAggregateType<T>>

    /**
     * Group by Invite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InviteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InviteGroupByArgs['orderBy'] }
        : { orderBy?: InviteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InviteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInviteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invite model
   */
  readonly fields: InviteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InviteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trip<T extends TripDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TripDefaultArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sentBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    channels<T extends Invite$channelsArgs<ExtArgs> = {}>(args?: Subset<T, Invite$channelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InviteChannelPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invite model
   */ 
  interface InviteFieldRefs {
    readonly id: FieldRef<"Invite", 'String'>
    readonly tripId: FieldRef<"Invite", 'String'>
    readonly token: FieldRef<"Invite", 'String'>
    readonly email: FieldRef<"Invite", 'String'>
    readonly phone: FieldRef<"Invite", 'String'>
    readonly status: FieldRef<"Invite", 'InviteStatus'>
    readonly expiresAt: FieldRef<"Invite", 'DateTime'>
    readonly sentById: FieldRef<"Invite", 'String'>
    readonly createdAt: FieldRef<"Invite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invite findUnique
   */
  export type InviteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter, which Invite to fetch.
     */
    where: InviteWhereUniqueInput
  }

  /**
   * Invite findUniqueOrThrow
   */
  export type InviteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter, which Invite to fetch.
     */
    where: InviteWhereUniqueInput
  }

  /**
   * Invite findFirst
   */
  export type InviteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter, which Invite to fetch.
     */
    where?: InviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invites to fetch.
     */
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invites.
     */
    cursor?: InviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invites.
     */
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * Invite findFirstOrThrow
   */
  export type InviteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter, which Invite to fetch.
     */
    where?: InviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invites to fetch.
     */
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invites.
     */
    cursor?: InviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invites.
     */
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * Invite findMany
   */
  export type InviteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter, which Invites to fetch.
     */
    where?: InviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invites to fetch.
     */
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invites.
     */
    cursor?: InviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invites.
     */
    skip?: number
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * Invite create
   */
  export type InviteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * The data needed to create a Invite.
     */
    data: XOR<InviteCreateInput, InviteUncheckedCreateInput>
  }

  /**
   * Invite createMany
   */
  export type InviteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invites.
     */
    data: InviteCreateManyInput | InviteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invite createManyAndReturn
   */
  export type InviteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invites.
     */
    data: InviteCreateManyInput | InviteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invite update
   */
  export type InviteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * The data needed to update a Invite.
     */
    data: XOR<InviteUpdateInput, InviteUncheckedUpdateInput>
    /**
     * Choose, which Invite to update.
     */
    where: InviteWhereUniqueInput
  }

  /**
   * Invite updateMany
   */
  export type InviteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invites.
     */
    data: XOR<InviteUpdateManyMutationInput, InviteUncheckedUpdateManyInput>
    /**
     * Filter which Invites to update
     */
    where?: InviteWhereInput
  }

  /**
   * Invite upsert
   */
  export type InviteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * The filter to search for the Invite to update in case it exists.
     */
    where: InviteWhereUniqueInput
    /**
     * In case the Invite found by the `where` argument doesn't exist, create a new Invite with this data.
     */
    create: XOR<InviteCreateInput, InviteUncheckedCreateInput>
    /**
     * In case the Invite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InviteUpdateInput, InviteUncheckedUpdateInput>
  }

  /**
   * Invite delete
   */
  export type InviteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter which Invite to delete.
     */
    where: InviteWhereUniqueInput
  }

  /**
   * Invite deleteMany
   */
  export type InviteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invites to delete
     */
    where?: InviteWhereInput
  }

  /**
   * Invite.channels
   */
  export type Invite$channelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteChannel
     */
    select?: InviteChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteChannelInclude<ExtArgs> | null
    where?: InviteChannelWhereInput
    orderBy?: InviteChannelOrderByWithRelationInput | InviteChannelOrderByWithRelationInput[]
    cursor?: InviteChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InviteChannelScalarFieldEnum | InviteChannelScalarFieldEnum[]
  }

  /**
   * Invite without action
   */
  export type InviteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
  }


  /**
   * Model InviteChannel
   */

  export type AggregateInviteChannel = {
    _count: InviteChannelCountAggregateOutputType | null
    _min: InviteChannelMinAggregateOutputType | null
    _max: InviteChannelMaxAggregateOutputType | null
  }

  export type InviteChannelMinAggregateOutputType = {
    id: string | null
    inviteId: string | null
    channel: string | null
    externalId: string | null
  }

  export type InviteChannelMaxAggregateOutputType = {
    id: string | null
    inviteId: string | null
    channel: string | null
    externalId: string | null
  }

  export type InviteChannelCountAggregateOutputType = {
    id: number
    inviteId: number
    channel: number
    externalId: number
    _all: number
  }


  export type InviteChannelMinAggregateInputType = {
    id?: true
    inviteId?: true
    channel?: true
    externalId?: true
  }

  export type InviteChannelMaxAggregateInputType = {
    id?: true
    inviteId?: true
    channel?: true
    externalId?: true
  }

  export type InviteChannelCountAggregateInputType = {
    id?: true
    inviteId?: true
    channel?: true
    externalId?: true
    _all?: true
  }

  export type InviteChannelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InviteChannel to aggregate.
     */
    where?: InviteChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InviteChannels to fetch.
     */
    orderBy?: InviteChannelOrderByWithRelationInput | InviteChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InviteChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InviteChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InviteChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InviteChannels
    **/
    _count?: true | InviteChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InviteChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InviteChannelMaxAggregateInputType
  }

  export type GetInviteChannelAggregateType<T extends InviteChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateInviteChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInviteChannel[P]>
      : GetScalarType<T[P], AggregateInviteChannel[P]>
  }




  export type InviteChannelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteChannelWhereInput
    orderBy?: InviteChannelOrderByWithAggregationInput | InviteChannelOrderByWithAggregationInput[]
    by: InviteChannelScalarFieldEnum[] | InviteChannelScalarFieldEnum
    having?: InviteChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InviteChannelCountAggregateInputType | true
    _min?: InviteChannelMinAggregateInputType
    _max?: InviteChannelMaxAggregateInputType
  }

  export type InviteChannelGroupByOutputType = {
    id: string
    inviteId: string
    channel: string
    externalId: string | null
    _count: InviteChannelCountAggregateOutputType | null
    _min: InviteChannelMinAggregateOutputType | null
    _max: InviteChannelMaxAggregateOutputType | null
  }

  type GetInviteChannelGroupByPayload<T extends InviteChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InviteChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InviteChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InviteChannelGroupByOutputType[P]>
            : GetScalarType<T[P], InviteChannelGroupByOutputType[P]>
        }
      >
    >


  export type InviteChannelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inviteId?: boolean
    channel?: boolean
    externalId?: boolean
    invite?: boolean | InviteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inviteChannel"]>

  export type InviteChannelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inviteId?: boolean
    channel?: boolean
    externalId?: boolean
    invite?: boolean | InviteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inviteChannel"]>

  export type InviteChannelSelectScalar = {
    id?: boolean
    inviteId?: boolean
    channel?: boolean
    externalId?: boolean
  }

  export type InviteChannelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invite?: boolean | InviteDefaultArgs<ExtArgs>
  }
  export type InviteChannelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invite?: boolean | InviteDefaultArgs<ExtArgs>
  }

  export type $InviteChannelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InviteChannel"
    objects: {
      invite: Prisma.$InvitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      inviteId: string
      channel: string
      externalId: string | null
    }, ExtArgs["result"]["inviteChannel"]>
    composites: {}
  }

  type InviteChannelGetPayload<S extends boolean | null | undefined | InviteChannelDefaultArgs> = $Result.GetResult<Prisma.$InviteChannelPayload, S>

  type InviteChannelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InviteChannelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InviteChannelCountAggregateInputType | true
    }

  export interface InviteChannelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InviteChannel'], meta: { name: 'InviteChannel' } }
    /**
     * Find zero or one InviteChannel that matches the filter.
     * @param {InviteChannelFindUniqueArgs} args - Arguments to find a InviteChannel
     * @example
     * // Get one InviteChannel
     * const inviteChannel = await prisma.inviteChannel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InviteChannelFindUniqueArgs>(args: SelectSubset<T, InviteChannelFindUniqueArgs<ExtArgs>>): Prisma__InviteChannelClient<$Result.GetResult<Prisma.$InviteChannelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InviteChannel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InviteChannelFindUniqueOrThrowArgs} args - Arguments to find a InviteChannel
     * @example
     * // Get one InviteChannel
     * const inviteChannel = await prisma.inviteChannel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InviteChannelFindUniqueOrThrowArgs>(args: SelectSubset<T, InviteChannelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InviteChannelClient<$Result.GetResult<Prisma.$InviteChannelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InviteChannel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteChannelFindFirstArgs} args - Arguments to find a InviteChannel
     * @example
     * // Get one InviteChannel
     * const inviteChannel = await prisma.inviteChannel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InviteChannelFindFirstArgs>(args?: SelectSubset<T, InviteChannelFindFirstArgs<ExtArgs>>): Prisma__InviteChannelClient<$Result.GetResult<Prisma.$InviteChannelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InviteChannel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteChannelFindFirstOrThrowArgs} args - Arguments to find a InviteChannel
     * @example
     * // Get one InviteChannel
     * const inviteChannel = await prisma.inviteChannel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InviteChannelFindFirstOrThrowArgs>(args?: SelectSubset<T, InviteChannelFindFirstOrThrowArgs<ExtArgs>>): Prisma__InviteChannelClient<$Result.GetResult<Prisma.$InviteChannelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InviteChannels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteChannelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InviteChannels
     * const inviteChannels = await prisma.inviteChannel.findMany()
     * 
     * // Get first 10 InviteChannels
     * const inviteChannels = await prisma.inviteChannel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inviteChannelWithIdOnly = await prisma.inviteChannel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InviteChannelFindManyArgs>(args?: SelectSubset<T, InviteChannelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InviteChannelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InviteChannel.
     * @param {InviteChannelCreateArgs} args - Arguments to create a InviteChannel.
     * @example
     * // Create one InviteChannel
     * const InviteChannel = await prisma.inviteChannel.create({
     *   data: {
     *     // ... data to create a InviteChannel
     *   }
     * })
     * 
     */
    create<T extends InviteChannelCreateArgs>(args: SelectSubset<T, InviteChannelCreateArgs<ExtArgs>>): Prisma__InviteChannelClient<$Result.GetResult<Prisma.$InviteChannelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InviteChannels.
     * @param {InviteChannelCreateManyArgs} args - Arguments to create many InviteChannels.
     * @example
     * // Create many InviteChannels
     * const inviteChannel = await prisma.inviteChannel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InviteChannelCreateManyArgs>(args?: SelectSubset<T, InviteChannelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InviteChannels and returns the data saved in the database.
     * @param {InviteChannelCreateManyAndReturnArgs} args - Arguments to create many InviteChannels.
     * @example
     * // Create many InviteChannels
     * const inviteChannel = await prisma.inviteChannel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InviteChannels and only return the `id`
     * const inviteChannelWithIdOnly = await prisma.inviteChannel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InviteChannelCreateManyAndReturnArgs>(args?: SelectSubset<T, InviteChannelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InviteChannelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InviteChannel.
     * @param {InviteChannelDeleteArgs} args - Arguments to delete one InviteChannel.
     * @example
     * // Delete one InviteChannel
     * const InviteChannel = await prisma.inviteChannel.delete({
     *   where: {
     *     // ... filter to delete one InviteChannel
     *   }
     * })
     * 
     */
    delete<T extends InviteChannelDeleteArgs>(args: SelectSubset<T, InviteChannelDeleteArgs<ExtArgs>>): Prisma__InviteChannelClient<$Result.GetResult<Prisma.$InviteChannelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InviteChannel.
     * @param {InviteChannelUpdateArgs} args - Arguments to update one InviteChannel.
     * @example
     * // Update one InviteChannel
     * const inviteChannel = await prisma.inviteChannel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InviteChannelUpdateArgs>(args: SelectSubset<T, InviteChannelUpdateArgs<ExtArgs>>): Prisma__InviteChannelClient<$Result.GetResult<Prisma.$InviteChannelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InviteChannels.
     * @param {InviteChannelDeleteManyArgs} args - Arguments to filter InviteChannels to delete.
     * @example
     * // Delete a few InviteChannels
     * const { count } = await prisma.inviteChannel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InviteChannelDeleteManyArgs>(args?: SelectSubset<T, InviteChannelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InviteChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InviteChannels
     * const inviteChannel = await prisma.inviteChannel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InviteChannelUpdateManyArgs>(args: SelectSubset<T, InviteChannelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InviteChannel.
     * @param {InviteChannelUpsertArgs} args - Arguments to update or create a InviteChannel.
     * @example
     * // Update or create a InviteChannel
     * const inviteChannel = await prisma.inviteChannel.upsert({
     *   create: {
     *     // ... data to create a InviteChannel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InviteChannel we want to update
     *   }
     * })
     */
    upsert<T extends InviteChannelUpsertArgs>(args: SelectSubset<T, InviteChannelUpsertArgs<ExtArgs>>): Prisma__InviteChannelClient<$Result.GetResult<Prisma.$InviteChannelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InviteChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteChannelCountArgs} args - Arguments to filter InviteChannels to count.
     * @example
     * // Count the number of InviteChannels
     * const count = await prisma.inviteChannel.count({
     *   where: {
     *     // ... the filter for the InviteChannels we want to count
     *   }
     * })
    **/
    count<T extends InviteChannelCountArgs>(
      args?: Subset<T, InviteChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InviteChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InviteChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InviteChannelAggregateArgs>(args: Subset<T, InviteChannelAggregateArgs>): Prisma.PrismaPromise<GetInviteChannelAggregateType<T>>

    /**
     * Group by InviteChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InviteChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InviteChannelGroupByArgs['orderBy'] }
        : { orderBy?: InviteChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InviteChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInviteChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InviteChannel model
   */
  readonly fields: InviteChannelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InviteChannel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InviteChannelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invite<T extends InviteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InviteDefaultArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InviteChannel model
   */ 
  interface InviteChannelFieldRefs {
    readonly id: FieldRef<"InviteChannel", 'String'>
    readonly inviteId: FieldRef<"InviteChannel", 'String'>
    readonly channel: FieldRef<"InviteChannel", 'String'>
    readonly externalId: FieldRef<"InviteChannel", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InviteChannel findUnique
   */
  export type InviteChannelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteChannel
     */
    select?: InviteChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteChannelInclude<ExtArgs> | null
    /**
     * Filter, which InviteChannel to fetch.
     */
    where: InviteChannelWhereUniqueInput
  }

  /**
   * InviteChannel findUniqueOrThrow
   */
  export type InviteChannelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteChannel
     */
    select?: InviteChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteChannelInclude<ExtArgs> | null
    /**
     * Filter, which InviteChannel to fetch.
     */
    where: InviteChannelWhereUniqueInput
  }

  /**
   * InviteChannel findFirst
   */
  export type InviteChannelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteChannel
     */
    select?: InviteChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteChannelInclude<ExtArgs> | null
    /**
     * Filter, which InviteChannel to fetch.
     */
    where?: InviteChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InviteChannels to fetch.
     */
    orderBy?: InviteChannelOrderByWithRelationInput | InviteChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InviteChannels.
     */
    cursor?: InviteChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InviteChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InviteChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InviteChannels.
     */
    distinct?: InviteChannelScalarFieldEnum | InviteChannelScalarFieldEnum[]
  }

  /**
   * InviteChannel findFirstOrThrow
   */
  export type InviteChannelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteChannel
     */
    select?: InviteChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteChannelInclude<ExtArgs> | null
    /**
     * Filter, which InviteChannel to fetch.
     */
    where?: InviteChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InviteChannels to fetch.
     */
    orderBy?: InviteChannelOrderByWithRelationInput | InviteChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InviteChannels.
     */
    cursor?: InviteChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InviteChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InviteChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InviteChannels.
     */
    distinct?: InviteChannelScalarFieldEnum | InviteChannelScalarFieldEnum[]
  }

  /**
   * InviteChannel findMany
   */
  export type InviteChannelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteChannel
     */
    select?: InviteChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteChannelInclude<ExtArgs> | null
    /**
     * Filter, which InviteChannels to fetch.
     */
    where?: InviteChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InviteChannels to fetch.
     */
    orderBy?: InviteChannelOrderByWithRelationInput | InviteChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InviteChannels.
     */
    cursor?: InviteChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InviteChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InviteChannels.
     */
    skip?: number
    distinct?: InviteChannelScalarFieldEnum | InviteChannelScalarFieldEnum[]
  }

  /**
   * InviteChannel create
   */
  export type InviteChannelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteChannel
     */
    select?: InviteChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteChannelInclude<ExtArgs> | null
    /**
     * The data needed to create a InviteChannel.
     */
    data: XOR<InviteChannelCreateInput, InviteChannelUncheckedCreateInput>
  }

  /**
   * InviteChannel createMany
   */
  export type InviteChannelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InviteChannels.
     */
    data: InviteChannelCreateManyInput | InviteChannelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InviteChannel createManyAndReturn
   */
  export type InviteChannelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteChannel
     */
    select?: InviteChannelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InviteChannels.
     */
    data: InviteChannelCreateManyInput | InviteChannelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteChannelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InviteChannel update
   */
  export type InviteChannelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteChannel
     */
    select?: InviteChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteChannelInclude<ExtArgs> | null
    /**
     * The data needed to update a InviteChannel.
     */
    data: XOR<InviteChannelUpdateInput, InviteChannelUncheckedUpdateInput>
    /**
     * Choose, which InviteChannel to update.
     */
    where: InviteChannelWhereUniqueInput
  }

  /**
   * InviteChannel updateMany
   */
  export type InviteChannelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InviteChannels.
     */
    data: XOR<InviteChannelUpdateManyMutationInput, InviteChannelUncheckedUpdateManyInput>
    /**
     * Filter which InviteChannels to update
     */
    where?: InviteChannelWhereInput
  }

  /**
   * InviteChannel upsert
   */
  export type InviteChannelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteChannel
     */
    select?: InviteChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteChannelInclude<ExtArgs> | null
    /**
     * The filter to search for the InviteChannel to update in case it exists.
     */
    where: InviteChannelWhereUniqueInput
    /**
     * In case the InviteChannel found by the `where` argument doesn't exist, create a new InviteChannel with this data.
     */
    create: XOR<InviteChannelCreateInput, InviteChannelUncheckedCreateInput>
    /**
     * In case the InviteChannel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InviteChannelUpdateInput, InviteChannelUncheckedUpdateInput>
  }

  /**
   * InviteChannel delete
   */
  export type InviteChannelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteChannel
     */
    select?: InviteChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteChannelInclude<ExtArgs> | null
    /**
     * Filter which InviteChannel to delete.
     */
    where: InviteChannelWhereUniqueInput
  }

  /**
   * InviteChannel deleteMany
   */
  export type InviteChannelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InviteChannels to delete
     */
    where?: InviteChannelWhereInput
  }

  /**
   * InviteChannel without action
   */
  export type InviteChannelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteChannel
     */
    select?: InviteChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteChannelInclude<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityAvgAggregateOutputType = {
    cost: Decimal | null
  }

  export type ActivitySumAggregateOutputType = {
    cost: Decimal | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    tripId: string | null
    title: string | null
    description: string | null
    location: string | null
    startTime: Date | null
    endTime: Date | null
    cost: Decimal | null
    currency: string | null
    category: string | null
    proposedBy: string | null
    votingEndsAt: Date | null
    status: string | null
    createdAt: Date | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    tripId: string | null
    title: string | null
    description: string | null
    location: string | null
    startTime: Date | null
    endTime: Date | null
    cost: Decimal | null
    currency: string | null
    category: string | null
    proposedBy: string | null
    votingEndsAt: Date | null
    status: string | null
    createdAt: Date | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    tripId: number
    title: number
    description: number
    location: number
    startTime: number
    endTime: number
    cost: number
    currency: number
    category: number
    proposedBy: number
    votingEndsAt: number
    status: number
    createdAt: number
    _all: number
  }


  export type ActivityAvgAggregateInputType = {
    cost?: true
  }

  export type ActivitySumAggregateInputType = {
    cost?: true
  }

  export type ActivityMinAggregateInputType = {
    id?: true
    tripId?: true
    title?: true
    description?: true
    location?: true
    startTime?: true
    endTime?: true
    cost?: true
    currency?: true
    category?: true
    proposedBy?: true
    votingEndsAt?: true
    status?: true
    createdAt?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    tripId?: true
    title?: true
    description?: true
    location?: true
    startTime?: true
    endTime?: true
    cost?: true
    currency?: true
    category?: true
    proposedBy?: true
    votingEndsAt?: true
    status?: true
    createdAt?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    tripId?: true
    title?: true
    description?: true
    location?: true
    startTime?: true
    endTime?: true
    cost?: true
    currency?: true
    category?: true
    proposedBy?: true
    votingEndsAt?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _avg?: ActivityAvgAggregateInputType
    _sum?: ActivitySumAggregateInputType
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: string
    tripId: string
    title: string
    description: string | null
    location: string | null
    startTime: Date | null
    endTime: Date | null
    cost: Decimal | null
    currency: string
    category: string
    proposedBy: string
    votingEndsAt: Date | null
    status: string
    createdAt: Date
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    startTime?: boolean
    endTime?: boolean
    cost?: boolean
    currency?: boolean
    category?: boolean
    proposedBy?: boolean
    votingEndsAt?: boolean
    status?: boolean
    createdAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
    proposer?: boolean | UserDefaultArgs<ExtArgs>
    votes?: boolean | Activity$votesArgs<ExtArgs>
    bookings?: boolean | Activity$bookingsArgs<ExtArgs>
    mediaItems?: boolean | Activity$mediaItemsArgs<ExtArgs>
    _count?: boolean | ActivityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    startTime?: boolean
    endTime?: boolean
    cost?: boolean
    currency?: boolean
    category?: boolean
    proposedBy?: boolean
    votingEndsAt?: boolean
    status?: boolean
    createdAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
    proposer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    tripId?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    startTime?: boolean
    endTime?: boolean
    cost?: boolean
    currency?: boolean
    category?: boolean
    proposedBy?: boolean
    votingEndsAt?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
    proposer?: boolean | UserDefaultArgs<ExtArgs>
    votes?: boolean | Activity$votesArgs<ExtArgs>
    bookings?: boolean | Activity$bookingsArgs<ExtArgs>
    mediaItems?: boolean | Activity$mediaItemsArgs<ExtArgs>
    _count?: boolean | ActivityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
    proposer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {
      trip: Prisma.$TripPayload<ExtArgs>
      proposer: Prisma.$UserPayload<ExtArgs>
      votes: Prisma.$VotePayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      mediaItems: Prisma.$MediaItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tripId: string
      title: string
      description: string | null
      location: string | null
      startTime: Date | null
      endTime: Date | null
      cost: Prisma.Decimal | null
      currency: string
      category: string
      proposedBy: string
      votingEndsAt: Date | null
      status: string
      createdAt: Date
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trip<T extends TripDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TripDefaultArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    proposer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    votes<T extends Activity$votesArgs<ExtArgs> = {}>(args?: Subset<T, Activity$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findMany"> | Null>
    bookings<T extends Activity$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Activity$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    mediaItems<T extends Activity$mediaItemsArgs<ExtArgs> = {}>(args?: Subset<T, Activity$mediaItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */ 
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'String'>
    readonly tripId: FieldRef<"Activity", 'String'>
    readonly title: FieldRef<"Activity", 'String'>
    readonly description: FieldRef<"Activity", 'String'>
    readonly location: FieldRef<"Activity", 'String'>
    readonly startTime: FieldRef<"Activity", 'DateTime'>
    readonly endTime: FieldRef<"Activity", 'DateTime'>
    readonly cost: FieldRef<"Activity", 'Decimal'>
    readonly currency: FieldRef<"Activity", 'String'>
    readonly category: FieldRef<"Activity", 'String'>
    readonly proposedBy: FieldRef<"Activity", 'String'>
    readonly votingEndsAt: FieldRef<"Activity", 'DateTime'>
    readonly status: FieldRef<"Activity", 'String'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
  }

  /**
   * Activity.votes
   */
  export type Activity$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    where?: VoteWhereInput
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    cursor?: VoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Activity.bookings
   */
  export type Activity$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Activity.mediaItems
   */
  export type Activity$mediaItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaItem
     */
    select?: MediaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaItemInclude<ExtArgs> | null
    where?: MediaItemWhereInput
    orderBy?: MediaItemOrderByWithRelationInput | MediaItemOrderByWithRelationInput[]
    cursor?: MediaItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaItemScalarFieldEnum | MediaItemScalarFieldEnum[]
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
  }


  /**
   * Model Vote
   */

  export type AggregateVote = {
    _count: VoteCountAggregateOutputType | null
    _min: VoteMinAggregateOutputType | null
    _max: VoteMaxAggregateOutputType | null
  }

  export type VoteMinAggregateOutputType = {
    id: string | null
    activityId: string | null
    userId: string | null
    option: string | null
  }

  export type VoteMaxAggregateOutputType = {
    id: string | null
    activityId: string | null
    userId: string | null
    option: string | null
  }

  export type VoteCountAggregateOutputType = {
    id: number
    activityId: number
    userId: number
    option: number
    _all: number
  }


  export type VoteMinAggregateInputType = {
    id?: true
    activityId?: true
    userId?: true
    option?: true
  }

  export type VoteMaxAggregateInputType = {
    id?: true
    activityId?: true
    userId?: true
    option?: true
  }

  export type VoteCountAggregateInputType = {
    id?: true
    activityId?: true
    userId?: true
    option?: true
    _all?: true
  }

  export type VoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vote to aggregate.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Votes
    **/
    _count?: true | VoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoteMaxAggregateInputType
  }

  export type GetVoteAggregateType<T extends VoteAggregateArgs> = {
        [P in keyof T & keyof AggregateVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVote[P]>
      : GetScalarType<T[P], AggregateVote[P]>
  }




  export type VoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoteWhereInput
    orderBy?: VoteOrderByWithAggregationInput | VoteOrderByWithAggregationInput[]
    by: VoteScalarFieldEnum[] | VoteScalarFieldEnum
    having?: VoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoteCountAggregateInputType | true
    _min?: VoteMinAggregateInputType
    _max?: VoteMaxAggregateInputType
  }

  export type VoteGroupByOutputType = {
    id: string
    activityId: string
    userId: string
    option: string
    _count: VoteCountAggregateOutputType | null
    _min: VoteMinAggregateOutputType | null
    _max: VoteMaxAggregateOutputType | null
  }

  type GetVoteGroupByPayload<T extends VoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoteGroupByOutputType[P]>
            : GetScalarType<T[P], VoteGroupByOutputType[P]>
        }
      >
    >


  export type VoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activityId?: boolean
    userId?: boolean
    option?: boolean
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vote"]>

  export type VoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activityId?: boolean
    userId?: boolean
    option?: boolean
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vote"]>

  export type VoteSelectScalar = {
    id?: boolean
    activityId?: boolean
    userId?: boolean
    option?: boolean
  }

  export type VoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vote"
    objects: {
      activity: Prisma.$ActivityPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      activityId: string
      userId: string
      option: string
    }, ExtArgs["result"]["vote"]>
    composites: {}
  }

  type VoteGetPayload<S extends boolean | null | undefined | VoteDefaultArgs> = $Result.GetResult<Prisma.$VotePayload, S>

  type VoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VoteCountAggregateInputType | true
    }

  export interface VoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vote'], meta: { name: 'Vote' } }
    /**
     * Find zero or one Vote that matches the filter.
     * @param {VoteFindUniqueArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoteFindUniqueArgs>(args: SelectSubset<T, VoteFindUniqueArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Vote that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VoteFindUniqueOrThrowArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoteFindUniqueOrThrowArgs>(args: SelectSubset<T, VoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Vote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindFirstArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoteFindFirstArgs>(args?: SelectSubset<T, VoteFindFirstArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Vote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindFirstOrThrowArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoteFindFirstOrThrowArgs>(args?: SelectSubset<T, VoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Votes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Votes
     * const votes = await prisma.vote.findMany()
     * 
     * // Get first 10 Votes
     * const votes = await prisma.vote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voteWithIdOnly = await prisma.vote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoteFindManyArgs>(args?: SelectSubset<T, VoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Vote.
     * @param {VoteCreateArgs} args - Arguments to create a Vote.
     * @example
     * // Create one Vote
     * const Vote = await prisma.vote.create({
     *   data: {
     *     // ... data to create a Vote
     *   }
     * })
     * 
     */
    create<T extends VoteCreateArgs>(args: SelectSubset<T, VoteCreateArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Votes.
     * @param {VoteCreateManyArgs} args - Arguments to create many Votes.
     * @example
     * // Create many Votes
     * const vote = await prisma.vote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoteCreateManyArgs>(args?: SelectSubset<T, VoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Votes and returns the data saved in the database.
     * @param {VoteCreateManyAndReturnArgs} args - Arguments to create many Votes.
     * @example
     * // Create many Votes
     * const vote = await prisma.vote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Votes and only return the `id`
     * const voteWithIdOnly = await prisma.vote.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoteCreateManyAndReturnArgs>(args?: SelectSubset<T, VoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Vote.
     * @param {VoteDeleteArgs} args - Arguments to delete one Vote.
     * @example
     * // Delete one Vote
     * const Vote = await prisma.vote.delete({
     *   where: {
     *     // ... filter to delete one Vote
     *   }
     * })
     * 
     */
    delete<T extends VoteDeleteArgs>(args: SelectSubset<T, VoteDeleteArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Vote.
     * @param {VoteUpdateArgs} args - Arguments to update one Vote.
     * @example
     * // Update one Vote
     * const vote = await prisma.vote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoteUpdateArgs>(args: SelectSubset<T, VoteUpdateArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Votes.
     * @param {VoteDeleteManyArgs} args - Arguments to filter Votes to delete.
     * @example
     * // Delete a few Votes
     * const { count } = await prisma.vote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoteDeleteManyArgs>(args?: SelectSubset<T, VoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Votes
     * const vote = await prisma.vote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoteUpdateManyArgs>(args: SelectSubset<T, VoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vote.
     * @param {VoteUpsertArgs} args - Arguments to update or create a Vote.
     * @example
     * // Update or create a Vote
     * const vote = await prisma.vote.upsert({
     *   create: {
     *     // ... data to create a Vote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vote we want to update
     *   }
     * })
     */
    upsert<T extends VoteUpsertArgs>(args: SelectSubset<T, VoteUpsertArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteCountArgs} args - Arguments to filter Votes to count.
     * @example
     * // Count the number of Votes
     * const count = await prisma.vote.count({
     *   where: {
     *     // ... the filter for the Votes we want to count
     *   }
     * })
    **/
    count<T extends VoteCountArgs>(
      args?: Subset<T, VoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoteAggregateArgs>(args: Subset<T, VoteAggregateArgs>): Prisma.PrismaPromise<GetVoteAggregateType<T>>

    /**
     * Group by Vote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoteGroupByArgs['orderBy'] }
        : { orderBy?: VoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vote model
   */
  readonly fields: VoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activity<T extends ActivityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivityDefaultArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vote model
   */ 
  interface VoteFieldRefs {
    readonly id: FieldRef<"Vote", 'String'>
    readonly activityId: FieldRef<"Vote", 'String'>
    readonly userId: FieldRef<"Vote", 'String'>
    readonly option: FieldRef<"Vote", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Vote findUnique
   */
  export type VoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote findUniqueOrThrow
   */
  export type VoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote findFirst
   */
  export type VoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Votes.
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Votes.
     */
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Vote findFirstOrThrow
   */
  export type VoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Votes.
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Votes.
     */
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Vote findMany
   */
  export type VoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Votes to fetch.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Votes.
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Vote create
   */
  export type VoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Vote.
     */
    data: XOR<VoteCreateInput, VoteUncheckedCreateInput>
  }

  /**
   * Vote createMany
   */
  export type VoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Votes.
     */
    data: VoteCreateManyInput | VoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vote createManyAndReturn
   */
  export type VoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Votes.
     */
    data: VoteCreateManyInput | VoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vote update
   */
  export type VoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Vote.
     */
    data: XOR<VoteUpdateInput, VoteUncheckedUpdateInput>
    /**
     * Choose, which Vote to update.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote updateMany
   */
  export type VoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Votes.
     */
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyInput>
    /**
     * Filter which Votes to update
     */
    where?: VoteWhereInput
  }

  /**
   * Vote upsert
   */
  export type VoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Vote to update in case it exists.
     */
    where: VoteWhereUniqueInput
    /**
     * In case the Vote found by the `where` argument doesn't exist, create a new Vote with this data.
     */
    create: XOR<VoteCreateInput, VoteUncheckedCreateInput>
    /**
     * In case the Vote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoteUpdateInput, VoteUncheckedUpdateInput>
  }

  /**
   * Vote delete
   */
  export type VoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter which Vote to delete.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote deleteMany
   */
  export type VoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Votes to delete
     */
    where?: VoteWhereInput
  }

  /**
   * Vote without action
   */
  export type VoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingMinAggregateOutputType = {
    id: string | null
    tripId: string | null
    activityId: string | null
    bookedBy: string | null
    confirmationNum: string | null
    status: $Enums.BookingStatus | null
    receiptUrl: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: string | null
    tripId: string | null
    activityId: string | null
    bookedBy: string | null
    confirmationNum: string | null
    status: $Enums.BookingStatus | null
    receiptUrl: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    tripId: number
    activityId: number
    bookedBy: number
    confirmationNum: number
    status: number
    receiptUrl: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookingMinAggregateInputType = {
    id?: true
    tripId?: true
    activityId?: true
    bookedBy?: true
    confirmationNum?: true
    status?: true
    receiptUrl?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    tripId?: true
    activityId?: true
    bookedBy?: true
    confirmationNum?: true
    status?: true
    receiptUrl?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    tripId?: true
    activityId?: true
    bookedBy?: true
    confirmationNum?: true
    status?: true
    receiptUrl?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: string
    tripId: string
    activityId: string | null
    bookedBy: string
    confirmationNum: string | null
    status: $Enums.BookingStatus
    receiptUrl: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: BookingCountAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    activityId?: boolean
    bookedBy?: boolean
    confirmationNum?: boolean
    status?: boolean
    receiptUrl?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
    activity?: boolean | Booking$activityArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    activityId?: boolean
    bookedBy?: boolean
    confirmationNum?: boolean
    status?: boolean
    receiptUrl?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
    activity?: boolean | Booking$activityArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    tripId?: boolean
    activityId?: boolean
    bookedBy?: boolean
    confirmationNum?: boolean
    status?: boolean
    receiptUrl?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
    activity?: boolean | Booking$activityArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
    activity?: boolean | Booking$activityArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      trip: Prisma.$TripPayload<ExtArgs>
      activity: Prisma.$ActivityPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tripId: string
      activityId: string | null
      bookedBy: string
      confirmationNum: string | null
      status: $Enums.BookingStatus
      receiptUrl: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trip<T extends TripDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TripDefaultArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    activity<T extends Booking$activityArgs<ExtArgs> = {}>(args?: Subset<T, Booking$activityArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */ 
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'String'>
    readonly tripId: FieldRef<"Booking", 'String'>
    readonly activityId: FieldRef<"Booking", 'String'>
    readonly bookedBy: FieldRef<"Booking", 'String'>
    readonly confirmationNum: FieldRef<"Booking", 'String'>
    readonly status: FieldRef<"Booking", 'BookingStatus'>
    readonly receiptUrl: FieldRef<"Booking", 'String'>
    readonly notes: FieldRef<"Booking", 'String'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
    readonly updatedAt: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
  }

  /**
   * Booking.activity
   */
  export type Booking$activityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model TripMessage
   */

  export type AggregateTripMessage = {
    _count: TripMessageCountAggregateOutputType | null
    _min: TripMessageMinAggregateOutputType | null
    _max: TripMessageMaxAggregateOutputType | null
  }

  export type TripMessageMinAggregateOutputType = {
    id: string | null
    tripId: string | null
    userId: string | null
    content: string | null
    messageType: $Enums.MessageType | null
    editedAt: Date | null
    parentId: string | null
    createdAt: Date | null
  }

  export type TripMessageMaxAggregateOutputType = {
    id: string | null
    tripId: string | null
    userId: string | null
    content: string | null
    messageType: $Enums.MessageType | null
    editedAt: Date | null
    parentId: string | null
    createdAt: Date | null
  }

  export type TripMessageCountAggregateOutputType = {
    id: number
    tripId: number
    userId: number
    content: number
    messageType: number
    editedAt: number
    parentId: number
    createdAt: number
    _all: number
  }


  export type TripMessageMinAggregateInputType = {
    id?: true
    tripId?: true
    userId?: true
    content?: true
    messageType?: true
    editedAt?: true
    parentId?: true
    createdAt?: true
  }

  export type TripMessageMaxAggregateInputType = {
    id?: true
    tripId?: true
    userId?: true
    content?: true
    messageType?: true
    editedAt?: true
    parentId?: true
    createdAt?: true
  }

  export type TripMessageCountAggregateInputType = {
    id?: true
    tripId?: true
    userId?: true
    content?: true
    messageType?: true
    editedAt?: true
    parentId?: true
    createdAt?: true
    _all?: true
  }

  export type TripMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TripMessage to aggregate.
     */
    where?: TripMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripMessages to fetch.
     */
    orderBy?: TripMessageOrderByWithRelationInput | TripMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TripMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TripMessages
    **/
    _count?: true | TripMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TripMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TripMessageMaxAggregateInputType
  }

  export type GetTripMessageAggregateType<T extends TripMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateTripMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTripMessage[P]>
      : GetScalarType<T[P], AggregateTripMessage[P]>
  }




  export type TripMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripMessageWhereInput
    orderBy?: TripMessageOrderByWithAggregationInput | TripMessageOrderByWithAggregationInput[]
    by: TripMessageScalarFieldEnum[] | TripMessageScalarFieldEnum
    having?: TripMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TripMessageCountAggregateInputType | true
    _min?: TripMessageMinAggregateInputType
    _max?: TripMessageMaxAggregateInputType
  }

  export type TripMessageGroupByOutputType = {
    id: string
    tripId: string
    userId: string
    content: string
    messageType: $Enums.MessageType
    editedAt: Date | null
    parentId: string | null
    createdAt: Date
    _count: TripMessageCountAggregateOutputType | null
    _min: TripMessageMinAggregateOutputType | null
    _max: TripMessageMaxAggregateOutputType | null
  }

  type GetTripMessageGroupByPayload<T extends TripMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TripMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TripMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TripMessageGroupByOutputType[P]>
            : GetScalarType<T[P], TripMessageGroupByOutputType[P]>
        }
      >
    >


  export type TripMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    userId?: boolean
    content?: boolean
    messageType?: boolean
    editedAt?: boolean
    parentId?: boolean
    createdAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | TripMessage$parentArgs<ExtArgs>
    edits?: boolean | TripMessage$editsArgs<ExtArgs>
    reactions?: boolean | TripMessage$reactionsArgs<ExtArgs>
    readReceipts?: boolean | TripMessage$readReceiptsArgs<ExtArgs>
    _count?: boolean | TripMessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tripMessage"]>

  export type TripMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    userId?: boolean
    content?: boolean
    messageType?: boolean
    editedAt?: boolean
    parentId?: boolean
    createdAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | TripMessage$parentArgs<ExtArgs>
  }, ExtArgs["result"]["tripMessage"]>

  export type TripMessageSelectScalar = {
    id?: boolean
    tripId?: boolean
    userId?: boolean
    content?: boolean
    messageType?: boolean
    editedAt?: boolean
    parentId?: boolean
    createdAt?: boolean
  }

  export type TripMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | TripMessage$parentArgs<ExtArgs>
    edits?: boolean | TripMessage$editsArgs<ExtArgs>
    reactions?: boolean | TripMessage$reactionsArgs<ExtArgs>
    readReceipts?: boolean | TripMessage$readReceiptsArgs<ExtArgs>
    _count?: boolean | TripMessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TripMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | TripMessage$parentArgs<ExtArgs>
  }

  export type $TripMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TripMessage"
    objects: {
      trip: Prisma.$TripPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      parent: Prisma.$TripMessagePayload<ExtArgs> | null
      edits: Prisma.$TripMessagePayload<ExtArgs>[]
      reactions: Prisma.$MessageReactionPayload<ExtArgs>[]
      readReceipts: Prisma.$MessageReadReceiptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tripId: string
      userId: string
      content: string
      messageType: $Enums.MessageType
      editedAt: Date | null
      parentId: string | null
      createdAt: Date
    }, ExtArgs["result"]["tripMessage"]>
    composites: {}
  }

  type TripMessageGetPayload<S extends boolean | null | undefined | TripMessageDefaultArgs> = $Result.GetResult<Prisma.$TripMessagePayload, S>

  type TripMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TripMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TripMessageCountAggregateInputType | true
    }

  export interface TripMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TripMessage'], meta: { name: 'TripMessage' } }
    /**
     * Find zero or one TripMessage that matches the filter.
     * @param {TripMessageFindUniqueArgs} args - Arguments to find a TripMessage
     * @example
     * // Get one TripMessage
     * const tripMessage = await prisma.tripMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TripMessageFindUniqueArgs>(args: SelectSubset<T, TripMessageFindUniqueArgs<ExtArgs>>): Prisma__TripMessageClient<$Result.GetResult<Prisma.$TripMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TripMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TripMessageFindUniqueOrThrowArgs} args - Arguments to find a TripMessage
     * @example
     * // Get one TripMessage
     * const tripMessage = await prisma.tripMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TripMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, TripMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TripMessageClient<$Result.GetResult<Prisma.$TripMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TripMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMessageFindFirstArgs} args - Arguments to find a TripMessage
     * @example
     * // Get one TripMessage
     * const tripMessage = await prisma.tripMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TripMessageFindFirstArgs>(args?: SelectSubset<T, TripMessageFindFirstArgs<ExtArgs>>): Prisma__TripMessageClient<$Result.GetResult<Prisma.$TripMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TripMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMessageFindFirstOrThrowArgs} args - Arguments to find a TripMessage
     * @example
     * // Get one TripMessage
     * const tripMessage = await prisma.tripMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TripMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, TripMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__TripMessageClient<$Result.GetResult<Prisma.$TripMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TripMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TripMessages
     * const tripMessages = await prisma.tripMessage.findMany()
     * 
     * // Get first 10 TripMessages
     * const tripMessages = await prisma.tripMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tripMessageWithIdOnly = await prisma.tripMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TripMessageFindManyArgs>(args?: SelectSubset<T, TripMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TripMessage.
     * @param {TripMessageCreateArgs} args - Arguments to create a TripMessage.
     * @example
     * // Create one TripMessage
     * const TripMessage = await prisma.tripMessage.create({
     *   data: {
     *     // ... data to create a TripMessage
     *   }
     * })
     * 
     */
    create<T extends TripMessageCreateArgs>(args: SelectSubset<T, TripMessageCreateArgs<ExtArgs>>): Prisma__TripMessageClient<$Result.GetResult<Prisma.$TripMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TripMessages.
     * @param {TripMessageCreateManyArgs} args - Arguments to create many TripMessages.
     * @example
     * // Create many TripMessages
     * const tripMessage = await prisma.tripMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TripMessageCreateManyArgs>(args?: SelectSubset<T, TripMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TripMessages and returns the data saved in the database.
     * @param {TripMessageCreateManyAndReturnArgs} args - Arguments to create many TripMessages.
     * @example
     * // Create many TripMessages
     * const tripMessage = await prisma.tripMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TripMessages and only return the `id`
     * const tripMessageWithIdOnly = await prisma.tripMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TripMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, TripMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TripMessage.
     * @param {TripMessageDeleteArgs} args - Arguments to delete one TripMessage.
     * @example
     * // Delete one TripMessage
     * const TripMessage = await prisma.tripMessage.delete({
     *   where: {
     *     // ... filter to delete one TripMessage
     *   }
     * })
     * 
     */
    delete<T extends TripMessageDeleteArgs>(args: SelectSubset<T, TripMessageDeleteArgs<ExtArgs>>): Prisma__TripMessageClient<$Result.GetResult<Prisma.$TripMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TripMessage.
     * @param {TripMessageUpdateArgs} args - Arguments to update one TripMessage.
     * @example
     * // Update one TripMessage
     * const tripMessage = await prisma.tripMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TripMessageUpdateArgs>(args: SelectSubset<T, TripMessageUpdateArgs<ExtArgs>>): Prisma__TripMessageClient<$Result.GetResult<Prisma.$TripMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TripMessages.
     * @param {TripMessageDeleteManyArgs} args - Arguments to filter TripMessages to delete.
     * @example
     * // Delete a few TripMessages
     * const { count } = await prisma.tripMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TripMessageDeleteManyArgs>(args?: SelectSubset<T, TripMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TripMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TripMessages
     * const tripMessage = await prisma.tripMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TripMessageUpdateManyArgs>(args: SelectSubset<T, TripMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TripMessage.
     * @param {TripMessageUpsertArgs} args - Arguments to update or create a TripMessage.
     * @example
     * // Update or create a TripMessage
     * const tripMessage = await prisma.tripMessage.upsert({
     *   create: {
     *     // ... data to create a TripMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TripMessage we want to update
     *   }
     * })
     */
    upsert<T extends TripMessageUpsertArgs>(args: SelectSubset<T, TripMessageUpsertArgs<ExtArgs>>): Prisma__TripMessageClient<$Result.GetResult<Prisma.$TripMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TripMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMessageCountArgs} args - Arguments to filter TripMessages to count.
     * @example
     * // Count the number of TripMessages
     * const count = await prisma.tripMessage.count({
     *   where: {
     *     // ... the filter for the TripMessages we want to count
     *   }
     * })
    **/
    count<T extends TripMessageCountArgs>(
      args?: Subset<T, TripMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TripMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TripMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TripMessageAggregateArgs>(args: Subset<T, TripMessageAggregateArgs>): Prisma.PrismaPromise<GetTripMessageAggregateType<T>>

    /**
     * Group by TripMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TripMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TripMessageGroupByArgs['orderBy'] }
        : { orderBy?: TripMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TripMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTripMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TripMessage model
   */
  readonly fields: TripMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TripMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TripMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trip<T extends TripDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TripDefaultArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parent<T extends TripMessage$parentArgs<ExtArgs> = {}>(args?: Subset<T, TripMessage$parentArgs<ExtArgs>>): Prisma__TripMessageClient<$Result.GetResult<Prisma.$TripMessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    edits<T extends TripMessage$editsArgs<ExtArgs> = {}>(args?: Subset<T, TripMessage$editsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripMessagePayload<ExtArgs>, T, "findMany"> | Null>
    reactions<T extends TripMessage$reactionsArgs<ExtArgs> = {}>(args?: Subset<T, TripMessage$reactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReactionPayload<ExtArgs>, T, "findMany"> | Null>
    readReceipts<T extends TripMessage$readReceiptsArgs<ExtArgs> = {}>(args?: Subset<T, TripMessage$readReceiptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReadReceiptPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TripMessage model
   */ 
  interface TripMessageFieldRefs {
    readonly id: FieldRef<"TripMessage", 'String'>
    readonly tripId: FieldRef<"TripMessage", 'String'>
    readonly userId: FieldRef<"TripMessage", 'String'>
    readonly content: FieldRef<"TripMessage", 'String'>
    readonly messageType: FieldRef<"TripMessage", 'MessageType'>
    readonly editedAt: FieldRef<"TripMessage", 'DateTime'>
    readonly parentId: FieldRef<"TripMessage", 'String'>
    readonly createdAt: FieldRef<"TripMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TripMessage findUnique
   */
  export type TripMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMessage
     */
    select?: TripMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMessageInclude<ExtArgs> | null
    /**
     * Filter, which TripMessage to fetch.
     */
    where: TripMessageWhereUniqueInput
  }

  /**
   * TripMessage findUniqueOrThrow
   */
  export type TripMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMessage
     */
    select?: TripMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMessageInclude<ExtArgs> | null
    /**
     * Filter, which TripMessage to fetch.
     */
    where: TripMessageWhereUniqueInput
  }

  /**
   * TripMessage findFirst
   */
  export type TripMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMessage
     */
    select?: TripMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMessageInclude<ExtArgs> | null
    /**
     * Filter, which TripMessage to fetch.
     */
    where?: TripMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripMessages to fetch.
     */
    orderBy?: TripMessageOrderByWithRelationInput | TripMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TripMessages.
     */
    cursor?: TripMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TripMessages.
     */
    distinct?: TripMessageScalarFieldEnum | TripMessageScalarFieldEnum[]
  }

  /**
   * TripMessage findFirstOrThrow
   */
  export type TripMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMessage
     */
    select?: TripMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMessageInclude<ExtArgs> | null
    /**
     * Filter, which TripMessage to fetch.
     */
    where?: TripMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripMessages to fetch.
     */
    orderBy?: TripMessageOrderByWithRelationInput | TripMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TripMessages.
     */
    cursor?: TripMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TripMessages.
     */
    distinct?: TripMessageScalarFieldEnum | TripMessageScalarFieldEnum[]
  }

  /**
   * TripMessage findMany
   */
  export type TripMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMessage
     */
    select?: TripMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMessageInclude<ExtArgs> | null
    /**
     * Filter, which TripMessages to fetch.
     */
    where?: TripMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripMessages to fetch.
     */
    orderBy?: TripMessageOrderByWithRelationInput | TripMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TripMessages.
     */
    cursor?: TripMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripMessages.
     */
    skip?: number
    distinct?: TripMessageScalarFieldEnum | TripMessageScalarFieldEnum[]
  }

  /**
   * TripMessage create
   */
  export type TripMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMessage
     */
    select?: TripMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a TripMessage.
     */
    data: XOR<TripMessageCreateInput, TripMessageUncheckedCreateInput>
  }

  /**
   * TripMessage createMany
   */
  export type TripMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TripMessages.
     */
    data: TripMessageCreateManyInput | TripMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TripMessage createManyAndReturn
   */
  export type TripMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMessage
     */
    select?: TripMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TripMessages.
     */
    data: TripMessageCreateManyInput | TripMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TripMessage update
   */
  export type TripMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMessage
     */
    select?: TripMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a TripMessage.
     */
    data: XOR<TripMessageUpdateInput, TripMessageUncheckedUpdateInput>
    /**
     * Choose, which TripMessage to update.
     */
    where: TripMessageWhereUniqueInput
  }

  /**
   * TripMessage updateMany
   */
  export type TripMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TripMessages.
     */
    data: XOR<TripMessageUpdateManyMutationInput, TripMessageUncheckedUpdateManyInput>
    /**
     * Filter which TripMessages to update
     */
    where?: TripMessageWhereInput
  }

  /**
   * TripMessage upsert
   */
  export type TripMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMessage
     */
    select?: TripMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the TripMessage to update in case it exists.
     */
    where: TripMessageWhereUniqueInput
    /**
     * In case the TripMessage found by the `where` argument doesn't exist, create a new TripMessage with this data.
     */
    create: XOR<TripMessageCreateInput, TripMessageUncheckedCreateInput>
    /**
     * In case the TripMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TripMessageUpdateInput, TripMessageUncheckedUpdateInput>
  }

  /**
   * TripMessage delete
   */
  export type TripMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMessage
     */
    select?: TripMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMessageInclude<ExtArgs> | null
    /**
     * Filter which TripMessage to delete.
     */
    where: TripMessageWhereUniqueInput
  }

  /**
   * TripMessage deleteMany
   */
  export type TripMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TripMessages to delete
     */
    where?: TripMessageWhereInput
  }

  /**
   * TripMessage.parent
   */
  export type TripMessage$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMessage
     */
    select?: TripMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMessageInclude<ExtArgs> | null
    where?: TripMessageWhereInput
  }

  /**
   * TripMessage.edits
   */
  export type TripMessage$editsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMessage
     */
    select?: TripMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMessageInclude<ExtArgs> | null
    where?: TripMessageWhereInput
    orderBy?: TripMessageOrderByWithRelationInput | TripMessageOrderByWithRelationInput[]
    cursor?: TripMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripMessageScalarFieldEnum | TripMessageScalarFieldEnum[]
  }

  /**
   * TripMessage.reactions
   */
  export type TripMessage$reactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReactionInclude<ExtArgs> | null
    where?: MessageReactionWhereInput
    orderBy?: MessageReactionOrderByWithRelationInput | MessageReactionOrderByWithRelationInput[]
    cursor?: MessageReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageReactionScalarFieldEnum | MessageReactionScalarFieldEnum[]
  }

  /**
   * TripMessage.readReceipts
   */
  export type TripMessage$readReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReadReceipt
     */
    select?: MessageReadReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadReceiptInclude<ExtArgs> | null
    where?: MessageReadReceiptWhereInput
    orderBy?: MessageReadReceiptOrderByWithRelationInput | MessageReadReceiptOrderByWithRelationInput[]
    cursor?: MessageReadReceiptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageReadReceiptScalarFieldEnum | MessageReadReceiptScalarFieldEnum[]
  }

  /**
   * TripMessage without action
   */
  export type TripMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMessage
     */
    select?: TripMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMessageInclude<ExtArgs> | null
  }


  /**
   * Model MessageReaction
   */

  export type AggregateMessageReaction = {
    _count: MessageReactionCountAggregateOutputType | null
    _min: MessageReactionMinAggregateOutputType | null
    _max: MessageReactionMaxAggregateOutputType | null
  }

  export type MessageReactionMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    emoji: string | null
  }

  export type MessageReactionMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    emoji: string | null
  }

  export type MessageReactionCountAggregateOutputType = {
    id: number
    messageId: number
    userId: number
    emoji: number
    _all: number
  }


  export type MessageReactionMinAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    emoji?: true
  }

  export type MessageReactionMaxAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    emoji?: true
  }

  export type MessageReactionCountAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    emoji?: true
    _all?: true
  }

  export type MessageReactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageReaction to aggregate.
     */
    where?: MessageReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReactions to fetch.
     */
    orderBy?: MessageReactionOrderByWithRelationInput | MessageReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageReactions
    **/
    _count?: true | MessageReactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageReactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageReactionMaxAggregateInputType
  }

  export type GetMessageReactionAggregateType<T extends MessageReactionAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageReaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageReaction[P]>
      : GetScalarType<T[P], AggregateMessageReaction[P]>
  }




  export type MessageReactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageReactionWhereInput
    orderBy?: MessageReactionOrderByWithAggregationInput | MessageReactionOrderByWithAggregationInput[]
    by: MessageReactionScalarFieldEnum[] | MessageReactionScalarFieldEnum
    having?: MessageReactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageReactionCountAggregateInputType | true
    _min?: MessageReactionMinAggregateInputType
    _max?: MessageReactionMaxAggregateInputType
  }

  export type MessageReactionGroupByOutputType = {
    id: string
    messageId: string
    userId: string
    emoji: string
    _count: MessageReactionCountAggregateOutputType | null
    _min: MessageReactionMinAggregateOutputType | null
    _max: MessageReactionMaxAggregateOutputType | null
  }

  type GetMessageReactionGroupByPayload<T extends MessageReactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageReactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageReactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageReactionGroupByOutputType[P]>
            : GetScalarType<T[P], MessageReactionGroupByOutputType[P]>
        }
      >
    >


  export type MessageReactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    emoji?: boolean
    message?: boolean | TripMessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageReaction"]>

  export type MessageReactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    emoji?: boolean
    message?: boolean | TripMessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageReaction"]>

  export type MessageReactionSelectScalar = {
    id?: boolean
    messageId?: boolean
    userId?: boolean
    emoji?: boolean
  }

  export type MessageReactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | TripMessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageReactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | TripMessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessageReactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageReaction"
    objects: {
      message: Prisma.$TripMessagePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      userId: string
      emoji: string
    }, ExtArgs["result"]["messageReaction"]>
    composites: {}
  }

  type MessageReactionGetPayload<S extends boolean | null | undefined | MessageReactionDefaultArgs> = $Result.GetResult<Prisma.$MessageReactionPayload, S>

  type MessageReactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageReactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageReactionCountAggregateInputType | true
    }

  export interface MessageReactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageReaction'], meta: { name: 'MessageReaction' } }
    /**
     * Find zero or one MessageReaction that matches the filter.
     * @param {MessageReactionFindUniqueArgs} args - Arguments to find a MessageReaction
     * @example
     * // Get one MessageReaction
     * const messageReaction = await prisma.messageReaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageReactionFindUniqueArgs>(args: SelectSubset<T, MessageReactionFindUniqueArgs<ExtArgs>>): Prisma__MessageReactionClient<$Result.GetResult<Prisma.$MessageReactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MessageReaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageReactionFindUniqueOrThrowArgs} args - Arguments to find a MessageReaction
     * @example
     * // Get one MessageReaction
     * const messageReaction = await prisma.messageReaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageReactionFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageReactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageReactionClient<$Result.GetResult<Prisma.$MessageReactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MessageReaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReactionFindFirstArgs} args - Arguments to find a MessageReaction
     * @example
     * // Get one MessageReaction
     * const messageReaction = await prisma.messageReaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageReactionFindFirstArgs>(args?: SelectSubset<T, MessageReactionFindFirstArgs<ExtArgs>>): Prisma__MessageReactionClient<$Result.GetResult<Prisma.$MessageReactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MessageReaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReactionFindFirstOrThrowArgs} args - Arguments to find a MessageReaction
     * @example
     * // Get one MessageReaction
     * const messageReaction = await prisma.messageReaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageReactionFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageReactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageReactionClient<$Result.GetResult<Prisma.$MessageReactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MessageReactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageReactions
     * const messageReactions = await prisma.messageReaction.findMany()
     * 
     * // Get first 10 MessageReactions
     * const messageReactions = await prisma.messageReaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageReactionWithIdOnly = await prisma.messageReaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageReactionFindManyArgs>(args?: SelectSubset<T, MessageReactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MessageReaction.
     * @param {MessageReactionCreateArgs} args - Arguments to create a MessageReaction.
     * @example
     * // Create one MessageReaction
     * const MessageReaction = await prisma.messageReaction.create({
     *   data: {
     *     // ... data to create a MessageReaction
     *   }
     * })
     * 
     */
    create<T extends MessageReactionCreateArgs>(args: SelectSubset<T, MessageReactionCreateArgs<ExtArgs>>): Prisma__MessageReactionClient<$Result.GetResult<Prisma.$MessageReactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MessageReactions.
     * @param {MessageReactionCreateManyArgs} args - Arguments to create many MessageReactions.
     * @example
     * // Create many MessageReactions
     * const messageReaction = await prisma.messageReaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageReactionCreateManyArgs>(args?: SelectSubset<T, MessageReactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageReactions and returns the data saved in the database.
     * @param {MessageReactionCreateManyAndReturnArgs} args - Arguments to create many MessageReactions.
     * @example
     * // Create many MessageReactions
     * const messageReaction = await prisma.messageReaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageReactions and only return the `id`
     * const messageReactionWithIdOnly = await prisma.messageReaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageReactionCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageReactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MessageReaction.
     * @param {MessageReactionDeleteArgs} args - Arguments to delete one MessageReaction.
     * @example
     * // Delete one MessageReaction
     * const MessageReaction = await prisma.messageReaction.delete({
     *   where: {
     *     // ... filter to delete one MessageReaction
     *   }
     * })
     * 
     */
    delete<T extends MessageReactionDeleteArgs>(args: SelectSubset<T, MessageReactionDeleteArgs<ExtArgs>>): Prisma__MessageReactionClient<$Result.GetResult<Prisma.$MessageReactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MessageReaction.
     * @param {MessageReactionUpdateArgs} args - Arguments to update one MessageReaction.
     * @example
     * // Update one MessageReaction
     * const messageReaction = await prisma.messageReaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageReactionUpdateArgs>(args: SelectSubset<T, MessageReactionUpdateArgs<ExtArgs>>): Prisma__MessageReactionClient<$Result.GetResult<Prisma.$MessageReactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MessageReactions.
     * @param {MessageReactionDeleteManyArgs} args - Arguments to filter MessageReactions to delete.
     * @example
     * // Delete a few MessageReactions
     * const { count } = await prisma.messageReaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageReactionDeleteManyArgs>(args?: SelectSubset<T, MessageReactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageReactions
     * const messageReaction = await prisma.messageReaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageReactionUpdateManyArgs>(args: SelectSubset<T, MessageReactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageReaction.
     * @param {MessageReactionUpsertArgs} args - Arguments to update or create a MessageReaction.
     * @example
     * // Update or create a MessageReaction
     * const messageReaction = await prisma.messageReaction.upsert({
     *   create: {
     *     // ... data to create a MessageReaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageReaction we want to update
     *   }
     * })
     */
    upsert<T extends MessageReactionUpsertArgs>(args: SelectSubset<T, MessageReactionUpsertArgs<ExtArgs>>): Prisma__MessageReactionClient<$Result.GetResult<Prisma.$MessageReactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MessageReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReactionCountArgs} args - Arguments to filter MessageReactions to count.
     * @example
     * // Count the number of MessageReactions
     * const count = await prisma.messageReaction.count({
     *   where: {
     *     // ... the filter for the MessageReactions we want to count
     *   }
     * })
    **/
    count<T extends MessageReactionCountArgs>(
      args?: Subset<T, MessageReactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageReactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageReactionAggregateArgs>(args: Subset<T, MessageReactionAggregateArgs>): Prisma.PrismaPromise<GetMessageReactionAggregateType<T>>

    /**
     * Group by MessageReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageReactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageReactionGroupByArgs['orderBy'] }
        : { orderBy?: MessageReactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageReactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageReactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageReaction model
   */
  readonly fields: MessageReactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageReaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageReactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends TripMessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TripMessageDefaultArgs<ExtArgs>>): Prisma__TripMessageClient<$Result.GetResult<Prisma.$TripMessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageReaction model
   */ 
  interface MessageReactionFieldRefs {
    readonly id: FieldRef<"MessageReaction", 'String'>
    readonly messageId: FieldRef<"MessageReaction", 'String'>
    readonly userId: FieldRef<"MessageReaction", 'String'>
    readonly emoji: FieldRef<"MessageReaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MessageReaction findUnique
   */
  export type MessageReactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReactionInclude<ExtArgs> | null
    /**
     * Filter, which MessageReaction to fetch.
     */
    where: MessageReactionWhereUniqueInput
  }

  /**
   * MessageReaction findUniqueOrThrow
   */
  export type MessageReactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReactionInclude<ExtArgs> | null
    /**
     * Filter, which MessageReaction to fetch.
     */
    where: MessageReactionWhereUniqueInput
  }

  /**
   * MessageReaction findFirst
   */
  export type MessageReactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReactionInclude<ExtArgs> | null
    /**
     * Filter, which MessageReaction to fetch.
     */
    where?: MessageReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReactions to fetch.
     */
    orderBy?: MessageReactionOrderByWithRelationInput | MessageReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageReactions.
     */
    cursor?: MessageReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageReactions.
     */
    distinct?: MessageReactionScalarFieldEnum | MessageReactionScalarFieldEnum[]
  }

  /**
   * MessageReaction findFirstOrThrow
   */
  export type MessageReactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReactionInclude<ExtArgs> | null
    /**
     * Filter, which MessageReaction to fetch.
     */
    where?: MessageReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReactions to fetch.
     */
    orderBy?: MessageReactionOrderByWithRelationInput | MessageReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageReactions.
     */
    cursor?: MessageReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageReactions.
     */
    distinct?: MessageReactionScalarFieldEnum | MessageReactionScalarFieldEnum[]
  }

  /**
   * MessageReaction findMany
   */
  export type MessageReactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReactionInclude<ExtArgs> | null
    /**
     * Filter, which MessageReactions to fetch.
     */
    where?: MessageReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReactions to fetch.
     */
    orderBy?: MessageReactionOrderByWithRelationInput | MessageReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageReactions.
     */
    cursor?: MessageReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReactions.
     */
    skip?: number
    distinct?: MessageReactionScalarFieldEnum | MessageReactionScalarFieldEnum[]
  }

  /**
   * MessageReaction create
   */
  export type MessageReactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReactionInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageReaction.
     */
    data: XOR<MessageReactionCreateInput, MessageReactionUncheckedCreateInput>
  }

  /**
   * MessageReaction createMany
   */
  export type MessageReactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageReactions.
     */
    data: MessageReactionCreateManyInput | MessageReactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageReaction createManyAndReturn
   */
  export type MessageReactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MessageReactions.
     */
    data: MessageReactionCreateManyInput | MessageReactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageReaction update
   */
  export type MessageReactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReactionInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageReaction.
     */
    data: XOR<MessageReactionUpdateInput, MessageReactionUncheckedUpdateInput>
    /**
     * Choose, which MessageReaction to update.
     */
    where: MessageReactionWhereUniqueInput
  }

  /**
   * MessageReaction updateMany
   */
  export type MessageReactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageReactions.
     */
    data: XOR<MessageReactionUpdateManyMutationInput, MessageReactionUncheckedUpdateManyInput>
    /**
     * Filter which MessageReactions to update
     */
    where?: MessageReactionWhereInput
  }

  /**
   * MessageReaction upsert
   */
  export type MessageReactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReactionInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageReaction to update in case it exists.
     */
    where: MessageReactionWhereUniqueInput
    /**
     * In case the MessageReaction found by the `where` argument doesn't exist, create a new MessageReaction with this data.
     */
    create: XOR<MessageReactionCreateInput, MessageReactionUncheckedCreateInput>
    /**
     * In case the MessageReaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageReactionUpdateInput, MessageReactionUncheckedUpdateInput>
  }

  /**
   * MessageReaction delete
   */
  export type MessageReactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReactionInclude<ExtArgs> | null
    /**
     * Filter which MessageReaction to delete.
     */
    where: MessageReactionWhereUniqueInput
  }

  /**
   * MessageReaction deleteMany
   */
  export type MessageReactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageReactions to delete
     */
    where?: MessageReactionWhereInput
  }

  /**
   * MessageReaction without action
   */
  export type MessageReactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReactionInclude<ExtArgs> | null
  }


  /**
   * Model MessageReadReceipt
   */

  export type AggregateMessageReadReceipt = {
    _count: MessageReadReceiptCountAggregateOutputType | null
    _min: MessageReadReceiptMinAggregateOutputType | null
    _max: MessageReadReceiptMaxAggregateOutputType | null
  }

  export type MessageReadReceiptMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    readAt: Date | null
  }

  export type MessageReadReceiptMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    readAt: Date | null
  }

  export type MessageReadReceiptCountAggregateOutputType = {
    id: number
    messageId: number
    userId: number
    readAt: number
    _all: number
  }


  export type MessageReadReceiptMinAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    readAt?: true
  }

  export type MessageReadReceiptMaxAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    readAt?: true
  }

  export type MessageReadReceiptCountAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    readAt?: true
    _all?: true
  }

  export type MessageReadReceiptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageReadReceipt to aggregate.
     */
    where?: MessageReadReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReadReceipts to fetch.
     */
    orderBy?: MessageReadReceiptOrderByWithRelationInput | MessageReadReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageReadReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReadReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReadReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageReadReceipts
    **/
    _count?: true | MessageReadReceiptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageReadReceiptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageReadReceiptMaxAggregateInputType
  }

  export type GetMessageReadReceiptAggregateType<T extends MessageReadReceiptAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageReadReceipt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageReadReceipt[P]>
      : GetScalarType<T[P], AggregateMessageReadReceipt[P]>
  }




  export type MessageReadReceiptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageReadReceiptWhereInput
    orderBy?: MessageReadReceiptOrderByWithAggregationInput | MessageReadReceiptOrderByWithAggregationInput[]
    by: MessageReadReceiptScalarFieldEnum[] | MessageReadReceiptScalarFieldEnum
    having?: MessageReadReceiptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageReadReceiptCountAggregateInputType | true
    _min?: MessageReadReceiptMinAggregateInputType
    _max?: MessageReadReceiptMaxAggregateInputType
  }

  export type MessageReadReceiptGroupByOutputType = {
    id: string
    messageId: string
    userId: string
    readAt: Date
    _count: MessageReadReceiptCountAggregateOutputType | null
    _min: MessageReadReceiptMinAggregateOutputType | null
    _max: MessageReadReceiptMaxAggregateOutputType | null
  }

  type GetMessageReadReceiptGroupByPayload<T extends MessageReadReceiptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageReadReceiptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageReadReceiptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageReadReceiptGroupByOutputType[P]>
            : GetScalarType<T[P], MessageReadReceiptGroupByOutputType[P]>
        }
      >
    >


  export type MessageReadReceiptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    readAt?: boolean
    message?: boolean | TripMessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageReadReceipt"]>

  export type MessageReadReceiptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    readAt?: boolean
    message?: boolean | TripMessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageReadReceipt"]>

  export type MessageReadReceiptSelectScalar = {
    id?: boolean
    messageId?: boolean
    userId?: boolean
    readAt?: boolean
  }

  export type MessageReadReceiptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | TripMessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageReadReceiptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | TripMessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessageReadReceiptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageReadReceipt"
    objects: {
      message: Prisma.$TripMessagePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      userId: string
      readAt: Date
    }, ExtArgs["result"]["messageReadReceipt"]>
    composites: {}
  }

  type MessageReadReceiptGetPayload<S extends boolean | null | undefined | MessageReadReceiptDefaultArgs> = $Result.GetResult<Prisma.$MessageReadReceiptPayload, S>

  type MessageReadReceiptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageReadReceiptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageReadReceiptCountAggregateInputType | true
    }

  export interface MessageReadReceiptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageReadReceipt'], meta: { name: 'MessageReadReceipt' } }
    /**
     * Find zero or one MessageReadReceipt that matches the filter.
     * @param {MessageReadReceiptFindUniqueArgs} args - Arguments to find a MessageReadReceipt
     * @example
     * // Get one MessageReadReceipt
     * const messageReadReceipt = await prisma.messageReadReceipt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageReadReceiptFindUniqueArgs>(args: SelectSubset<T, MessageReadReceiptFindUniqueArgs<ExtArgs>>): Prisma__MessageReadReceiptClient<$Result.GetResult<Prisma.$MessageReadReceiptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MessageReadReceipt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageReadReceiptFindUniqueOrThrowArgs} args - Arguments to find a MessageReadReceipt
     * @example
     * // Get one MessageReadReceipt
     * const messageReadReceipt = await prisma.messageReadReceipt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageReadReceiptFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageReadReceiptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageReadReceiptClient<$Result.GetResult<Prisma.$MessageReadReceiptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MessageReadReceipt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadReceiptFindFirstArgs} args - Arguments to find a MessageReadReceipt
     * @example
     * // Get one MessageReadReceipt
     * const messageReadReceipt = await prisma.messageReadReceipt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageReadReceiptFindFirstArgs>(args?: SelectSubset<T, MessageReadReceiptFindFirstArgs<ExtArgs>>): Prisma__MessageReadReceiptClient<$Result.GetResult<Prisma.$MessageReadReceiptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MessageReadReceipt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadReceiptFindFirstOrThrowArgs} args - Arguments to find a MessageReadReceipt
     * @example
     * // Get one MessageReadReceipt
     * const messageReadReceipt = await prisma.messageReadReceipt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageReadReceiptFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageReadReceiptFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageReadReceiptClient<$Result.GetResult<Prisma.$MessageReadReceiptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MessageReadReceipts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadReceiptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageReadReceipts
     * const messageReadReceipts = await prisma.messageReadReceipt.findMany()
     * 
     * // Get first 10 MessageReadReceipts
     * const messageReadReceipts = await prisma.messageReadReceipt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageReadReceiptWithIdOnly = await prisma.messageReadReceipt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageReadReceiptFindManyArgs>(args?: SelectSubset<T, MessageReadReceiptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReadReceiptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MessageReadReceipt.
     * @param {MessageReadReceiptCreateArgs} args - Arguments to create a MessageReadReceipt.
     * @example
     * // Create one MessageReadReceipt
     * const MessageReadReceipt = await prisma.messageReadReceipt.create({
     *   data: {
     *     // ... data to create a MessageReadReceipt
     *   }
     * })
     * 
     */
    create<T extends MessageReadReceiptCreateArgs>(args: SelectSubset<T, MessageReadReceiptCreateArgs<ExtArgs>>): Prisma__MessageReadReceiptClient<$Result.GetResult<Prisma.$MessageReadReceiptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MessageReadReceipts.
     * @param {MessageReadReceiptCreateManyArgs} args - Arguments to create many MessageReadReceipts.
     * @example
     * // Create many MessageReadReceipts
     * const messageReadReceipt = await prisma.messageReadReceipt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageReadReceiptCreateManyArgs>(args?: SelectSubset<T, MessageReadReceiptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageReadReceipts and returns the data saved in the database.
     * @param {MessageReadReceiptCreateManyAndReturnArgs} args - Arguments to create many MessageReadReceipts.
     * @example
     * // Create many MessageReadReceipts
     * const messageReadReceipt = await prisma.messageReadReceipt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageReadReceipts and only return the `id`
     * const messageReadReceiptWithIdOnly = await prisma.messageReadReceipt.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageReadReceiptCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageReadReceiptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReadReceiptPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MessageReadReceipt.
     * @param {MessageReadReceiptDeleteArgs} args - Arguments to delete one MessageReadReceipt.
     * @example
     * // Delete one MessageReadReceipt
     * const MessageReadReceipt = await prisma.messageReadReceipt.delete({
     *   where: {
     *     // ... filter to delete one MessageReadReceipt
     *   }
     * })
     * 
     */
    delete<T extends MessageReadReceiptDeleteArgs>(args: SelectSubset<T, MessageReadReceiptDeleteArgs<ExtArgs>>): Prisma__MessageReadReceiptClient<$Result.GetResult<Prisma.$MessageReadReceiptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MessageReadReceipt.
     * @param {MessageReadReceiptUpdateArgs} args - Arguments to update one MessageReadReceipt.
     * @example
     * // Update one MessageReadReceipt
     * const messageReadReceipt = await prisma.messageReadReceipt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageReadReceiptUpdateArgs>(args: SelectSubset<T, MessageReadReceiptUpdateArgs<ExtArgs>>): Prisma__MessageReadReceiptClient<$Result.GetResult<Prisma.$MessageReadReceiptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MessageReadReceipts.
     * @param {MessageReadReceiptDeleteManyArgs} args - Arguments to filter MessageReadReceipts to delete.
     * @example
     * // Delete a few MessageReadReceipts
     * const { count } = await prisma.messageReadReceipt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageReadReceiptDeleteManyArgs>(args?: SelectSubset<T, MessageReadReceiptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageReadReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadReceiptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageReadReceipts
     * const messageReadReceipt = await prisma.messageReadReceipt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageReadReceiptUpdateManyArgs>(args: SelectSubset<T, MessageReadReceiptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageReadReceipt.
     * @param {MessageReadReceiptUpsertArgs} args - Arguments to update or create a MessageReadReceipt.
     * @example
     * // Update or create a MessageReadReceipt
     * const messageReadReceipt = await prisma.messageReadReceipt.upsert({
     *   create: {
     *     // ... data to create a MessageReadReceipt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageReadReceipt we want to update
     *   }
     * })
     */
    upsert<T extends MessageReadReceiptUpsertArgs>(args: SelectSubset<T, MessageReadReceiptUpsertArgs<ExtArgs>>): Prisma__MessageReadReceiptClient<$Result.GetResult<Prisma.$MessageReadReceiptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MessageReadReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadReceiptCountArgs} args - Arguments to filter MessageReadReceipts to count.
     * @example
     * // Count the number of MessageReadReceipts
     * const count = await prisma.messageReadReceipt.count({
     *   where: {
     *     // ... the filter for the MessageReadReceipts we want to count
     *   }
     * })
    **/
    count<T extends MessageReadReceiptCountArgs>(
      args?: Subset<T, MessageReadReceiptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageReadReceiptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageReadReceipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadReceiptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageReadReceiptAggregateArgs>(args: Subset<T, MessageReadReceiptAggregateArgs>): Prisma.PrismaPromise<GetMessageReadReceiptAggregateType<T>>

    /**
     * Group by MessageReadReceipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadReceiptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageReadReceiptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageReadReceiptGroupByArgs['orderBy'] }
        : { orderBy?: MessageReadReceiptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageReadReceiptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageReadReceiptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageReadReceipt model
   */
  readonly fields: MessageReadReceiptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageReadReceipt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageReadReceiptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends TripMessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TripMessageDefaultArgs<ExtArgs>>): Prisma__TripMessageClient<$Result.GetResult<Prisma.$TripMessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageReadReceipt model
   */ 
  interface MessageReadReceiptFieldRefs {
    readonly id: FieldRef<"MessageReadReceipt", 'String'>
    readonly messageId: FieldRef<"MessageReadReceipt", 'String'>
    readonly userId: FieldRef<"MessageReadReceipt", 'String'>
    readonly readAt: FieldRef<"MessageReadReceipt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageReadReceipt findUnique
   */
  export type MessageReadReceiptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReadReceipt
     */
    select?: MessageReadReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadReceiptInclude<ExtArgs> | null
    /**
     * Filter, which MessageReadReceipt to fetch.
     */
    where: MessageReadReceiptWhereUniqueInput
  }

  /**
   * MessageReadReceipt findUniqueOrThrow
   */
  export type MessageReadReceiptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReadReceipt
     */
    select?: MessageReadReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadReceiptInclude<ExtArgs> | null
    /**
     * Filter, which MessageReadReceipt to fetch.
     */
    where: MessageReadReceiptWhereUniqueInput
  }

  /**
   * MessageReadReceipt findFirst
   */
  export type MessageReadReceiptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReadReceipt
     */
    select?: MessageReadReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadReceiptInclude<ExtArgs> | null
    /**
     * Filter, which MessageReadReceipt to fetch.
     */
    where?: MessageReadReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReadReceipts to fetch.
     */
    orderBy?: MessageReadReceiptOrderByWithRelationInput | MessageReadReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageReadReceipts.
     */
    cursor?: MessageReadReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReadReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReadReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageReadReceipts.
     */
    distinct?: MessageReadReceiptScalarFieldEnum | MessageReadReceiptScalarFieldEnum[]
  }

  /**
   * MessageReadReceipt findFirstOrThrow
   */
  export type MessageReadReceiptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReadReceipt
     */
    select?: MessageReadReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadReceiptInclude<ExtArgs> | null
    /**
     * Filter, which MessageReadReceipt to fetch.
     */
    where?: MessageReadReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReadReceipts to fetch.
     */
    orderBy?: MessageReadReceiptOrderByWithRelationInput | MessageReadReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageReadReceipts.
     */
    cursor?: MessageReadReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReadReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReadReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageReadReceipts.
     */
    distinct?: MessageReadReceiptScalarFieldEnum | MessageReadReceiptScalarFieldEnum[]
  }

  /**
   * MessageReadReceipt findMany
   */
  export type MessageReadReceiptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReadReceipt
     */
    select?: MessageReadReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadReceiptInclude<ExtArgs> | null
    /**
     * Filter, which MessageReadReceipts to fetch.
     */
    where?: MessageReadReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReadReceipts to fetch.
     */
    orderBy?: MessageReadReceiptOrderByWithRelationInput | MessageReadReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageReadReceipts.
     */
    cursor?: MessageReadReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReadReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReadReceipts.
     */
    skip?: number
    distinct?: MessageReadReceiptScalarFieldEnum | MessageReadReceiptScalarFieldEnum[]
  }

  /**
   * MessageReadReceipt create
   */
  export type MessageReadReceiptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReadReceipt
     */
    select?: MessageReadReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadReceiptInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageReadReceipt.
     */
    data: XOR<MessageReadReceiptCreateInput, MessageReadReceiptUncheckedCreateInput>
  }

  /**
   * MessageReadReceipt createMany
   */
  export type MessageReadReceiptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageReadReceipts.
     */
    data: MessageReadReceiptCreateManyInput | MessageReadReceiptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageReadReceipt createManyAndReturn
   */
  export type MessageReadReceiptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReadReceipt
     */
    select?: MessageReadReceiptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MessageReadReceipts.
     */
    data: MessageReadReceiptCreateManyInput | MessageReadReceiptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadReceiptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageReadReceipt update
   */
  export type MessageReadReceiptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReadReceipt
     */
    select?: MessageReadReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadReceiptInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageReadReceipt.
     */
    data: XOR<MessageReadReceiptUpdateInput, MessageReadReceiptUncheckedUpdateInput>
    /**
     * Choose, which MessageReadReceipt to update.
     */
    where: MessageReadReceiptWhereUniqueInput
  }

  /**
   * MessageReadReceipt updateMany
   */
  export type MessageReadReceiptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageReadReceipts.
     */
    data: XOR<MessageReadReceiptUpdateManyMutationInput, MessageReadReceiptUncheckedUpdateManyInput>
    /**
     * Filter which MessageReadReceipts to update
     */
    where?: MessageReadReceiptWhereInput
  }

  /**
   * MessageReadReceipt upsert
   */
  export type MessageReadReceiptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReadReceipt
     */
    select?: MessageReadReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadReceiptInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageReadReceipt to update in case it exists.
     */
    where: MessageReadReceiptWhereUniqueInput
    /**
     * In case the MessageReadReceipt found by the `where` argument doesn't exist, create a new MessageReadReceipt with this data.
     */
    create: XOR<MessageReadReceiptCreateInput, MessageReadReceiptUncheckedCreateInput>
    /**
     * In case the MessageReadReceipt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageReadReceiptUpdateInput, MessageReadReceiptUncheckedUpdateInput>
  }

  /**
   * MessageReadReceipt delete
   */
  export type MessageReadReceiptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReadReceipt
     */
    select?: MessageReadReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadReceiptInclude<ExtArgs> | null
    /**
     * Filter which MessageReadReceipt to delete.
     */
    where: MessageReadReceiptWhereUniqueInput
  }

  /**
   * MessageReadReceipt deleteMany
   */
  export type MessageReadReceiptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageReadReceipts to delete
     */
    where?: MessageReadReceiptWhereInput
  }

  /**
   * MessageReadReceipt without action
   */
  export type MessageReadReceiptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReadReceipt
     */
    select?: MessageReadReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadReceiptInclude<ExtArgs> | null
  }


  /**
   * Model MediaItem
   */

  export type AggregateMediaItem = {
    _count: MediaItemCountAggregateOutputType | null
    _min: MediaItemMinAggregateOutputType | null
    _max: MediaItemMaxAggregateOutputType | null
  }

  export type MediaItemMinAggregateOutputType = {
    id: string | null
    tripId: string | null
    uploaderId: string | null
    type: string | null
    url: string | null
    thumbnailUrl: string | null
    activityId: string | null
    caption: string | null
    createdAt: Date | null
  }

  export type MediaItemMaxAggregateOutputType = {
    id: string | null
    tripId: string | null
    uploaderId: string | null
    type: string | null
    url: string | null
    thumbnailUrl: string | null
    activityId: string | null
    caption: string | null
    createdAt: Date | null
  }

  export type MediaItemCountAggregateOutputType = {
    id: number
    tripId: number
    uploaderId: number
    type: number
    url: number
    thumbnailUrl: number
    activityId: number
    caption: number
    createdAt: number
    _all: number
  }


  export type MediaItemMinAggregateInputType = {
    id?: true
    tripId?: true
    uploaderId?: true
    type?: true
    url?: true
    thumbnailUrl?: true
    activityId?: true
    caption?: true
    createdAt?: true
  }

  export type MediaItemMaxAggregateInputType = {
    id?: true
    tripId?: true
    uploaderId?: true
    type?: true
    url?: true
    thumbnailUrl?: true
    activityId?: true
    caption?: true
    createdAt?: true
  }

  export type MediaItemCountAggregateInputType = {
    id?: true
    tripId?: true
    uploaderId?: true
    type?: true
    url?: true
    thumbnailUrl?: true
    activityId?: true
    caption?: true
    createdAt?: true
    _all?: true
  }

  export type MediaItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaItem to aggregate.
     */
    where?: MediaItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaItems to fetch.
     */
    orderBy?: MediaItemOrderByWithRelationInput | MediaItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MediaItems
    **/
    _count?: true | MediaItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaItemMaxAggregateInputType
  }

  export type GetMediaItemAggregateType<T extends MediaItemAggregateArgs> = {
        [P in keyof T & keyof AggregateMediaItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMediaItem[P]>
      : GetScalarType<T[P], AggregateMediaItem[P]>
  }




  export type MediaItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaItemWhereInput
    orderBy?: MediaItemOrderByWithAggregationInput | MediaItemOrderByWithAggregationInput[]
    by: MediaItemScalarFieldEnum[] | MediaItemScalarFieldEnum
    having?: MediaItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaItemCountAggregateInputType | true
    _min?: MediaItemMinAggregateInputType
    _max?: MediaItemMaxAggregateInputType
  }

  export type MediaItemGroupByOutputType = {
    id: string
    tripId: string
    uploaderId: string
    type: string
    url: string
    thumbnailUrl: string | null
    activityId: string | null
    caption: string | null
    createdAt: Date
    _count: MediaItemCountAggregateOutputType | null
    _min: MediaItemMinAggregateOutputType | null
    _max: MediaItemMaxAggregateOutputType | null
  }

  type GetMediaItemGroupByPayload<T extends MediaItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaItemGroupByOutputType[P]>
            : GetScalarType<T[P], MediaItemGroupByOutputType[P]>
        }
      >
    >


  export type MediaItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    uploaderId?: boolean
    type?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    activityId?: boolean
    caption?: boolean
    createdAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    activity?: boolean | MediaItem$activityArgs<ExtArgs>
  }, ExtArgs["result"]["mediaItem"]>

  export type MediaItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    uploaderId?: boolean
    type?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    activityId?: boolean
    caption?: boolean
    createdAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    activity?: boolean | MediaItem$activityArgs<ExtArgs>
  }, ExtArgs["result"]["mediaItem"]>

  export type MediaItemSelectScalar = {
    id?: boolean
    tripId?: boolean
    uploaderId?: boolean
    type?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    activityId?: boolean
    caption?: boolean
    createdAt?: boolean
  }

  export type MediaItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    activity?: boolean | MediaItem$activityArgs<ExtArgs>
  }
  export type MediaItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    activity?: boolean | MediaItem$activityArgs<ExtArgs>
  }

  export type $MediaItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MediaItem"
    objects: {
      trip: Prisma.$TripPayload<ExtArgs>
      uploader: Prisma.$UserPayload<ExtArgs>
      activity: Prisma.$ActivityPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tripId: string
      uploaderId: string
      type: string
      url: string
      thumbnailUrl: string | null
      activityId: string | null
      caption: string | null
      createdAt: Date
    }, ExtArgs["result"]["mediaItem"]>
    composites: {}
  }

  type MediaItemGetPayload<S extends boolean | null | undefined | MediaItemDefaultArgs> = $Result.GetResult<Prisma.$MediaItemPayload, S>

  type MediaItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MediaItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MediaItemCountAggregateInputType | true
    }

  export interface MediaItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MediaItem'], meta: { name: 'MediaItem' } }
    /**
     * Find zero or one MediaItem that matches the filter.
     * @param {MediaItemFindUniqueArgs} args - Arguments to find a MediaItem
     * @example
     * // Get one MediaItem
     * const mediaItem = await prisma.mediaItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaItemFindUniqueArgs>(args: SelectSubset<T, MediaItemFindUniqueArgs<ExtArgs>>): Prisma__MediaItemClient<$Result.GetResult<Prisma.$MediaItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MediaItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MediaItemFindUniqueOrThrowArgs} args - Arguments to find a MediaItem
     * @example
     * // Get one MediaItem
     * const mediaItem = await prisma.mediaItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaItemFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaItemClient<$Result.GetResult<Prisma.$MediaItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MediaItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaItemFindFirstArgs} args - Arguments to find a MediaItem
     * @example
     * // Get one MediaItem
     * const mediaItem = await prisma.mediaItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaItemFindFirstArgs>(args?: SelectSubset<T, MediaItemFindFirstArgs<ExtArgs>>): Prisma__MediaItemClient<$Result.GetResult<Prisma.$MediaItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MediaItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaItemFindFirstOrThrowArgs} args - Arguments to find a MediaItem
     * @example
     * // Get one MediaItem
     * const mediaItem = await prisma.mediaItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaItemFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaItemClient<$Result.GetResult<Prisma.$MediaItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MediaItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MediaItems
     * const mediaItems = await prisma.mediaItem.findMany()
     * 
     * // Get first 10 MediaItems
     * const mediaItems = await prisma.mediaItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaItemWithIdOnly = await prisma.mediaItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaItemFindManyArgs>(args?: SelectSubset<T, MediaItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MediaItem.
     * @param {MediaItemCreateArgs} args - Arguments to create a MediaItem.
     * @example
     * // Create one MediaItem
     * const MediaItem = await prisma.mediaItem.create({
     *   data: {
     *     // ... data to create a MediaItem
     *   }
     * })
     * 
     */
    create<T extends MediaItemCreateArgs>(args: SelectSubset<T, MediaItemCreateArgs<ExtArgs>>): Prisma__MediaItemClient<$Result.GetResult<Prisma.$MediaItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MediaItems.
     * @param {MediaItemCreateManyArgs} args - Arguments to create many MediaItems.
     * @example
     * // Create many MediaItems
     * const mediaItem = await prisma.mediaItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaItemCreateManyArgs>(args?: SelectSubset<T, MediaItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MediaItems and returns the data saved in the database.
     * @param {MediaItemCreateManyAndReturnArgs} args - Arguments to create many MediaItems.
     * @example
     * // Create many MediaItems
     * const mediaItem = await prisma.mediaItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MediaItems and only return the `id`
     * const mediaItemWithIdOnly = await prisma.mediaItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaItemCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MediaItem.
     * @param {MediaItemDeleteArgs} args - Arguments to delete one MediaItem.
     * @example
     * // Delete one MediaItem
     * const MediaItem = await prisma.mediaItem.delete({
     *   where: {
     *     // ... filter to delete one MediaItem
     *   }
     * })
     * 
     */
    delete<T extends MediaItemDeleteArgs>(args: SelectSubset<T, MediaItemDeleteArgs<ExtArgs>>): Prisma__MediaItemClient<$Result.GetResult<Prisma.$MediaItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MediaItem.
     * @param {MediaItemUpdateArgs} args - Arguments to update one MediaItem.
     * @example
     * // Update one MediaItem
     * const mediaItem = await prisma.mediaItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaItemUpdateArgs>(args: SelectSubset<T, MediaItemUpdateArgs<ExtArgs>>): Prisma__MediaItemClient<$Result.GetResult<Prisma.$MediaItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MediaItems.
     * @param {MediaItemDeleteManyArgs} args - Arguments to filter MediaItems to delete.
     * @example
     * // Delete a few MediaItems
     * const { count } = await prisma.mediaItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaItemDeleteManyArgs>(args?: SelectSubset<T, MediaItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MediaItems
     * const mediaItem = await prisma.mediaItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaItemUpdateManyArgs>(args: SelectSubset<T, MediaItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MediaItem.
     * @param {MediaItemUpsertArgs} args - Arguments to update or create a MediaItem.
     * @example
     * // Update or create a MediaItem
     * const mediaItem = await prisma.mediaItem.upsert({
     *   create: {
     *     // ... data to create a MediaItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MediaItem we want to update
     *   }
     * })
     */
    upsert<T extends MediaItemUpsertArgs>(args: SelectSubset<T, MediaItemUpsertArgs<ExtArgs>>): Prisma__MediaItemClient<$Result.GetResult<Prisma.$MediaItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MediaItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaItemCountArgs} args - Arguments to filter MediaItems to count.
     * @example
     * // Count the number of MediaItems
     * const count = await prisma.mediaItem.count({
     *   where: {
     *     // ... the filter for the MediaItems we want to count
     *   }
     * })
    **/
    count<T extends MediaItemCountArgs>(
      args?: Subset<T, MediaItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MediaItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaItemAggregateArgs>(args: Subset<T, MediaItemAggregateArgs>): Prisma.PrismaPromise<GetMediaItemAggregateType<T>>

    /**
     * Group by MediaItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaItemGroupByArgs['orderBy'] }
        : { orderBy?: MediaItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MediaItem model
   */
  readonly fields: MediaItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MediaItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trip<T extends TripDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TripDefaultArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    uploader<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    activity<T extends MediaItem$activityArgs<ExtArgs> = {}>(args?: Subset<T, MediaItem$activityArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MediaItem model
   */ 
  interface MediaItemFieldRefs {
    readonly id: FieldRef<"MediaItem", 'String'>
    readonly tripId: FieldRef<"MediaItem", 'String'>
    readonly uploaderId: FieldRef<"MediaItem", 'String'>
    readonly type: FieldRef<"MediaItem", 'String'>
    readonly url: FieldRef<"MediaItem", 'String'>
    readonly thumbnailUrl: FieldRef<"MediaItem", 'String'>
    readonly activityId: FieldRef<"MediaItem", 'String'>
    readonly caption: FieldRef<"MediaItem", 'String'>
    readonly createdAt: FieldRef<"MediaItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MediaItem findUnique
   */
  export type MediaItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaItem
     */
    select?: MediaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaItemInclude<ExtArgs> | null
    /**
     * Filter, which MediaItem to fetch.
     */
    where: MediaItemWhereUniqueInput
  }

  /**
   * MediaItem findUniqueOrThrow
   */
  export type MediaItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaItem
     */
    select?: MediaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaItemInclude<ExtArgs> | null
    /**
     * Filter, which MediaItem to fetch.
     */
    where: MediaItemWhereUniqueInput
  }

  /**
   * MediaItem findFirst
   */
  export type MediaItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaItem
     */
    select?: MediaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaItemInclude<ExtArgs> | null
    /**
     * Filter, which MediaItem to fetch.
     */
    where?: MediaItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaItems to fetch.
     */
    orderBy?: MediaItemOrderByWithRelationInput | MediaItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaItems.
     */
    cursor?: MediaItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaItems.
     */
    distinct?: MediaItemScalarFieldEnum | MediaItemScalarFieldEnum[]
  }

  /**
   * MediaItem findFirstOrThrow
   */
  export type MediaItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaItem
     */
    select?: MediaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaItemInclude<ExtArgs> | null
    /**
     * Filter, which MediaItem to fetch.
     */
    where?: MediaItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaItems to fetch.
     */
    orderBy?: MediaItemOrderByWithRelationInput | MediaItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaItems.
     */
    cursor?: MediaItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaItems.
     */
    distinct?: MediaItemScalarFieldEnum | MediaItemScalarFieldEnum[]
  }

  /**
   * MediaItem findMany
   */
  export type MediaItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaItem
     */
    select?: MediaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaItemInclude<ExtArgs> | null
    /**
     * Filter, which MediaItems to fetch.
     */
    where?: MediaItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaItems to fetch.
     */
    orderBy?: MediaItemOrderByWithRelationInput | MediaItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MediaItems.
     */
    cursor?: MediaItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaItems.
     */
    skip?: number
    distinct?: MediaItemScalarFieldEnum | MediaItemScalarFieldEnum[]
  }

  /**
   * MediaItem create
   */
  export type MediaItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaItem
     */
    select?: MediaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaItemInclude<ExtArgs> | null
    /**
     * The data needed to create a MediaItem.
     */
    data: XOR<MediaItemCreateInput, MediaItemUncheckedCreateInput>
  }

  /**
   * MediaItem createMany
   */
  export type MediaItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MediaItems.
     */
    data: MediaItemCreateManyInput | MediaItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MediaItem createManyAndReturn
   */
  export type MediaItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaItem
     */
    select?: MediaItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MediaItems.
     */
    data: MediaItemCreateManyInput | MediaItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MediaItem update
   */
  export type MediaItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaItem
     */
    select?: MediaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaItemInclude<ExtArgs> | null
    /**
     * The data needed to update a MediaItem.
     */
    data: XOR<MediaItemUpdateInput, MediaItemUncheckedUpdateInput>
    /**
     * Choose, which MediaItem to update.
     */
    where: MediaItemWhereUniqueInput
  }

  /**
   * MediaItem updateMany
   */
  export type MediaItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MediaItems.
     */
    data: XOR<MediaItemUpdateManyMutationInput, MediaItemUncheckedUpdateManyInput>
    /**
     * Filter which MediaItems to update
     */
    where?: MediaItemWhereInput
  }

  /**
   * MediaItem upsert
   */
  export type MediaItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaItem
     */
    select?: MediaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaItemInclude<ExtArgs> | null
    /**
     * The filter to search for the MediaItem to update in case it exists.
     */
    where: MediaItemWhereUniqueInput
    /**
     * In case the MediaItem found by the `where` argument doesn't exist, create a new MediaItem with this data.
     */
    create: XOR<MediaItemCreateInput, MediaItemUncheckedCreateInput>
    /**
     * In case the MediaItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaItemUpdateInput, MediaItemUncheckedUpdateInput>
  }

  /**
   * MediaItem delete
   */
  export type MediaItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaItem
     */
    select?: MediaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaItemInclude<ExtArgs> | null
    /**
     * Filter which MediaItem to delete.
     */
    where: MediaItemWhereUniqueInput
  }

  /**
   * MediaItem deleteMany
   */
  export type MediaItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaItems to delete
     */
    where?: MediaItemWhereInput
  }

  /**
   * MediaItem.activity
   */
  export type MediaItem$activityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
  }

  /**
   * MediaItem without action
   */
  export type MediaItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaItem
     */
    select?: MediaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaItemInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tripId: string | null
    type: string | null
    title: string | null
    body: string | null
    actionUrl: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tripId: string | null
    type: string | null
    title: string | null
    body: string | null
    actionUrl: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    tripId: number
    type: number
    title: number
    body: number
    actionUrl: number
    read: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    tripId?: true
    type?: true
    title?: true
    body?: true
    actionUrl?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    tripId?: true
    type?: true
    title?: true
    body?: true
    actionUrl?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    tripId?: true
    type?: true
    title?: true
    body?: true
    actionUrl?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    tripId: string | null
    type: string
    title: string
    body: string
    actionUrl: string | null
    read: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tripId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    actionUrl?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    trip?: boolean | Notification$tripArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tripId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    actionUrl?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    trip?: boolean | Notification$tripArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    tripId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    actionUrl?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    trip?: boolean | Notification$tripArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    trip?: boolean | Notification$tripArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      trip: Prisma.$TripPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tripId: string | null
      type: string
      title: string
      body: string
      actionUrl: string | null
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    trip<T extends Notification$tripArgs<ExtArgs> = {}>(args?: Subset<T, Notification$tripArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly tripId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly body: FieldRef<"Notification", 'String'>
    readonly actionUrl: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification.trip
   */
  export type Notification$tripArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    where?: TripWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model PushSubscription
   */

  export type AggregatePushSubscription = {
    _count: PushSubscriptionCountAggregateOutputType | null
    _min: PushSubscriptionMinAggregateOutputType | null
    _max: PushSubscriptionMaxAggregateOutputType | null
  }

  export type PushSubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    endpoint: string | null
    p256dh: string | null
    auth: string | null
    createdAt: Date | null
  }

  export type PushSubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    endpoint: string | null
    p256dh: string | null
    auth: string | null
    createdAt: Date | null
  }

  export type PushSubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    endpoint: number
    p256dh: number
    auth: number
    createdAt: number
    _all: number
  }


  export type PushSubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    endpoint?: true
    p256dh?: true
    auth?: true
    createdAt?: true
  }

  export type PushSubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    endpoint?: true
    p256dh?: true
    auth?: true
    createdAt?: true
  }

  export type PushSubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    endpoint?: true
    p256dh?: true
    auth?: true
    createdAt?: true
    _all?: true
  }

  export type PushSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PushSubscription to aggregate.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PushSubscriptions
    **/
    _count?: true | PushSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PushSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PushSubscriptionMaxAggregateInputType
  }

  export type GetPushSubscriptionAggregateType<T extends PushSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePushSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePushSubscription[P]>
      : GetScalarType<T[P], AggregatePushSubscription[P]>
  }




  export type PushSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PushSubscriptionWhereInput
    orderBy?: PushSubscriptionOrderByWithAggregationInput | PushSubscriptionOrderByWithAggregationInput[]
    by: PushSubscriptionScalarFieldEnum[] | PushSubscriptionScalarFieldEnum
    having?: PushSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PushSubscriptionCountAggregateInputType | true
    _min?: PushSubscriptionMinAggregateInputType
    _max?: PushSubscriptionMaxAggregateInputType
  }

  export type PushSubscriptionGroupByOutputType = {
    id: string
    userId: string
    endpoint: string
    p256dh: string
    auth: string
    createdAt: Date
    _count: PushSubscriptionCountAggregateOutputType | null
    _min: PushSubscriptionMinAggregateOutputType | null
    _max: PushSubscriptionMaxAggregateOutputType | null
  }

  type GetPushSubscriptionGroupByPayload<T extends PushSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PushSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PushSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PushSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], PushSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type PushSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    endpoint?: boolean
    p256dh?: boolean
    auth?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pushSubscription"]>

  export type PushSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    endpoint?: boolean
    p256dh?: boolean
    auth?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pushSubscription"]>

  export type PushSubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    endpoint?: boolean
    p256dh?: boolean
    auth?: boolean
    createdAt?: boolean
  }

  export type PushSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PushSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PushSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PushSubscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      endpoint: string
      p256dh: string
      auth: string
      createdAt: Date
    }, ExtArgs["result"]["pushSubscription"]>
    composites: {}
  }

  type PushSubscriptionGetPayload<S extends boolean | null | undefined | PushSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$PushSubscriptionPayload, S>

  type PushSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PushSubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PushSubscriptionCountAggregateInputType | true
    }

  export interface PushSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PushSubscription'], meta: { name: 'PushSubscription' } }
    /**
     * Find zero or one PushSubscription that matches the filter.
     * @param {PushSubscriptionFindUniqueArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PushSubscriptionFindUniqueArgs>(args: SelectSubset<T, PushSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PushSubscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PushSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PushSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PushSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PushSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindFirstArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PushSubscriptionFindFirstArgs>(args?: SelectSubset<T, PushSubscriptionFindFirstArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PushSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindFirstOrThrowArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PushSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PushSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PushSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PushSubscriptions
     * const pushSubscriptions = await prisma.pushSubscription.findMany()
     * 
     * // Get first 10 PushSubscriptions
     * const pushSubscriptions = await prisma.pushSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pushSubscriptionWithIdOnly = await prisma.pushSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PushSubscriptionFindManyArgs>(args?: SelectSubset<T, PushSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PushSubscription.
     * @param {PushSubscriptionCreateArgs} args - Arguments to create a PushSubscription.
     * @example
     * // Create one PushSubscription
     * const PushSubscription = await prisma.pushSubscription.create({
     *   data: {
     *     // ... data to create a PushSubscription
     *   }
     * })
     * 
     */
    create<T extends PushSubscriptionCreateArgs>(args: SelectSubset<T, PushSubscriptionCreateArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PushSubscriptions.
     * @param {PushSubscriptionCreateManyArgs} args - Arguments to create many PushSubscriptions.
     * @example
     * // Create many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PushSubscriptionCreateManyArgs>(args?: SelectSubset<T, PushSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PushSubscriptions and returns the data saved in the database.
     * @param {PushSubscriptionCreateManyAndReturnArgs} args - Arguments to create many PushSubscriptions.
     * @example
     * // Create many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PushSubscriptions and only return the `id`
     * const pushSubscriptionWithIdOnly = await prisma.pushSubscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PushSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PushSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PushSubscription.
     * @param {PushSubscriptionDeleteArgs} args - Arguments to delete one PushSubscription.
     * @example
     * // Delete one PushSubscription
     * const PushSubscription = await prisma.pushSubscription.delete({
     *   where: {
     *     // ... filter to delete one PushSubscription
     *   }
     * })
     * 
     */
    delete<T extends PushSubscriptionDeleteArgs>(args: SelectSubset<T, PushSubscriptionDeleteArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PushSubscription.
     * @param {PushSubscriptionUpdateArgs} args - Arguments to update one PushSubscription.
     * @example
     * // Update one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PushSubscriptionUpdateArgs>(args: SelectSubset<T, PushSubscriptionUpdateArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PushSubscriptions.
     * @param {PushSubscriptionDeleteManyArgs} args - Arguments to filter PushSubscriptions to delete.
     * @example
     * // Delete a few PushSubscriptions
     * const { count } = await prisma.pushSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PushSubscriptionDeleteManyArgs>(args?: SelectSubset<T, PushSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PushSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PushSubscriptionUpdateManyArgs>(args: SelectSubset<T, PushSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PushSubscription.
     * @param {PushSubscriptionUpsertArgs} args - Arguments to update or create a PushSubscription.
     * @example
     * // Update or create a PushSubscription
     * const pushSubscription = await prisma.pushSubscription.upsert({
     *   create: {
     *     // ... data to create a PushSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PushSubscription we want to update
     *   }
     * })
     */
    upsert<T extends PushSubscriptionUpsertArgs>(args: SelectSubset<T, PushSubscriptionUpsertArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PushSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionCountArgs} args - Arguments to filter PushSubscriptions to count.
     * @example
     * // Count the number of PushSubscriptions
     * const count = await prisma.pushSubscription.count({
     *   where: {
     *     // ... the filter for the PushSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends PushSubscriptionCountArgs>(
      args?: Subset<T, PushSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PushSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PushSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PushSubscriptionAggregateArgs>(args: Subset<T, PushSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetPushSubscriptionAggregateType<T>>

    /**
     * Group by PushSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PushSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PushSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: PushSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PushSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPushSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PushSubscription model
   */
  readonly fields: PushSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PushSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PushSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PushSubscription model
   */ 
  interface PushSubscriptionFieldRefs {
    readonly id: FieldRef<"PushSubscription", 'String'>
    readonly userId: FieldRef<"PushSubscription", 'String'>
    readonly endpoint: FieldRef<"PushSubscription", 'String'>
    readonly p256dh: FieldRef<"PushSubscription", 'String'>
    readonly auth: FieldRef<"PushSubscription", 'String'>
    readonly createdAt: FieldRef<"PushSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PushSubscription findUnique
   */
  export type PushSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription findUniqueOrThrow
   */
  export type PushSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription findFirst
   */
  export type PushSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PushSubscriptions.
     */
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * PushSubscription findFirstOrThrow
   */
  export type PushSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PushSubscriptions.
     */
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * PushSubscription findMany
   */
  export type PushSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscriptions to fetch.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * PushSubscription create
   */
  export type PushSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a PushSubscription.
     */
    data: XOR<PushSubscriptionCreateInput, PushSubscriptionUncheckedCreateInput>
  }

  /**
   * PushSubscription createMany
   */
  export type PushSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PushSubscriptions.
     */
    data: PushSubscriptionCreateManyInput | PushSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PushSubscription createManyAndReturn
   */
  export type PushSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PushSubscriptions.
     */
    data: PushSubscriptionCreateManyInput | PushSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PushSubscription update
   */
  export type PushSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a PushSubscription.
     */
    data: XOR<PushSubscriptionUpdateInput, PushSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which PushSubscription to update.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription updateMany
   */
  export type PushSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PushSubscriptions.
     */
    data: XOR<PushSubscriptionUpdateManyMutationInput, PushSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which PushSubscriptions to update
     */
    where?: PushSubscriptionWhereInput
  }

  /**
   * PushSubscription upsert
   */
  export type PushSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the PushSubscription to update in case it exists.
     */
    where: PushSubscriptionWhereUniqueInput
    /**
     * In case the PushSubscription found by the `where` argument doesn't exist, create a new PushSubscription with this data.
     */
    create: XOR<PushSubscriptionCreateInput, PushSubscriptionUncheckedCreateInput>
    /**
     * In case the PushSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PushSubscriptionUpdateInput, PushSubscriptionUncheckedUpdateInput>
  }

  /**
   * PushSubscription delete
   */
  export type PushSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which PushSubscription to delete.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription deleteMany
   */
  export type PushSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PushSubscriptions to delete
     */
    where?: PushSubscriptionWhereInput
  }

  /**
   * PushSubscription without action
   */
  export type PushSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    avatarUrl: 'avatarUrl',
    phone: 'phone',
    venmo: 'venmo',
    paypal: 'paypal',
    zelle: 'zelle',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const TripScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    destination: 'destination',
    startDate: 'startDate',
    endDate: 'endDate',
    coverImage: 'coverImage',
    status: 'status',
    tripMasterId: 'tripMasterId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TripScalarFieldEnum = (typeof TripScalarFieldEnum)[keyof typeof TripScalarFieldEnum]


  export const TripMemberScalarFieldEnum: {
    id: 'id',
    tripId: 'tripId',
    userId: 'userId',
    role: 'role',
    status: 'status',
    paymentStatus: 'paymentStatus',
    paymentAmount: 'paymentAmount',
    paymentConfirmedAt: 'paymentConfirmedAt',
    joinedAt: 'joinedAt'
  };

  export type TripMemberScalarFieldEnum = (typeof TripMemberScalarFieldEnum)[keyof typeof TripMemberScalarFieldEnum]


  export const InviteScalarFieldEnum: {
    id: 'id',
    tripId: 'tripId',
    token: 'token',
    email: 'email',
    phone: 'phone',
    status: 'status',
    expiresAt: 'expiresAt',
    sentById: 'sentById',
    createdAt: 'createdAt'
  };

  export type InviteScalarFieldEnum = (typeof InviteScalarFieldEnum)[keyof typeof InviteScalarFieldEnum]


  export const InviteChannelScalarFieldEnum: {
    id: 'id',
    inviteId: 'inviteId',
    channel: 'channel',
    externalId: 'externalId'
  };

  export type InviteChannelScalarFieldEnum = (typeof InviteChannelScalarFieldEnum)[keyof typeof InviteChannelScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    tripId: 'tripId',
    title: 'title',
    description: 'description',
    location: 'location',
    startTime: 'startTime',
    endTime: 'endTime',
    cost: 'cost',
    currency: 'currency',
    category: 'category',
    proposedBy: 'proposedBy',
    votingEndsAt: 'votingEndsAt',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const VoteScalarFieldEnum: {
    id: 'id',
    activityId: 'activityId',
    userId: 'userId',
    option: 'option'
  };

  export type VoteScalarFieldEnum = (typeof VoteScalarFieldEnum)[keyof typeof VoteScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    tripId: 'tripId',
    activityId: 'activityId',
    bookedBy: 'bookedBy',
    confirmationNum: 'confirmationNum',
    status: 'status',
    receiptUrl: 'receiptUrl',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const TripMessageScalarFieldEnum: {
    id: 'id',
    tripId: 'tripId',
    userId: 'userId',
    content: 'content',
    messageType: 'messageType',
    editedAt: 'editedAt',
    parentId: 'parentId',
    createdAt: 'createdAt'
  };

  export type TripMessageScalarFieldEnum = (typeof TripMessageScalarFieldEnum)[keyof typeof TripMessageScalarFieldEnum]


  export const MessageReactionScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    userId: 'userId',
    emoji: 'emoji'
  };

  export type MessageReactionScalarFieldEnum = (typeof MessageReactionScalarFieldEnum)[keyof typeof MessageReactionScalarFieldEnum]


  export const MessageReadReceiptScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    userId: 'userId',
    readAt: 'readAt'
  };

  export type MessageReadReceiptScalarFieldEnum = (typeof MessageReadReceiptScalarFieldEnum)[keyof typeof MessageReadReceiptScalarFieldEnum]


  export const MediaItemScalarFieldEnum: {
    id: 'id',
    tripId: 'tripId',
    uploaderId: 'uploaderId',
    type: 'type',
    url: 'url',
    thumbnailUrl: 'thumbnailUrl',
    activityId: 'activityId',
    caption: 'caption',
    createdAt: 'createdAt'
  };

  export type MediaItemScalarFieldEnum = (typeof MediaItemScalarFieldEnum)[keyof typeof MediaItemScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tripId: 'tripId',
    type: 'type',
    title: 'title',
    body: 'body',
    actionUrl: 'actionUrl',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const PushSubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    endpoint: 'endpoint',
    p256dh: 'p256dh',
    auth: 'auth',
    createdAt: 'createdAt'
  };

  export type PushSubscriptionScalarFieldEnum = (typeof PushSubscriptionScalarFieldEnum)[keyof typeof PushSubscriptionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'TripStatus'
   */
  export type EnumTripStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TripStatus'>
    


  /**
   * Reference to a field of type 'TripStatus[]'
   */
  export type ListEnumTripStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TripStatus[]'>
    


  /**
   * Reference to a field of type 'MemberRole'
   */
  export type EnumMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberRole'>
    


  /**
   * Reference to a field of type 'MemberRole[]'
   */
  export type ListEnumMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberRole[]'>
    


  /**
   * Reference to a field of type 'MemberStatus'
   */
  export type EnumMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberStatus'>
    


  /**
   * Reference to a field of type 'MemberStatus[]'
   */
  export type ListEnumMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'InviteStatus'
   */
  export type EnumInviteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InviteStatus'>
    


  /**
   * Reference to a field of type 'InviteStatus[]'
   */
  export type ListEnumInviteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InviteStatus[]'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'MessageType'
   */
  export type EnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType'>
    


  /**
   * Reference to a field of type 'MessageType[]'
   */
  export type ListEnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    venmo?: StringNullableFilter<"User"> | string | null
    paypal?: StringNullableFilter<"User"> | string | null
    zelle?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    memberships?: TripMemberListRelationFilter
    createdTrips?: TripListRelationFilter
    activities?: ActivityListRelationFilter
    votes?: VoteListRelationFilter
    messages?: TripMessageListRelationFilter
    mediaItems?: MediaItemListRelationFilter
    notifications?: NotificationListRelationFilter
    sentInvites?: InviteListRelationFilter
    messageReactions?: MessageReactionListRelationFilter
    messageReadReceipts?: MessageReadReceiptListRelationFilter
    pushSubscriptions?: PushSubscriptionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    venmo?: SortOrderInput | SortOrder
    paypal?: SortOrderInput | SortOrder
    zelle?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    memberships?: TripMemberOrderByRelationAggregateInput
    createdTrips?: TripOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
    votes?: VoteOrderByRelationAggregateInput
    messages?: TripMessageOrderByRelationAggregateInput
    mediaItems?: MediaItemOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    sentInvites?: InviteOrderByRelationAggregateInput
    messageReactions?: MessageReactionOrderByRelationAggregateInput
    messageReadReceipts?: MessageReadReceiptOrderByRelationAggregateInput
    pushSubscriptions?: PushSubscriptionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    venmo?: StringNullableFilter<"User"> | string | null
    paypal?: StringNullableFilter<"User"> | string | null
    zelle?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    memberships?: TripMemberListRelationFilter
    createdTrips?: TripListRelationFilter
    activities?: ActivityListRelationFilter
    votes?: VoteListRelationFilter
    messages?: TripMessageListRelationFilter
    mediaItems?: MediaItemListRelationFilter
    notifications?: NotificationListRelationFilter
    sentInvites?: InviteListRelationFilter
    messageReactions?: MessageReactionListRelationFilter
    messageReadReceipts?: MessageReadReceiptListRelationFilter
    pushSubscriptions?: PushSubscriptionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    venmo?: SortOrderInput | SortOrder
    paypal?: SortOrderInput | SortOrder
    zelle?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    venmo?: StringNullableWithAggregatesFilter<"User"> | string | null
    paypal?: StringNullableWithAggregatesFilter<"User"> | string | null
    zelle?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type TripWhereInput = {
    AND?: TripWhereInput | TripWhereInput[]
    OR?: TripWhereInput[]
    NOT?: TripWhereInput | TripWhereInput[]
    id?: StringFilter<"Trip"> | string
    name?: StringFilter<"Trip"> | string
    description?: StringNullableFilter<"Trip"> | string | null
    destination?: StringNullableFilter<"Trip"> | string | null
    startDate?: DateTimeNullableFilter<"Trip"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Trip"> | Date | string | null
    coverImage?: StringNullableFilter<"Trip"> | string | null
    status?: EnumTripStatusFilter<"Trip"> | $Enums.TripStatus
    tripMasterId?: StringFilter<"Trip"> | string
    createdAt?: DateTimeFilter<"Trip"> | Date | string
    updatedAt?: DateTimeFilter<"Trip"> | Date | string
    tripMaster?: XOR<UserRelationFilter, UserWhereInput>
    members?: TripMemberListRelationFilter
    invites?: InviteListRelationFilter
    activities?: ActivityListRelationFilter
    bookings?: BookingListRelationFilter
    messages?: TripMessageListRelationFilter
    mediaItems?: MediaItemListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type TripOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    destination?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    status?: SortOrder
    tripMasterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tripMaster?: UserOrderByWithRelationInput
    members?: TripMemberOrderByRelationAggregateInput
    invites?: InviteOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    messages?: TripMessageOrderByRelationAggregateInput
    mediaItems?: MediaItemOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type TripWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TripWhereInput | TripWhereInput[]
    OR?: TripWhereInput[]
    NOT?: TripWhereInput | TripWhereInput[]
    name?: StringFilter<"Trip"> | string
    description?: StringNullableFilter<"Trip"> | string | null
    destination?: StringNullableFilter<"Trip"> | string | null
    startDate?: DateTimeNullableFilter<"Trip"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Trip"> | Date | string | null
    coverImage?: StringNullableFilter<"Trip"> | string | null
    status?: EnumTripStatusFilter<"Trip"> | $Enums.TripStatus
    tripMasterId?: StringFilter<"Trip"> | string
    createdAt?: DateTimeFilter<"Trip"> | Date | string
    updatedAt?: DateTimeFilter<"Trip"> | Date | string
    tripMaster?: XOR<UserRelationFilter, UserWhereInput>
    members?: TripMemberListRelationFilter
    invites?: InviteListRelationFilter
    activities?: ActivityListRelationFilter
    bookings?: BookingListRelationFilter
    messages?: TripMessageListRelationFilter
    mediaItems?: MediaItemListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type TripOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    destination?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    status?: SortOrder
    tripMasterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TripCountOrderByAggregateInput
    _max?: TripMaxOrderByAggregateInput
    _min?: TripMinOrderByAggregateInput
  }

  export type TripScalarWhereWithAggregatesInput = {
    AND?: TripScalarWhereWithAggregatesInput | TripScalarWhereWithAggregatesInput[]
    OR?: TripScalarWhereWithAggregatesInput[]
    NOT?: TripScalarWhereWithAggregatesInput | TripScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Trip"> | string
    name?: StringWithAggregatesFilter<"Trip"> | string
    description?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    destination?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
    coverImage?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    status?: EnumTripStatusWithAggregatesFilter<"Trip"> | $Enums.TripStatus
    tripMasterId?: StringWithAggregatesFilter<"Trip"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Trip"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Trip"> | Date | string
  }

  export type TripMemberWhereInput = {
    AND?: TripMemberWhereInput | TripMemberWhereInput[]
    OR?: TripMemberWhereInput[]
    NOT?: TripMemberWhereInput | TripMemberWhereInput[]
    id?: StringFilter<"TripMember"> | string
    tripId?: StringFilter<"TripMember"> | string
    userId?: StringFilter<"TripMember"> | string
    role?: EnumMemberRoleFilter<"TripMember"> | $Enums.MemberRole
    status?: EnumMemberStatusFilter<"TripMember"> | $Enums.MemberStatus
    paymentStatus?: StringNullableFilter<"TripMember"> | string | null
    paymentAmount?: DecimalNullableFilter<"TripMember"> | Decimal | DecimalJsLike | number | string | null
    paymentConfirmedAt?: DateTimeNullableFilter<"TripMember"> | Date | string | null
    joinedAt?: DateTimeFilter<"TripMember"> | Date | string
    trip?: XOR<TripRelationFilter, TripWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TripMemberOrderByWithRelationInput = {
    id?: SortOrder
    tripId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrderInput | SortOrder
    paymentAmount?: SortOrderInput | SortOrder
    paymentConfirmedAt?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    trip?: TripOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TripMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tripId_userId?: TripMemberTripIdUserIdCompoundUniqueInput
    AND?: TripMemberWhereInput | TripMemberWhereInput[]
    OR?: TripMemberWhereInput[]
    NOT?: TripMemberWhereInput | TripMemberWhereInput[]
    tripId?: StringFilter<"TripMember"> | string
    userId?: StringFilter<"TripMember"> | string
    role?: EnumMemberRoleFilter<"TripMember"> | $Enums.MemberRole
    status?: EnumMemberStatusFilter<"TripMember"> | $Enums.MemberStatus
    paymentStatus?: StringNullableFilter<"TripMember"> | string | null
    paymentAmount?: DecimalNullableFilter<"TripMember"> | Decimal | DecimalJsLike | number | string | null
    paymentConfirmedAt?: DateTimeNullableFilter<"TripMember"> | Date | string | null
    joinedAt?: DateTimeFilter<"TripMember"> | Date | string
    trip?: XOR<TripRelationFilter, TripWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "tripId_userId">

  export type TripMemberOrderByWithAggregationInput = {
    id?: SortOrder
    tripId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrderInput | SortOrder
    paymentAmount?: SortOrderInput | SortOrder
    paymentConfirmedAt?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    _count?: TripMemberCountOrderByAggregateInput
    _avg?: TripMemberAvgOrderByAggregateInput
    _max?: TripMemberMaxOrderByAggregateInput
    _min?: TripMemberMinOrderByAggregateInput
    _sum?: TripMemberSumOrderByAggregateInput
  }

  export type TripMemberScalarWhereWithAggregatesInput = {
    AND?: TripMemberScalarWhereWithAggregatesInput | TripMemberScalarWhereWithAggregatesInput[]
    OR?: TripMemberScalarWhereWithAggregatesInput[]
    NOT?: TripMemberScalarWhereWithAggregatesInput | TripMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TripMember"> | string
    tripId?: StringWithAggregatesFilter<"TripMember"> | string
    userId?: StringWithAggregatesFilter<"TripMember"> | string
    role?: EnumMemberRoleWithAggregatesFilter<"TripMember"> | $Enums.MemberRole
    status?: EnumMemberStatusWithAggregatesFilter<"TripMember"> | $Enums.MemberStatus
    paymentStatus?: StringNullableWithAggregatesFilter<"TripMember"> | string | null
    paymentAmount?: DecimalNullableWithAggregatesFilter<"TripMember"> | Decimal | DecimalJsLike | number | string | null
    paymentConfirmedAt?: DateTimeNullableWithAggregatesFilter<"TripMember"> | Date | string | null
    joinedAt?: DateTimeWithAggregatesFilter<"TripMember"> | Date | string
  }

  export type InviteWhereInput = {
    AND?: InviteWhereInput | InviteWhereInput[]
    OR?: InviteWhereInput[]
    NOT?: InviteWhereInput | InviteWhereInput[]
    id?: StringFilter<"Invite"> | string
    tripId?: StringFilter<"Invite"> | string
    token?: StringFilter<"Invite"> | string
    email?: StringNullableFilter<"Invite"> | string | null
    phone?: StringNullableFilter<"Invite"> | string | null
    status?: EnumInviteStatusFilter<"Invite"> | $Enums.InviteStatus
    expiresAt?: DateTimeFilter<"Invite"> | Date | string
    sentById?: StringFilter<"Invite"> | string
    createdAt?: DateTimeFilter<"Invite"> | Date | string
    trip?: XOR<TripRelationFilter, TripWhereInput>
    sentBy?: XOR<UserRelationFilter, UserWhereInput>
    channels?: InviteChannelListRelationFilter
  }

  export type InviteOrderByWithRelationInput = {
    id?: SortOrder
    tripId?: SortOrder
    token?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    sentById?: SortOrder
    createdAt?: SortOrder
    trip?: TripOrderByWithRelationInput
    sentBy?: UserOrderByWithRelationInput
    channels?: InviteChannelOrderByRelationAggregateInput
  }

  export type InviteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: InviteWhereInput | InviteWhereInput[]
    OR?: InviteWhereInput[]
    NOT?: InviteWhereInput | InviteWhereInput[]
    tripId?: StringFilter<"Invite"> | string
    email?: StringNullableFilter<"Invite"> | string | null
    phone?: StringNullableFilter<"Invite"> | string | null
    status?: EnumInviteStatusFilter<"Invite"> | $Enums.InviteStatus
    expiresAt?: DateTimeFilter<"Invite"> | Date | string
    sentById?: StringFilter<"Invite"> | string
    createdAt?: DateTimeFilter<"Invite"> | Date | string
    trip?: XOR<TripRelationFilter, TripWhereInput>
    sentBy?: XOR<UserRelationFilter, UserWhereInput>
    channels?: InviteChannelListRelationFilter
  }, "id" | "token">

  export type InviteOrderByWithAggregationInput = {
    id?: SortOrder
    tripId?: SortOrder
    token?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    sentById?: SortOrder
    createdAt?: SortOrder
    _count?: InviteCountOrderByAggregateInput
    _max?: InviteMaxOrderByAggregateInput
    _min?: InviteMinOrderByAggregateInput
  }

  export type InviteScalarWhereWithAggregatesInput = {
    AND?: InviteScalarWhereWithAggregatesInput | InviteScalarWhereWithAggregatesInput[]
    OR?: InviteScalarWhereWithAggregatesInput[]
    NOT?: InviteScalarWhereWithAggregatesInput | InviteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invite"> | string
    tripId?: StringWithAggregatesFilter<"Invite"> | string
    token?: StringWithAggregatesFilter<"Invite"> | string
    email?: StringNullableWithAggregatesFilter<"Invite"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Invite"> | string | null
    status?: EnumInviteStatusWithAggregatesFilter<"Invite"> | $Enums.InviteStatus
    expiresAt?: DateTimeWithAggregatesFilter<"Invite"> | Date | string
    sentById?: StringWithAggregatesFilter<"Invite"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Invite"> | Date | string
  }

  export type InviteChannelWhereInput = {
    AND?: InviteChannelWhereInput | InviteChannelWhereInput[]
    OR?: InviteChannelWhereInput[]
    NOT?: InviteChannelWhereInput | InviteChannelWhereInput[]
    id?: StringFilter<"InviteChannel"> | string
    inviteId?: StringFilter<"InviteChannel"> | string
    channel?: StringFilter<"InviteChannel"> | string
    externalId?: StringNullableFilter<"InviteChannel"> | string | null
    invite?: XOR<InviteRelationFilter, InviteWhereInput>
  }

  export type InviteChannelOrderByWithRelationInput = {
    id?: SortOrder
    inviteId?: SortOrder
    channel?: SortOrder
    externalId?: SortOrderInput | SortOrder
    invite?: InviteOrderByWithRelationInput
  }

  export type InviteChannelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InviteChannelWhereInput | InviteChannelWhereInput[]
    OR?: InviteChannelWhereInput[]
    NOT?: InviteChannelWhereInput | InviteChannelWhereInput[]
    inviteId?: StringFilter<"InviteChannel"> | string
    channel?: StringFilter<"InviteChannel"> | string
    externalId?: StringNullableFilter<"InviteChannel"> | string | null
    invite?: XOR<InviteRelationFilter, InviteWhereInput>
  }, "id">

  export type InviteChannelOrderByWithAggregationInput = {
    id?: SortOrder
    inviteId?: SortOrder
    channel?: SortOrder
    externalId?: SortOrderInput | SortOrder
    _count?: InviteChannelCountOrderByAggregateInput
    _max?: InviteChannelMaxOrderByAggregateInput
    _min?: InviteChannelMinOrderByAggregateInput
  }

  export type InviteChannelScalarWhereWithAggregatesInput = {
    AND?: InviteChannelScalarWhereWithAggregatesInput | InviteChannelScalarWhereWithAggregatesInput[]
    OR?: InviteChannelScalarWhereWithAggregatesInput[]
    NOT?: InviteChannelScalarWhereWithAggregatesInput | InviteChannelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InviteChannel"> | string
    inviteId?: StringWithAggregatesFilter<"InviteChannel"> | string
    channel?: StringWithAggregatesFilter<"InviteChannel"> | string
    externalId?: StringNullableWithAggregatesFilter<"InviteChannel"> | string | null
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: StringFilter<"Activity"> | string
    tripId?: StringFilter<"Activity"> | string
    title?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    location?: StringNullableFilter<"Activity"> | string | null
    startTime?: DateTimeNullableFilter<"Activity"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Activity"> | Date | string | null
    cost?: DecimalNullableFilter<"Activity"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"Activity"> | string
    category?: StringFilter<"Activity"> | string
    proposedBy?: StringFilter<"Activity"> | string
    votingEndsAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    status?: StringFilter<"Activity"> | string
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    trip?: XOR<TripRelationFilter, TripWhereInput>
    proposer?: XOR<UserRelationFilter, UserWhereInput>
    votes?: VoteListRelationFilter
    bookings?: BookingListRelationFilter
    mediaItems?: MediaItemListRelationFilter
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    tripId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    currency?: SortOrder
    category?: SortOrder
    proposedBy?: SortOrder
    votingEndsAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    trip?: TripOrderByWithRelationInput
    proposer?: UserOrderByWithRelationInput
    votes?: VoteOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    mediaItems?: MediaItemOrderByRelationAggregateInput
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    tripId?: StringFilter<"Activity"> | string
    title?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    location?: StringNullableFilter<"Activity"> | string | null
    startTime?: DateTimeNullableFilter<"Activity"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Activity"> | Date | string | null
    cost?: DecimalNullableFilter<"Activity"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"Activity"> | string
    category?: StringFilter<"Activity"> | string
    proposedBy?: StringFilter<"Activity"> | string
    votingEndsAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    status?: StringFilter<"Activity"> | string
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    trip?: XOR<TripRelationFilter, TripWhereInput>
    proposer?: XOR<UserRelationFilter, UserWhereInput>
    votes?: VoteListRelationFilter
    bookings?: BookingListRelationFilter
    mediaItems?: MediaItemListRelationFilter
  }, "id">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    tripId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    currency?: SortOrder
    category?: SortOrder
    proposedBy?: SortOrder
    votingEndsAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _avg?: ActivityAvgOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
    _sum?: ActivitySumOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Activity"> | string
    tripId?: StringWithAggregatesFilter<"Activity"> | string
    title?: StringWithAggregatesFilter<"Activity"> | string
    description?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    location?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    startTime?: DateTimeNullableWithAggregatesFilter<"Activity"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"Activity"> | Date | string | null
    cost?: DecimalNullableWithAggregatesFilter<"Activity"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringWithAggregatesFilter<"Activity"> | string
    category?: StringWithAggregatesFilter<"Activity"> | string
    proposedBy?: StringWithAggregatesFilter<"Activity"> | string
    votingEndsAt?: DateTimeNullableWithAggregatesFilter<"Activity"> | Date | string | null
    status?: StringWithAggregatesFilter<"Activity"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
  }

  export type VoteWhereInput = {
    AND?: VoteWhereInput | VoteWhereInput[]
    OR?: VoteWhereInput[]
    NOT?: VoteWhereInput | VoteWhereInput[]
    id?: StringFilter<"Vote"> | string
    activityId?: StringFilter<"Vote"> | string
    userId?: StringFilter<"Vote"> | string
    option?: StringFilter<"Vote"> | string
    activity?: XOR<ActivityRelationFilter, ActivityWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type VoteOrderByWithRelationInput = {
    id?: SortOrder
    activityId?: SortOrder
    userId?: SortOrder
    option?: SortOrder
    activity?: ActivityOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type VoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    activityId_userId?: VoteActivityIdUserIdCompoundUniqueInput
    AND?: VoteWhereInput | VoteWhereInput[]
    OR?: VoteWhereInput[]
    NOT?: VoteWhereInput | VoteWhereInput[]
    activityId?: StringFilter<"Vote"> | string
    userId?: StringFilter<"Vote"> | string
    option?: StringFilter<"Vote"> | string
    activity?: XOR<ActivityRelationFilter, ActivityWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "activityId_userId">

  export type VoteOrderByWithAggregationInput = {
    id?: SortOrder
    activityId?: SortOrder
    userId?: SortOrder
    option?: SortOrder
    _count?: VoteCountOrderByAggregateInput
    _max?: VoteMaxOrderByAggregateInput
    _min?: VoteMinOrderByAggregateInput
  }

  export type VoteScalarWhereWithAggregatesInput = {
    AND?: VoteScalarWhereWithAggregatesInput | VoteScalarWhereWithAggregatesInput[]
    OR?: VoteScalarWhereWithAggregatesInput[]
    NOT?: VoteScalarWhereWithAggregatesInput | VoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vote"> | string
    activityId?: StringWithAggregatesFilter<"Vote"> | string
    userId?: StringWithAggregatesFilter<"Vote"> | string
    option?: StringWithAggregatesFilter<"Vote"> | string
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: StringFilter<"Booking"> | string
    tripId?: StringFilter<"Booking"> | string
    activityId?: StringNullableFilter<"Booking"> | string | null
    bookedBy?: StringFilter<"Booking"> | string
    confirmationNum?: StringNullableFilter<"Booking"> | string | null
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    receiptUrl?: StringNullableFilter<"Booking"> | string | null
    notes?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    trip?: XOR<TripRelationFilter, TripWhereInput>
    activity?: XOR<ActivityNullableRelationFilter, ActivityWhereInput> | null
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    tripId?: SortOrder
    activityId?: SortOrderInput | SortOrder
    bookedBy?: SortOrder
    confirmationNum?: SortOrderInput | SortOrder
    status?: SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trip?: TripOrderByWithRelationInput
    activity?: ActivityOrderByWithRelationInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    tripId?: StringFilter<"Booking"> | string
    activityId?: StringNullableFilter<"Booking"> | string | null
    bookedBy?: StringFilter<"Booking"> | string
    confirmationNum?: StringNullableFilter<"Booking"> | string | null
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    receiptUrl?: StringNullableFilter<"Booking"> | string | null
    notes?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    trip?: XOR<TripRelationFilter, TripWhereInput>
    activity?: XOR<ActivityNullableRelationFilter, ActivityWhereInput> | null
  }, "id">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    tripId?: SortOrder
    activityId?: SortOrderInput | SortOrder
    bookedBy?: SortOrder
    confirmationNum?: SortOrderInput | SortOrder
    status?: SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Booking"> | string
    tripId?: StringWithAggregatesFilter<"Booking"> | string
    activityId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    bookedBy?: StringWithAggregatesFilter<"Booking"> | string
    confirmationNum?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    status?: EnumBookingStatusWithAggregatesFilter<"Booking"> | $Enums.BookingStatus
    receiptUrl?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type TripMessageWhereInput = {
    AND?: TripMessageWhereInput | TripMessageWhereInput[]
    OR?: TripMessageWhereInput[]
    NOT?: TripMessageWhereInput | TripMessageWhereInput[]
    id?: StringFilter<"TripMessage"> | string
    tripId?: StringFilter<"TripMessage"> | string
    userId?: StringFilter<"TripMessage"> | string
    content?: StringFilter<"TripMessage"> | string
    messageType?: EnumMessageTypeFilter<"TripMessage"> | $Enums.MessageType
    editedAt?: DateTimeNullableFilter<"TripMessage"> | Date | string | null
    parentId?: StringNullableFilter<"TripMessage"> | string | null
    createdAt?: DateTimeFilter<"TripMessage"> | Date | string
    trip?: XOR<TripRelationFilter, TripWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    parent?: XOR<TripMessageNullableRelationFilter, TripMessageWhereInput> | null
    edits?: TripMessageListRelationFilter
    reactions?: MessageReactionListRelationFilter
    readReceipts?: MessageReadReceiptListRelationFilter
  }

  export type TripMessageOrderByWithRelationInput = {
    id?: SortOrder
    tripId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    editedAt?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    trip?: TripOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    parent?: TripMessageOrderByWithRelationInput
    edits?: TripMessageOrderByRelationAggregateInput
    reactions?: MessageReactionOrderByRelationAggregateInput
    readReceipts?: MessageReadReceiptOrderByRelationAggregateInput
  }

  export type TripMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TripMessageWhereInput | TripMessageWhereInput[]
    OR?: TripMessageWhereInput[]
    NOT?: TripMessageWhereInput | TripMessageWhereInput[]
    tripId?: StringFilter<"TripMessage"> | string
    userId?: StringFilter<"TripMessage"> | string
    content?: StringFilter<"TripMessage"> | string
    messageType?: EnumMessageTypeFilter<"TripMessage"> | $Enums.MessageType
    editedAt?: DateTimeNullableFilter<"TripMessage"> | Date | string | null
    parentId?: StringNullableFilter<"TripMessage"> | string | null
    createdAt?: DateTimeFilter<"TripMessage"> | Date | string
    trip?: XOR<TripRelationFilter, TripWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    parent?: XOR<TripMessageNullableRelationFilter, TripMessageWhereInput> | null
    edits?: TripMessageListRelationFilter
    reactions?: MessageReactionListRelationFilter
    readReceipts?: MessageReadReceiptListRelationFilter
  }, "id">

  export type TripMessageOrderByWithAggregationInput = {
    id?: SortOrder
    tripId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    editedAt?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TripMessageCountOrderByAggregateInput
    _max?: TripMessageMaxOrderByAggregateInput
    _min?: TripMessageMinOrderByAggregateInput
  }

  export type TripMessageScalarWhereWithAggregatesInput = {
    AND?: TripMessageScalarWhereWithAggregatesInput | TripMessageScalarWhereWithAggregatesInput[]
    OR?: TripMessageScalarWhereWithAggregatesInput[]
    NOT?: TripMessageScalarWhereWithAggregatesInput | TripMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TripMessage"> | string
    tripId?: StringWithAggregatesFilter<"TripMessage"> | string
    userId?: StringWithAggregatesFilter<"TripMessage"> | string
    content?: StringWithAggregatesFilter<"TripMessage"> | string
    messageType?: EnumMessageTypeWithAggregatesFilter<"TripMessage"> | $Enums.MessageType
    editedAt?: DateTimeNullableWithAggregatesFilter<"TripMessage"> | Date | string | null
    parentId?: StringNullableWithAggregatesFilter<"TripMessage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TripMessage"> | Date | string
  }

  export type MessageReactionWhereInput = {
    AND?: MessageReactionWhereInput | MessageReactionWhereInput[]
    OR?: MessageReactionWhereInput[]
    NOT?: MessageReactionWhereInput | MessageReactionWhereInput[]
    id?: StringFilter<"MessageReaction"> | string
    messageId?: StringFilter<"MessageReaction"> | string
    userId?: StringFilter<"MessageReaction"> | string
    emoji?: StringFilter<"MessageReaction"> | string
    message?: XOR<TripMessageRelationFilter, TripMessageWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MessageReactionOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    emoji?: SortOrder
    message?: TripMessageOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MessageReactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId_userId_emoji?: MessageReactionMessageIdUserIdEmojiCompoundUniqueInput
    AND?: MessageReactionWhereInput | MessageReactionWhereInput[]
    OR?: MessageReactionWhereInput[]
    NOT?: MessageReactionWhereInput | MessageReactionWhereInput[]
    messageId?: StringFilter<"MessageReaction"> | string
    userId?: StringFilter<"MessageReaction"> | string
    emoji?: StringFilter<"MessageReaction"> | string
    message?: XOR<TripMessageRelationFilter, TripMessageWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "messageId_userId_emoji">

  export type MessageReactionOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    emoji?: SortOrder
    _count?: MessageReactionCountOrderByAggregateInput
    _max?: MessageReactionMaxOrderByAggregateInput
    _min?: MessageReactionMinOrderByAggregateInput
  }

  export type MessageReactionScalarWhereWithAggregatesInput = {
    AND?: MessageReactionScalarWhereWithAggregatesInput | MessageReactionScalarWhereWithAggregatesInput[]
    OR?: MessageReactionScalarWhereWithAggregatesInput[]
    NOT?: MessageReactionScalarWhereWithAggregatesInput | MessageReactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageReaction"> | string
    messageId?: StringWithAggregatesFilter<"MessageReaction"> | string
    userId?: StringWithAggregatesFilter<"MessageReaction"> | string
    emoji?: StringWithAggregatesFilter<"MessageReaction"> | string
  }

  export type MessageReadReceiptWhereInput = {
    AND?: MessageReadReceiptWhereInput | MessageReadReceiptWhereInput[]
    OR?: MessageReadReceiptWhereInput[]
    NOT?: MessageReadReceiptWhereInput | MessageReadReceiptWhereInput[]
    id?: StringFilter<"MessageReadReceipt"> | string
    messageId?: StringFilter<"MessageReadReceipt"> | string
    userId?: StringFilter<"MessageReadReceipt"> | string
    readAt?: DateTimeFilter<"MessageReadReceipt"> | Date | string
    message?: XOR<TripMessageRelationFilter, TripMessageWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MessageReadReceiptOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
    message?: TripMessageOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MessageReadReceiptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId_userId?: MessageReadReceiptMessageIdUserIdCompoundUniqueInput
    AND?: MessageReadReceiptWhereInput | MessageReadReceiptWhereInput[]
    OR?: MessageReadReceiptWhereInput[]
    NOT?: MessageReadReceiptWhereInput | MessageReadReceiptWhereInput[]
    messageId?: StringFilter<"MessageReadReceipt"> | string
    userId?: StringFilter<"MessageReadReceipt"> | string
    readAt?: DateTimeFilter<"MessageReadReceipt"> | Date | string
    message?: XOR<TripMessageRelationFilter, TripMessageWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "messageId_userId">

  export type MessageReadReceiptOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
    _count?: MessageReadReceiptCountOrderByAggregateInput
    _max?: MessageReadReceiptMaxOrderByAggregateInput
    _min?: MessageReadReceiptMinOrderByAggregateInput
  }

  export type MessageReadReceiptScalarWhereWithAggregatesInput = {
    AND?: MessageReadReceiptScalarWhereWithAggregatesInput | MessageReadReceiptScalarWhereWithAggregatesInput[]
    OR?: MessageReadReceiptScalarWhereWithAggregatesInput[]
    NOT?: MessageReadReceiptScalarWhereWithAggregatesInput | MessageReadReceiptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageReadReceipt"> | string
    messageId?: StringWithAggregatesFilter<"MessageReadReceipt"> | string
    userId?: StringWithAggregatesFilter<"MessageReadReceipt"> | string
    readAt?: DateTimeWithAggregatesFilter<"MessageReadReceipt"> | Date | string
  }

  export type MediaItemWhereInput = {
    AND?: MediaItemWhereInput | MediaItemWhereInput[]
    OR?: MediaItemWhereInput[]
    NOT?: MediaItemWhereInput | MediaItemWhereInput[]
    id?: StringFilter<"MediaItem"> | string
    tripId?: StringFilter<"MediaItem"> | string
    uploaderId?: StringFilter<"MediaItem"> | string
    type?: StringFilter<"MediaItem"> | string
    url?: StringFilter<"MediaItem"> | string
    thumbnailUrl?: StringNullableFilter<"MediaItem"> | string | null
    activityId?: StringNullableFilter<"MediaItem"> | string | null
    caption?: StringNullableFilter<"MediaItem"> | string | null
    createdAt?: DateTimeFilter<"MediaItem"> | Date | string
    trip?: XOR<TripRelationFilter, TripWhereInput>
    uploader?: XOR<UserRelationFilter, UserWhereInput>
    activity?: XOR<ActivityNullableRelationFilter, ActivityWhereInput> | null
  }

  export type MediaItemOrderByWithRelationInput = {
    id?: SortOrder
    tripId?: SortOrder
    uploaderId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    activityId?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    trip?: TripOrderByWithRelationInput
    uploader?: UserOrderByWithRelationInput
    activity?: ActivityOrderByWithRelationInput
  }

  export type MediaItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaItemWhereInput | MediaItemWhereInput[]
    OR?: MediaItemWhereInput[]
    NOT?: MediaItemWhereInput | MediaItemWhereInput[]
    tripId?: StringFilter<"MediaItem"> | string
    uploaderId?: StringFilter<"MediaItem"> | string
    type?: StringFilter<"MediaItem"> | string
    url?: StringFilter<"MediaItem"> | string
    thumbnailUrl?: StringNullableFilter<"MediaItem"> | string | null
    activityId?: StringNullableFilter<"MediaItem"> | string | null
    caption?: StringNullableFilter<"MediaItem"> | string | null
    createdAt?: DateTimeFilter<"MediaItem"> | Date | string
    trip?: XOR<TripRelationFilter, TripWhereInput>
    uploader?: XOR<UserRelationFilter, UserWhereInput>
    activity?: XOR<ActivityNullableRelationFilter, ActivityWhereInput> | null
  }, "id">

  export type MediaItemOrderByWithAggregationInput = {
    id?: SortOrder
    tripId?: SortOrder
    uploaderId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    activityId?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MediaItemCountOrderByAggregateInput
    _max?: MediaItemMaxOrderByAggregateInput
    _min?: MediaItemMinOrderByAggregateInput
  }

  export type MediaItemScalarWhereWithAggregatesInput = {
    AND?: MediaItemScalarWhereWithAggregatesInput | MediaItemScalarWhereWithAggregatesInput[]
    OR?: MediaItemScalarWhereWithAggregatesInput[]
    NOT?: MediaItemScalarWhereWithAggregatesInput | MediaItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MediaItem"> | string
    tripId?: StringWithAggregatesFilter<"MediaItem"> | string
    uploaderId?: StringWithAggregatesFilter<"MediaItem"> | string
    type?: StringWithAggregatesFilter<"MediaItem"> | string
    url?: StringWithAggregatesFilter<"MediaItem"> | string
    thumbnailUrl?: StringNullableWithAggregatesFilter<"MediaItem"> | string | null
    activityId?: StringNullableWithAggregatesFilter<"MediaItem"> | string | null
    caption?: StringNullableWithAggregatesFilter<"MediaItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MediaItem"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    tripId?: StringNullableFilter<"Notification"> | string | null
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    trip?: XOR<TripNullableRelationFilter, TripWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tripId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    trip?: TripOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    tripId?: StringNullableFilter<"Notification"> | string | null
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    trip?: XOR<TripNullableRelationFilter, TripWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tripId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    tripId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    body?: StringWithAggregatesFilter<"Notification"> | string
    actionUrl?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type PushSubscriptionWhereInput = {
    AND?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    OR?: PushSubscriptionWhereInput[]
    NOT?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    id?: StringFilter<"PushSubscription"> | string
    userId?: StringFilter<"PushSubscription"> | string
    endpoint?: StringFilter<"PushSubscription"> | string
    p256dh?: StringFilter<"PushSubscription"> | string
    auth?: StringFilter<"PushSubscription"> | string
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PushSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PushSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_endpoint?: PushSubscriptionUserIdEndpointCompoundUniqueInput
    AND?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    OR?: PushSubscriptionWhereInput[]
    NOT?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    userId?: StringFilter<"PushSubscription"> | string
    endpoint?: StringFilter<"PushSubscription"> | string
    p256dh?: StringFilter<"PushSubscription"> | string
    auth?: StringFilter<"PushSubscription"> | string
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_endpoint">

  export type PushSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    createdAt?: SortOrder
    _count?: PushSubscriptionCountOrderByAggregateInput
    _max?: PushSubscriptionMaxOrderByAggregateInput
    _min?: PushSubscriptionMinOrderByAggregateInput
  }

  export type PushSubscriptionScalarWhereWithAggregatesInput = {
    AND?: PushSubscriptionScalarWhereWithAggregatesInput | PushSubscriptionScalarWhereWithAggregatesInput[]
    OR?: PushSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: PushSubscriptionScalarWhereWithAggregatesInput | PushSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PushSubscription"> | string
    userId?: StringWithAggregatesFilter<"PushSubscription"> | string
    endpoint?: StringWithAggregatesFilter<"PushSubscription"> | string
    p256dh?: StringWithAggregatesFilter<"PushSubscription"> | string
    auth?: StringWithAggregatesFilter<"PushSubscription"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PushSubscription"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    avatarUrl?: string | null
    phone?: string | null
    venmo?: string | null
    paypal?: string | null
    zelle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TripMemberCreateNestedManyWithoutUserInput
    createdTrips?: TripCreateNestedManyWithoutTripMasterInput
    activities?: ActivityCreateNestedManyWithoutProposerInput
    votes?: VoteCreateNestedManyWithoutUserInput
    messages?: TripMessageCreateNestedManyWithoutUserInput
    mediaItems?: MediaItemCreateNestedManyWithoutUploaderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sentInvites?: InviteCreateNestedManyWithoutSentByInput
    messageReactions?: MessageReactionCreateNestedManyWithoutUserInput
    messageReadReceipts?: MessageReadReceiptCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    avatarUrl?: string | null
    phone?: string | null
    venmo?: string | null
    paypal?: string | null
    zelle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TripMemberUncheckedCreateNestedManyWithoutUserInput
    createdTrips?: TripUncheckedCreateNestedManyWithoutTripMasterInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProposerInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
    messages?: TripMessageUncheckedCreateNestedManyWithoutUserInput
    mediaItems?: MediaItemUncheckedCreateNestedManyWithoutUploaderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sentInvites?: InviteUncheckedCreateNestedManyWithoutSentByInput
    messageReactions?: MessageReactionUncheckedCreateNestedManyWithoutUserInput
    messageReadReceipts?: MessageReadReceiptUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    venmo?: NullableStringFieldUpdateOperationsInput | string | null
    paypal?: NullableStringFieldUpdateOperationsInput | string | null
    zelle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TripMemberUpdateManyWithoutUserNestedInput
    createdTrips?: TripUpdateManyWithoutTripMasterNestedInput
    activities?: ActivityUpdateManyWithoutProposerNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
    messages?: TripMessageUpdateManyWithoutUserNestedInput
    mediaItems?: MediaItemUpdateManyWithoutUploaderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sentInvites?: InviteUpdateManyWithoutSentByNestedInput
    messageReactions?: MessageReactionUpdateManyWithoutUserNestedInput
    messageReadReceipts?: MessageReadReceiptUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    venmo?: NullableStringFieldUpdateOperationsInput | string | null
    paypal?: NullableStringFieldUpdateOperationsInput | string | null
    zelle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TripMemberUncheckedUpdateManyWithoutUserNestedInput
    createdTrips?: TripUncheckedUpdateManyWithoutTripMasterNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProposerNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
    messages?: TripMessageUncheckedUpdateManyWithoutUserNestedInput
    mediaItems?: MediaItemUncheckedUpdateManyWithoutUploaderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sentInvites?: InviteUncheckedUpdateManyWithoutSentByNestedInput
    messageReactions?: MessageReactionUncheckedUpdateManyWithoutUserNestedInput
    messageReadReceipts?: MessageReadReceiptUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    avatarUrl?: string | null
    phone?: string | null
    venmo?: string | null
    paypal?: string | null
    zelle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    venmo?: NullableStringFieldUpdateOperationsInput | string | null
    paypal?: NullableStringFieldUpdateOperationsInput | string | null
    zelle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    venmo?: NullableStringFieldUpdateOperationsInput | string | null
    paypal?: NullableStringFieldUpdateOperationsInput | string | null
    zelle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripCreateInput = {
    id?: string
    name: string
    description?: string | null
    destination?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverImage?: string | null
    status?: $Enums.TripStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tripMaster: UserCreateNestedOneWithoutCreatedTripsInput
    members?: TripMemberCreateNestedManyWithoutTripInput
    invites?: InviteCreateNestedManyWithoutTripInput
    activities?: ActivityCreateNestedManyWithoutTripInput
    bookings?: BookingCreateNestedManyWithoutTripInput
    messages?: TripMessageCreateNestedManyWithoutTripInput
    mediaItems?: MediaItemCreateNestedManyWithoutTripInput
    notifications?: NotificationCreateNestedManyWithoutTripInput
  }

  export type TripUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    destination?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverImage?: string | null
    status?: $Enums.TripStatus
    tripMasterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TripMemberUncheckedCreateNestedManyWithoutTripInput
    invites?: InviteUncheckedCreateNestedManyWithoutTripInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTripInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTripInput
    messages?: TripMessageUncheckedCreateNestedManyWithoutTripInput
    mediaItems?: MediaItemUncheckedCreateNestedManyWithoutTripInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tripMaster?: UserUpdateOneRequiredWithoutCreatedTripsNestedInput
    members?: TripMemberUpdateManyWithoutTripNestedInput
    invites?: InviteUpdateManyWithoutTripNestedInput
    activities?: ActivityUpdateManyWithoutTripNestedInput
    bookings?: BookingUpdateManyWithoutTripNestedInput
    messages?: TripMessageUpdateManyWithoutTripNestedInput
    mediaItems?: MediaItemUpdateManyWithoutTripNestedInput
    notifications?: NotificationUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    tripMasterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TripMemberUncheckedUpdateManyWithoutTripNestedInput
    invites?: InviteUncheckedUpdateManyWithoutTripNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTripNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTripNestedInput
    messages?: TripMessageUncheckedUpdateManyWithoutTripNestedInput
    mediaItems?: MediaItemUncheckedUpdateManyWithoutTripNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTripNestedInput
  }

  export type TripCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    destination?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverImage?: string | null
    status?: $Enums.TripStatus
    tripMasterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TripUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    tripMasterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripMemberCreateInput = {
    id?: string
    role?: $Enums.MemberRole
    status?: $Enums.MemberStatus
    paymentStatus?: string | null
    paymentAmount?: Decimal | DecimalJsLike | number | string | null
    paymentConfirmedAt?: Date | string | null
    joinedAt?: Date | string
    trip: TripCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutMembershipsInput
  }

  export type TripMemberUncheckedCreateInput = {
    id?: string
    tripId: string
    userId: string
    role?: $Enums.MemberRole
    status?: $Enums.MemberStatus
    paymentStatus?: string | null
    paymentAmount?: Decimal | DecimalJsLike | number | string | null
    paymentConfirmedAt?: Date | string | null
    joinedAt?: Date | string
  }

  export type TripMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trip?: TripUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type TripMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripMemberCreateManyInput = {
    id?: string
    tripId: string
    userId: string
    role?: $Enums.MemberRole
    status?: $Enums.MemberStatus
    paymentStatus?: string | null
    paymentAmount?: Decimal | DecimalJsLike | number | string | null
    paymentConfirmedAt?: Date | string | null
    joinedAt?: Date | string
  }

  export type TripMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteCreateInput = {
    id?: string
    token: string
    email?: string | null
    phone?: string | null
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    createdAt?: Date | string
    trip: TripCreateNestedOneWithoutInvitesInput
    sentBy: UserCreateNestedOneWithoutSentInvitesInput
    channels?: InviteChannelCreateNestedManyWithoutInviteInput
  }

  export type InviteUncheckedCreateInput = {
    id?: string
    tripId: string
    token: string
    email?: string | null
    phone?: string | null
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    sentById: string
    createdAt?: Date | string
    channels?: InviteChannelUncheckedCreateNestedManyWithoutInviteInput
  }

  export type InviteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trip?: TripUpdateOneRequiredWithoutInvitesNestedInput
    sentBy?: UserUpdateOneRequiredWithoutSentInvitesNestedInput
    channels?: InviteChannelUpdateManyWithoutInviteNestedInput
  }

  export type InviteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channels?: InviteChannelUncheckedUpdateManyWithoutInviteNestedInput
  }

  export type InviteCreateManyInput = {
    id?: string
    tripId: string
    token: string
    email?: string | null
    phone?: string | null
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    sentById: string
    createdAt?: Date | string
  }

  export type InviteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteChannelCreateInput = {
    id?: string
    channel: string
    externalId?: string | null
    invite: InviteCreateNestedOneWithoutChannelsInput
  }

  export type InviteChannelUncheckedCreateInput = {
    id?: string
    inviteId: string
    channel: string
    externalId?: string | null
  }

  export type InviteChannelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    invite?: InviteUpdateOneRequiredWithoutChannelsNestedInput
  }

  export type InviteChannelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteId?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InviteChannelCreateManyInput = {
    id?: string
    inviteId: string
    channel: string
    externalId?: string | null
  }

  export type InviteChannelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InviteChannelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteId?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityCreateInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startTime?: Date | string | null
    endTime?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    category: string
    votingEndsAt?: Date | string | null
    status?: string
    createdAt?: Date | string
    trip: TripCreateNestedOneWithoutActivitiesInput
    proposer: UserCreateNestedOneWithoutActivitiesInput
    votes?: VoteCreateNestedManyWithoutActivityInput
    bookings?: BookingCreateNestedManyWithoutActivityInput
    mediaItems?: MediaItemCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: string
    tripId: string
    title: string
    description?: string | null
    location?: string | null
    startTime?: Date | string | null
    endTime?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    category: string
    proposedBy: string
    votingEndsAt?: Date | string | null
    status?: string
    createdAt?: Date | string
    votes?: VoteUncheckedCreateNestedManyWithoutActivityInput
    bookings?: BookingUncheckedCreateNestedManyWithoutActivityInput
    mediaItems?: MediaItemUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    votingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trip?: TripUpdateOneRequiredWithoutActivitiesNestedInput
    proposer?: UserUpdateOneRequiredWithoutActivitiesNestedInput
    votes?: VoteUpdateManyWithoutActivityNestedInput
    bookings?: BookingUpdateManyWithoutActivityNestedInput
    mediaItems?: MediaItemUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    proposedBy?: StringFieldUpdateOperationsInput | string
    votingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: VoteUncheckedUpdateManyWithoutActivityNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutActivityNestedInput
    mediaItems?: MediaItemUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityCreateManyInput = {
    id?: string
    tripId: string
    title: string
    description?: string | null
    location?: string | null
    startTime?: Date | string | null
    endTime?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    category: string
    proposedBy: string
    votingEndsAt?: Date | string | null
    status?: string
    createdAt?: Date | string
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    votingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    proposedBy?: StringFieldUpdateOperationsInput | string
    votingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteCreateInput = {
    id?: string
    option: string
    activity: ActivityCreateNestedOneWithoutVotesInput
    user: UserCreateNestedOneWithoutVotesInput
  }

  export type VoteUncheckedCreateInput = {
    id?: string
    activityId: string
    userId: string
    option: string
  }

  export type VoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    option?: StringFieldUpdateOperationsInput | string
    activity?: ActivityUpdateOneRequiredWithoutVotesNestedInput
    user?: UserUpdateOneRequiredWithoutVotesNestedInput
  }

  export type VoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    option?: StringFieldUpdateOperationsInput | string
  }

  export type VoteCreateManyInput = {
    id?: string
    activityId: string
    userId: string
    option: string
  }

  export type VoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    option?: StringFieldUpdateOperationsInput | string
  }

  export type VoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    option?: StringFieldUpdateOperationsInput | string
  }

  export type BookingCreateInput = {
    id?: string
    bookedBy: string
    confirmationNum?: string | null
    status?: $Enums.BookingStatus
    receiptUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trip: TripCreateNestedOneWithoutBookingsInput
    activity?: ActivityCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateInput = {
    id?: string
    tripId: string
    activityId?: string | null
    bookedBy: string
    confirmationNum?: string | null
    status?: $Enums.BookingStatus
    receiptUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookedBy?: StringFieldUpdateOperationsInput | string
    confirmationNum?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trip?: TripUpdateOneRequiredWithoutBookingsNestedInput
    activity?: ActivityUpdateOneWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    bookedBy?: StringFieldUpdateOperationsInput | string
    confirmationNum?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyInput = {
    id?: string
    tripId: string
    activityId?: string | null
    bookedBy: string
    confirmationNum?: string | null
    status?: $Enums.BookingStatus
    receiptUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookedBy?: StringFieldUpdateOperationsInput | string
    confirmationNum?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    bookedBy?: StringFieldUpdateOperationsInput | string
    confirmationNum?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripMessageCreateInput = {
    id?: string
    content: string
    messageType?: $Enums.MessageType
    editedAt?: Date | string | null
    createdAt?: Date | string
    trip: TripCreateNestedOneWithoutMessagesInput
    user: UserCreateNestedOneWithoutMessagesInput
    parent?: TripMessageCreateNestedOneWithoutEditsInput
    edits?: TripMessageCreateNestedManyWithoutParentInput
    reactions?: MessageReactionCreateNestedManyWithoutMessageInput
    readReceipts?: MessageReadReceiptCreateNestedManyWithoutMessageInput
  }

  export type TripMessageUncheckedCreateInput = {
    id?: string
    tripId: string
    userId: string
    content: string
    messageType?: $Enums.MessageType
    editedAt?: Date | string | null
    parentId?: string | null
    createdAt?: Date | string
    edits?: TripMessageUncheckedCreateNestedManyWithoutParentInput
    reactions?: MessageReactionUncheckedCreateNestedManyWithoutMessageInput
    readReceipts?: MessageReadReceiptUncheckedCreateNestedManyWithoutMessageInput
  }

  export type TripMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trip?: TripUpdateOneRequiredWithoutMessagesNestedInput
    user?: UserUpdateOneRequiredWithoutMessagesNestedInput
    parent?: TripMessageUpdateOneWithoutEditsNestedInput
    edits?: TripMessageUpdateManyWithoutParentNestedInput
    reactions?: MessageReactionUpdateManyWithoutMessageNestedInput
    readReceipts?: MessageReadReceiptUpdateManyWithoutMessageNestedInput
  }

  export type TripMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    edits?: TripMessageUncheckedUpdateManyWithoutParentNestedInput
    reactions?: MessageReactionUncheckedUpdateManyWithoutMessageNestedInput
    readReceipts?: MessageReadReceiptUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type TripMessageCreateManyInput = {
    id?: string
    tripId: string
    userId: string
    content: string
    messageType?: $Enums.MessageType
    editedAt?: Date | string | null
    parentId?: string | null
    createdAt?: Date | string
  }

  export type TripMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReactionCreateInput = {
    id?: string
    emoji: string
    message: TripMessageCreateNestedOneWithoutReactionsInput
    user: UserCreateNestedOneWithoutMessageReactionsInput
  }

  export type MessageReactionUncheckedCreateInput = {
    id?: string
    messageId: string
    userId: string
    emoji: string
  }

  export type MessageReactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    message?: TripMessageUpdateOneRequiredWithoutReactionsNestedInput
    user?: UserUpdateOneRequiredWithoutMessageReactionsNestedInput
  }

  export type MessageReactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
  }

  export type MessageReactionCreateManyInput = {
    id?: string
    messageId: string
    userId: string
    emoji: string
  }

  export type MessageReactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
  }

  export type MessageReactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
  }

  export type MessageReadReceiptCreateInput = {
    id?: string
    readAt?: Date | string
    message: TripMessageCreateNestedOneWithoutReadReceiptsInput
    user: UserCreateNestedOneWithoutMessageReadReceiptsInput
  }

  export type MessageReadReceiptUncheckedCreateInput = {
    id?: string
    messageId: string
    userId: string
    readAt?: Date | string
  }

  export type MessageReadReceiptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: TripMessageUpdateOneRequiredWithoutReadReceiptsNestedInput
    user?: UserUpdateOneRequiredWithoutMessageReadReceiptsNestedInput
  }

  export type MessageReadReceiptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadReceiptCreateManyInput = {
    id?: string
    messageId: string
    userId: string
    readAt?: Date | string
  }

  export type MessageReadReceiptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadReceiptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaItemCreateInput = {
    id?: string
    type: string
    url: string
    thumbnailUrl?: string | null
    caption?: string | null
    createdAt?: Date | string
    trip: TripCreateNestedOneWithoutMediaItemsInput
    uploader: UserCreateNestedOneWithoutMediaItemsInput
    activity?: ActivityCreateNestedOneWithoutMediaItemsInput
  }

  export type MediaItemUncheckedCreateInput = {
    id?: string
    tripId: string
    uploaderId: string
    type: string
    url: string
    thumbnailUrl?: string | null
    activityId?: string | null
    caption?: string | null
    createdAt?: Date | string
  }

  export type MediaItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trip?: TripUpdateOneRequiredWithoutMediaItemsNestedInput
    uploader?: UserUpdateOneRequiredWithoutMediaItemsNestedInput
    activity?: ActivityUpdateOneWithoutMediaItemsNestedInput
  }

  export type MediaItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    uploaderId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaItemCreateManyInput = {
    id?: string
    tripId: string
    uploaderId: string
    type: string
    url: string
    thumbnailUrl?: string | null
    activityId?: string | null
    caption?: string | null
    createdAt?: Date | string
  }

  export type MediaItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    uploaderId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    title: string
    body: string
    actionUrl?: string | null
    read?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
    trip?: TripCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    tripId?: string | null
    type: string
    title: string
    body: string
    actionUrl?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    trip?: TripUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tripId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    tripId?: string | null
    type: string
    title: string
    body: string
    actionUrl?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tripId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionCreateInput = {
    id?: string
    endpoint: string
    p256dh: string
    auth: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPushSubscriptionsInput
  }

  export type PushSubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    endpoint: string
    p256dh: string
    auth: string
    createdAt?: Date | string
  }

  export type PushSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPushSubscriptionsNestedInput
  }

  export type PushSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionCreateManyInput = {
    id?: string
    userId: string
    endpoint: string
    p256dh: string
    auth: string
    createdAt?: Date | string
  }

  export type PushSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type TripMemberListRelationFilter = {
    every?: TripMemberWhereInput
    some?: TripMemberWhereInput
    none?: TripMemberWhereInput
  }

  export type TripListRelationFilter = {
    every?: TripWhereInput
    some?: TripWhereInput
    none?: TripWhereInput
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type VoteListRelationFilter = {
    every?: VoteWhereInput
    some?: VoteWhereInput
    none?: VoteWhereInput
  }

  export type TripMessageListRelationFilter = {
    every?: TripMessageWhereInput
    some?: TripMessageWhereInput
    none?: TripMessageWhereInput
  }

  export type MediaItemListRelationFilter = {
    every?: MediaItemWhereInput
    some?: MediaItemWhereInput
    none?: MediaItemWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type InviteListRelationFilter = {
    every?: InviteWhereInput
    some?: InviteWhereInput
    none?: InviteWhereInput
  }

  export type MessageReactionListRelationFilter = {
    every?: MessageReactionWhereInput
    some?: MessageReactionWhereInput
    none?: MessageReactionWhereInput
  }

  export type MessageReadReceiptListRelationFilter = {
    every?: MessageReadReceiptWhereInput
    some?: MessageReadReceiptWhereInput
    none?: MessageReadReceiptWhereInput
  }

  export type PushSubscriptionListRelationFilter = {
    every?: PushSubscriptionWhereInput
    some?: PushSubscriptionWhereInput
    none?: PushSubscriptionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TripMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TripOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TripMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InviteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageReactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageReadReceiptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PushSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    phone?: SortOrder
    venmo?: SortOrder
    paypal?: SortOrder
    zelle?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    phone?: SortOrder
    venmo?: SortOrder
    paypal?: SortOrder
    zelle?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    phone?: SortOrder
    venmo?: SortOrder
    paypal?: SortOrder
    zelle?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumTripStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TripStatus | EnumTripStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TripStatus[] | ListEnumTripStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TripStatus[] | ListEnumTripStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTripStatusFilter<$PrismaModel> | $Enums.TripStatus
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TripCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    destination?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    coverImage?: SortOrder
    status?: SortOrder
    tripMasterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TripMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    destination?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    coverImage?: SortOrder
    status?: SortOrder
    tripMasterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TripMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    destination?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    coverImage?: SortOrder
    status?: SortOrder
    tripMasterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumTripStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TripStatus | EnumTripStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TripStatus[] | ListEnumTripStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TripStatus[] | ListEnumTripStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTripStatusWithAggregatesFilter<$PrismaModel> | $Enums.TripStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTripStatusFilter<$PrismaModel>
    _max?: NestedEnumTripStatusFilter<$PrismaModel>
  }

  export type EnumMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberRoleFilter<$PrismaModel> | $Enums.MemberRole
  }

  export type EnumMemberStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberStatus | EnumMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberStatusFilter<$PrismaModel> | $Enums.MemberStatus
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type TripRelationFilter = {
    is?: TripWhereInput
    isNot?: TripWhereInput
  }

  export type TripMemberTripIdUserIdCompoundUniqueInput = {
    tripId: string
    userId: string
  }

  export type TripMemberCountOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    paymentAmount?: SortOrder
    paymentConfirmedAt?: SortOrder
    joinedAt?: SortOrder
  }

  export type TripMemberAvgOrderByAggregateInput = {
    paymentAmount?: SortOrder
  }

  export type TripMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    paymentAmount?: SortOrder
    paymentConfirmedAt?: SortOrder
    joinedAt?: SortOrder
  }

  export type TripMemberMinOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    paymentAmount?: SortOrder
    paymentConfirmedAt?: SortOrder
    joinedAt?: SortOrder
  }

  export type TripMemberSumOrderByAggregateInput = {
    paymentAmount?: SortOrder
  }

  export type EnumMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.MemberRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberRoleFilter<$PrismaModel>
    _max?: NestedEnumMemberRoleFilter<$PrismaModel>
  }

  export type EnumMemberStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberStatus | EnumMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberStatusWithAggregatesFilter<$PrismaModel> | $Enums.MemberStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberStatusFilter<$PrismaModel>
    _max?: NestedEnumMemberStatusFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumInviteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusFilter<$PrismaModel> | $Enums.InviteStatus
  }

  export type InviteChannelListRelationFilter = {
    every?: InviteChannelWhereInput
    some?: InviteChannelWhereInput
    none?: InviteChannelWhereInput
  }

  export type InviteChannelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InviteCountOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    token?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    sentById?: SortOrder
    createdAt?: SortOrder
  }

  export type InviteMaxOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    token?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    sentById?: SortOrder
    createdAt?: SortOrder
  }

  export type InviteMinOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    token?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    sentById?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumInviteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusWithAggregatesFilter<$PrismaModel> | $Enums.InviteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInviteStatusFilter<$PrismaModel>
    _max?: NestedEnumInviteStatusFilter<$PrismaModel>
  }

  export type InviteRelationFilter = {
    is?: InviteWhereInput
    isNot?: InviteWhereInput
  }

  export type InviteChannelCountOrderByAggregateInput = {
    id?: SortOrder
    inviteId?: SortOrder
    channel?: SortOrder
    externalId?: SortOrder
  }

  export type InviteChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    inviteId?: SortOrder
    channel?: SortOrder
    externalId?: SortOrder
  }

  export type InviteChannelMinOrderByAggregateInput = {
    id?: SortOrder
    inviteId?: SortOrder
    channel?: SortOrder
    externalId?: SortOrder
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    cost?: SortOrder
    currency?: SortOrder
    category?: SortOrder
    proposedBy?: SortOrder
    votingEndsAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityAvgOrderByAggregateInput = {
    cost?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    cost?: SortOrder
    currency?: SortOrder
    category?: SortOrder
    proposedBy?: SortOrder
    votingEndsAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    cost?: SortOrder
    currency?: SortOrder
    category?: SortOrder
    proposedBy?: SortOrder
    votingEndsAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivitySumOrderByAggregateInput = {
    cost?: SortOrder
  }

  export type ActivityRelationFilter = {
    is?: ActivityWhereInput
    isNot?: ActivityWhereInput
  }

  export type VoteActivityIdUserIdCompoundUniqueInput = {
    activityId: string
    userId: string
  }

  export type VoteCountOrderByAggregateInput = {
    id?: SortOrder
    activityId?: SortOrder
    userId?: SortOrder
    option?: SortOrder
  }

  export type VoteMaxOrderByAggregateInput = {
    id?: SortOrder
    activityId?: SortOrder
    userId?: SortOrder
    option?: SortOrder
  }

  export type VoteMinOrderByAggregateInput = {
    id?: SortOrder
    activityId?: SortOrder
    userId?: SortOrder
    option?: SortOrder
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type ActivityNullableRelationFilter = {
    is?: ActivityWhereInput | null
    isNot?: ActivityWhereInput | null
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    activityId?: SortOrder
    bookedBy?: SortOrder
    confirmationNum?: SortOrder
    status?: SortOrder
    receiptUrl?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    activityId?: SortOrder
    bookedBy?: SortOrder
    confirmationNum?: SortOrder
    status?: SortOrder
    receiptUrl?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    activityId?: SortOrder
    bookedBy?: SortOrder
    confirmationNum?: SortOrder
    status?: SortOrder
    receiptUrl?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type EnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type TripMessageNullableRelationFilter = {
    is?: TripMessageWhereInput | null
    isNot?: TripMessageWhereInput | null
  }

  export type TripMessageCountOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    editedAt?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
  }

  export type TripMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    editedAt?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
  }

  export type TripMessageMinOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    editedAt?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type TripMessageRelationFilter = {
    is?: TripMessageWhereInput
    isNot?: TripMessageWhereInput
  }

  export type MessageReactionMessageIdUserIdEmojiCompoundUniqueInput = {
    messageId: string
    userId: string
    emoji: string
  }

  export type MessageReactionCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    emoji?: SortOrder
  }

  export type MessageReactionMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    emoji?: SortOrder
  }

  export type MessageReactionMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    emoji?: SortOrder
  }

  export type MessageReadReceiptMessageIdUserIdCompoundUniqueInput = {
    messageId: string
    userId: string
  }

  export type MessageReadReceiptCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type MessageReadReceiptMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type MessageReadReceiptMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type MediaItemCountOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    uploaderId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    activityId?: SortOrder
    caption?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaItemMaxOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    uploaderId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    activityId?: SortOrder
    caption?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaItemMinOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    uploaderId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    activityId?: SortOrder
    caption?: SortOrder
    createdAt?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type TripNullableRelationFilter = {
    is?: TripWhereInput | null
    isNot?: TripWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tripId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    actionUrl?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tripId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    actionUrl?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tripId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    actionUrl?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type PushSubscriptionUserIdEndpointCompoundUniqueInput = {
    userId: string
    endpoint: string
  }

  export type PushSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    createdAt?: SortOrder
  }

  export type PushSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    createdAt?: SortOrder
  }

  export type PushSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    createdAt?: SortOrder
  }

  export type TripMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<TripMemberCreateWithoutUserInput, TripMemberUncheckedCreateWithoutUserInput> | TripMemberCreateWithoutUserInput[] | TripMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TripMemberCreateOrConnectWithoutUserInput | TripMemberCreateOrConnectWithoutUserInput[]
    createMany?: TripMemberCreateManyUserInputEnvelope
    connect?: TripMemberWhereUniqueInput | TripMemberWhereUniqueInput[]
  }

  export type TripCreateNestedManyWithoutTripMasterInput = {
    create?: XOR<TripCreateWithoutTripMasterInput, TripUncheckedCreateWithoutTripMasterInput> | TripCreateWithoutTripMasterInput[] | TripUncheckedCreateWithoutTripMasterInput[]
    connectOrCreate?: TripCreateOrConnectWithoutTripMasterInput | TripCreateOrConnectWithoutTripMasterInput[]
    createMany?: TripCreateManyTripMasterInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutProposerInput = {
    create?: XOR<ActivityCreateWithoutProposerInput, ActivityUncheckedCreateWithoutProposerInput> | ActivityCreateWithoutProposerInput[] | ActivityUncheckedCreateWithoutProposerInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutProposerInput | ActivityCreateOrConnectWithoutProposerInput[]
    createMany?: ActivityCreateManyProposerInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type VoteCreateNestedManyWithoutUserInput = {
    create?: XOR<VoteCreateWithoutUserInput, VoteUncheckedCreateWithoutUserInput> | VoteCreateWithoutUserInput[] | VoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutUserInput | VoteCreateOrConnectWithoutUserInput[]
    createMany?: VoteCreateManyUserInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type TripMessageCreateNestedManyWithoutUserInput = {
    create?: XOR<TripMessageCreateWithoutUserInput, TripMessageUncheckedCreateWithoutUserInput> | TripMessageCreateWithoutUserInput[] | TripMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TripMessageCreateOrConnectWithoutUserInput | TripMessageCreateOrConnectWithoutUserInput[]
    createMany?: TripMessageCreateManyUserInputEnvelope
    connect?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
  }

  export type MediaItemCreateNestedManyWithoutUploaderInput = {
    create?: XOR<MediaItemCreateWithoutUploaderInput, MediaItemUncheckedCreateWithoutUploaderInput> | MediaItemCreateWithoutUploaderInput[] | MediaItemUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: MediaItemCreateOrConnectWithoutUploaderInput | MediaItemCreateOrConnectWithoutUploaderInput[]
    createMany?: MediaItemCreateManyUploaderInputEnvelope
    connect?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type InviteCreateNestedManyWithoutSentByInput = {
    create?: XOR<InviteCreateWithoutSentByInput, InviteUncheckedCreateWithoutSentByInput> | InviteCreateWithoutSentByInput[] | InviteUncheckedCreateWithoutSentByInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutSentByInput | InviteCreateOrConnectWithoutSentByInput[]
    createMany?: InviteCreateManySentByInputEnvelope
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
  }

  export type MessageReactionCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageReactionCreateWithoutUserInput, MessageReactionUncheckedCreateWithoutUserInput> | MessageReactionCreateWithoutUserInput[] | MessageReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageReactionCreateOrConnectWithoutUserInput | MessageReactionCreateOrConnectWithoutUserInput[]
    createMany?: MessageReactionCreateManyUserInputEnvelope
    connect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
  }

  export type MessageReadReceiptCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageReadReceiptCreateWithoutUserInput, MessageReadReceiptUncheckedCreateWithoutUserInput> | MessageReadReceiptCreateWithoutUserInput[] | MessageReadReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageReadReceiptCreateOrConnectWithoutUserInput | MessageReadReceiptCreateOrConnectWithoutUserInput[]
    createMany?: MessageReadReceiptCreateManyUserInputEnvelope
    connect?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
  }

  export type PushSubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
  }

  export type TripMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TripMemberCreateWithoutUserInput, TripMemberUncheckedCreateWithoutUserInput> | TripMemberCreateWithoutUserInput[] | TripMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TripMemberCreateOrConnectWithoutUserInput | TripMemberCreateOrConnectWithoutUserInput[]
    createMany?: TripMemberCreateManyUserInputEnvelope
    connect?: TripMemberWhereUniqueInput | TripMemberWhereUniqueInput[]
  }

  export type TripUncheckedCreateNestedManyWithoutTripMasterInput = {
    create?: XOR<TripCreateWithoutTripMasterInput, TripUncheckedCreateWithoutTripMasterInput> | TripCreateWithoutTripMasterInput[] | TripUncheckedCreateWithoutTripMasterInput[]
    connectOrCreate?: TripCreateOrConnectWithoutTripMasterInput | TripCreateOrConnectWithoutTripMasterInput[]
    createMany?: TripCreateManyTripMasterInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutProposerInput = {
    create?: XOR<ActivityCreateWithoutProposerInput, ActivityUncheckedCreateWithoutProposerInput> | ActivityCreateWithoutProposerInput[] | ActivityUncheckedCreateWithoutProposerInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutProposerInput | ActivityCreateOrConnectWithoutProposerInput[]
    createMany?: ActivityCreateManyProposerInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type VoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VoteCreateWithoutUserInput, VoteUncheckedCreateWithoutUserInput> | VoteCreateWithoutUserInput[] | VoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutUserInput | VoteCreateOrConnectWithoutUserInput[]
    createMany?: VoteCreateManyUserInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type TripMessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TripMessageCreateWithoutUserInput, TripMessageUncheckedCreateWithoutUserInput> | TripMessageCreateWithoutUserInput[] | TripMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TripMessageCreateOrConnectWithoutUserInput | TripMessageCreateOrConnectWithoutUserInput[]
    createMany?: TripMessageCreateManyUserInputEnvelope
    connect?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
  }

  export type MediaItemUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<MediaItemCreateWithoutUploaderInput, MediaItemUncheckedCreateWithoutUploaderInput> | MediaItemCreateWithoutUploaderInput[] | MediaItemUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: MediaItemCreateOrConnectWithoutUploaderInput | MediaItemCreateOrConnectWithoutUploaderInput[]
    createMany?: MediaItemCreateManyUploaderInputEnvelope
    connect?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type InviteUncheckedCreateNestedManyWithoutSentByInput = {
    create?: XOR<InviteCreateWithoutSentByInput, InviteUncheckedCreateWithoutSentByInput> | InviteCreateWithoutSentByInput[] | InviteUncheckedCreateWithoutSentByInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutSentByInput | InviteCreateOrConnectWithoutSentByInput[]
    createMany?: InviteCreateManySentByInputEnvelope
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
  }

  export type MessageReactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageReactionCreateWithoutUserInput, MessageReactionUncheckedCreateWithoutUserInput> | MessageReactionCreateWithoutUserInput[] | MessageReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageReactionCreateOrConnectWithoutUserInput | MessageReactionCreateOrConnectWithoutUserInput[]
    createMany?: MessageReactionCreateManyUserInputEnvelope
    connect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
  }

  export type MessageReadReceiptUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageReadReceiptCreateWithoutUserInput, MessageReadReceiptUncheckedCreateWithoutUserInput> | MessageReadReceiptCreateWithoutUserInput[] | MessageReadReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageReadReceiptCreateOrConnectWithoutUserInput | MessageReadReceiptCreateOrConnectWithoutUserInput[]
    createMany?: MessageReadReceiptCreateManyUserInputEnvelope
    connect?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
  }

  export type PushSubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TripMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<TripMemberCreateWithoutUserInput, TripMemberUncheckedCreateWithoutUserInput> | TripMemberCreateWithoutUserInput[] | TripMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TripMemberCreateOrConnectWithoutUserInput | TripMemberCreateOrConnectWithoutUserInput[]
    upsert?: TripMemberUpsertWithWhereUniqueWithoutUserInput | TripMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TripMemberCreateManyUserInputEnvelope
    set?: TripMemberWhereUniqueInput | TripMemberWhereUniqueInput[]
    disconnect?: TripMemberWhereUniqueInput | TripMemberWhereUniqueInput[]
    delete?: TripMemberWhereUniqueInput | TripMemberWhereUniqueInput[]
    connect?: TripMemberWhereUniqueInput | TripMemberWhereUniqueInput[]
    update?: TripMemberUpdateWithWhereUniqueWithoutUserInput | TripMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TripMemberUpdateManyWithWhereWithoutUserInput | TripMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TripMemberScalarWhereInput | TripMemberScalarWhereInput[]
  }

  export type TripUpdateManyWithoutTripMasterNestedInput = {
    create?: XOR<TripCreateWithoutTripMasterInput, TripUncheckedCreateWithoutTripMasterInput> | TripCreateWithoutTripMasterInput[] | TripUncheckedCreateWithoutTripMasterInput[]
    connectOrCreate?: TripCreateOrConnectWithoutTripMasterInput | TripCreateOrConnectWithoutTripMasterInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutTripMasterInput | TripUpsertWithWhereUniqueWithoutTripMasterInput[]
    createMany?: TripCreateManyTripMasterInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutTripMasterInput | TripUpdateWithWhereUniqueWithoutTripMasterInput[]
    updateMany?: TripUpdateManyWithWhereWithoutTripMasterInput | TripUpdateManyWithWhereWithoutTripMasterInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutProposerNestedInput = {
    create?: XOR<ActivityCreateWithoutProposerInput, ActivityUncheckedCreateWithoutProposerInput> | ActivityCreateWithoutProposerInput[] | ActivityUncheckedCreateWithoutProposerInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutProposerInput | ActivityCreateOrConnectWithoutProposerInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutProposerInput | ActivityUpsertWithWhereUniqueWithoutProposerInput[]
    createMany?: ActivityCreateManyProposerInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutProposerInput | ActivityUpdateWithWhereUniqueWithoutProposerInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutProposerInput | ActivityUpdateManyWithWhereWithoutProposerInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type VoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<VoteCreateWithoutUserInput, VoteUncheckedCreateWithoutUserInput> | VoteCreateWithoutUserInput[] | VoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutUserInput | VoteCreateOrConnectWithoutUserInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutUserInput | VoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VoteCreateManyUserInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutUserInput | VoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutUserInput | VoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type TripMessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<TripMessageCreateWithoutUserInput, TripMessageUncheckedCreateWithoutUserInput> | TripMessageCreateWithoutUserInput[] | TripMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TripMessageCreateOrConnectWithoutUserInput | TripMessageCreateOrConnectWithoutUserInput[]
    upsert?: TripMessageUpsertWithWhereUniqueWithoutUserInput | TripMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TripMessageCreateManyUserInputEnvelope
    set?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
    disconnect?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
    delete?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
    connect?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
    update?: TripMessageUpdateWithWhereUniqueWithoutUserInput | TripMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TripMessageUpdateManyWithWhereWithoutUserInput | TripMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TripMessageScalarWhereInput | TripMessageScalarWhereInput[]
  }

  export type MediaItemUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<MediaItemCreateWithoutUploaderInput, MediaItemUncheckedCreateWithoutUploaderInput> | MediaItemCreateWithoutUploaderInput[] | MediaItemUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: MediaItemCreateOrConnectWithoutUploaderInput | MediaItemCreateOrConnectWithoutUploaderInput[]
    upsert?: MediaItemUpsertWithWhereUniqueWithoutUploaderInput | MediaItemUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: MediaItemCreateManyUploaderInputEnvelope
    set?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
    disconnect?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
    delete?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
    connect?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
    update?: MediaItemUpdateWithWhereUniqueWithoutUploaderInput | MediaItemUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: MediaItemUpdateManyWithWhereWithoutUploaderInput | MediaItemUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: MediaItemScalarWhereInput | MediaItemScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type InviteUpdateManyWithoutSentByNestedInput = {
    create?: XOR<InviteCreateWithoutSentByInput, InviteUncheckedCreateWithoutSentByInput> | InviteCreateWithoutSentByInput[] | InviteUncheckedCreateWithoutSentByInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutSentByInput | InviteCreateOrConnectWithoutSentByInput[]
    upsert?: InviteUpsertWithWhereUniqueWithoutSentByInput | InviteUpsertWithWhereUniqueWithoutSentByInput[]
    createMany?: InviteCreateManySentByInputEnvelope
    set?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    disconnect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    delete?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    update?: InviteUpdateWithWhereUniqueWithoutSentByInput | InviteUpdateWithWhereUniqueWithoutSentByInput[]
    updateMany?: InviteUpdateManyWithWhereWithoutSentByInput | InviteUpdateManyWithWhereWithoutSentByInput[]
    deleteMany?: InviteScalarWhereInput | InviteScalarWhereInput[]
  }

  export type MessageReactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageReactionCreateWithoutUserInput, MessageReactionUncheckedCreateWithoutUserInput> | MessageReactionCreateWithoutUserInput[] | MessageReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageReactionCreateOrConnectWithoutUserInput | MessageReactionCreateOrConnectWithoutUserInput[]
    upsert?: MessageReactionUpsertWithWhereUniqueWithoutUserInput | MessageReactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageReactionCreateManyUserInputEnvelope
    set?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    disconnect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    delete?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    connect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    update?: MessageReactionUpdateWithWhereUniqueWithoutUserInput | MessageReactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageReactionUpdateManyWithWhereWithoutUserInput | MessageReactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageReactionScalarWhereInput | MessageReactionScalarWhereInput[]
  }

  export type MessageReadReceiptUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageReadReceiptCreateWithoutUserInput, MessageReadReceiptUncheckedCreateWithoutUserInput> | MessageReadReceiptCreateWithoutUserInput[] | MessageReadReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageReadReceiptCreateOrConnectWithoutUserInput | MessageReadReceiptCreateOrConnectWithoutUserInput[]
    upsert?: MessageReadReceiptUpsertWithWhereUniqueWithoutUserInput | MessageReadReceiptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageReadReceiptCreateManyUserInputEnvelope
    set?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
    disconnect?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
    delete?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
    connect?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
    update?: MessageReadReceiptUpdateWithWhereUniqueWithoutUserInput | MessageReadReceiptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageReadReceiptUpdateManyWithWhereWithoutUserInput | MessageReadReceiptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageReadReceiptScalarWhereInput | MessageReadReceiptScalarWhereInput[]
  }

  export type PushSubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: PushSubscriptionUpsertWithWhereUniqueWithoutUserInput | PushSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    set?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    disconnect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    delete?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    update?: PushSubscriptionUpdateWithWhereUniqueWithoutUserInput | PushSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PushSubscriptionUpdateManyWithWhereWithoutUserInput | PushSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
  }

  export type TripMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TripMemberCreateWithoutUserInput, TripMemberUncheckedCreateWithoutUserInput> | TripMemberCreateWithoutUserInput[] | TripMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TripMemberCreateOrConnectWithoutUserInput | TripMemberCreateOrConnectWithoutUserInput[]
    upsert?: TripMemberUpsertWithWhereUniqueWithoutUserInput | TripMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TripMemberCreateManyUserInputEnvelope
    set?: TripMemberWhereUniqueInput | TripMemberWhereUniqueInput[]
    disconnect?: TripMemberWhereUniqueInput | TripMemberWhereUniqueInput[]
    delete?: TripMemberWhereUniqueInput | TripMemberWhereUniqueInput[]
    connect?: TripMemberWhereUniqueInput | TripMemberWhereUniqueInput[]
    update?: TripMemberUpdateWithWhereUniqueWithoutUserInput | TripMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TripMemberUpdateManyWithWhereWithoutUserInput | TripMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TripMemberScalarWhereInput | TripMemberScalarWhereInput[]
  }

  export type TripUncheckedUpdateManyWithoutTripMasterNestedInput = {
    create?: XOR<TripCreateWithoutTripMasterInput, TripUncheckedCreateWithoutTripMasterInput> | TripCreateWithoutTripMasterInput[] | TripUncheckedCreateWithoutTripMasterInput[]
    connectOrCreate?: TripCreateOrConnectWithoutTripMasterInput | TripCreateOrConnectWithoutTripMasterInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutTripMasterInput | TripUpsertWithWhereUniqueWithoutTripMasterInput[]
    createMany?: TripCreateManyTripMasterInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutTripMasterInput | TripUpdateWithWhereUniqueWithoutTripMasterInput[]
    updateMany?: TripUpdateManyWithWhereWithoutTripMasterInput | TripUpdateManyWithWhereWithoutTripMasterInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutProposerNestedInput = {
    create?: XOR<ActivityCreateWithoutProposerInput, ActivityUncheckedCreateWithoutProposerInput> | ActivityCreateWithoutProposerInput[] | ActivityUncheckedCreateWithoutProposerInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutProposerInput | ActivityCreateOrConnectWithoutProposerInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutProposerInput | ActivityUpsertWithWhereUniqueWithoutProposerInput[]
    createMany?: ActivityCreateManyProposerInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutProposerInput | ActivityUpdateWithWhereUniqueWithoutProposerInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutProposerInput | ActivityUpdateManyWithWhereWithoutProposerInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type VoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VoteCreateWithoutUserInput, VoteUncheckedCreateWithoutUserInput> | VoteCreateWithoutUserInput[] | VoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutUserInput | VoteCreateOrConnectWithoutUserInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutUserInput | VoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VoteCreateManyUserInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutUserInput | VoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutUserInput | VoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type TripMessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TripMessageCreateWithoutUserInput, TripMessageUncheckedCreateWithoutUserInput> | TripMessageCreateWithoutUserInput[] | TripMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TripMessageCreateOrConnectWithoutUserInput | TripMessageCreateOrConnectWithoutUserInput[]
    upsert?: TripMessageUpsertWithWhereUniqueWithoutUserInput | TripMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TripMessageCreateManyUserInputEnvelope
    set?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
    disconnect?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
    delete?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
    connect?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
    update?: TripMessageUpdateWithWhereUniqueWithoutUserInput | TripMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TripMessageUpdateManyWithWhereWithoutUserInput | TripMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TripMessageScalarWhereInput | TripMessageScalarWhereInput[]
  }

  export type MediaItemUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<MediaItemCreateWithoutUploaderInput, MediaItemUncheckedCreateWithoutUploaderInput> | MediaItemCreateWithoutUploaderInput[] | MediaItemUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: MediaItemCreateOrConnectWithoutUploaderInput | MediaItemCreateOrConnectWithoutUploaderInput[]
    upsert?: MediaItemUpsertWithWhereUniqueWithoutUploaderInput | MediaItemUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: MediaItemCreateManyUploaderInputEnvelope
    set?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
    disconnect?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
    delete?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
    connect?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
    update?: MediaItemUpdateWithWhereUniqueWithoutUploaderInput | MediaItemUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: MediaItemUpdateManyWithWhereWithoutUploaderInput | MediaItemUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: MediaItemScalarWhereInput | MediaItemScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type InviteUncheckedUpdateManyWithoutSentByNestedInput = {
    create?: XOR<InviteCreateWithoutSentByInput, InviteUncheckedCreateWithoutSentByInput> | InviteCreateWithoutSentByInput[] | InviteUncheckedCreateWithoutSentByInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutSentByInput | InviteCreateOrConnectWithoutSentByInput[]
    upsert?: InviteUpsertWithWhereUniqueWithoutSentByInput | InviteUpsertWithWhereUniqueWithoutSentByInput[]
    createMany?: InviteCreateManySentByInputEnvelope
    set?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    disconnect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    delete?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    update?: InviteUpdateWithWhereUniqueWithoutSentByInput | InviteUpdateWithWhereUniqueWithoutSentByInput[]
    updateMany?: InviteUpdateManyWithWhereWithoutSentByInput | InviteUpdateManyWithWhereWithoutSentByInput[]
    deleteMany?: InviteScalarWhereInput | InviteScalarWhereInput[]
  }

  export type MessageReactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageReactionCreateWithoutUserInput, MessageReactionUncheckedCreateWithoutUserInput> | MessageReactionCreateWithoutUserInput[] | MessageReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageReactionCreateOrConnectWithoutUserInput | MessageReactionCreateOrConnectWithoutUserInput[]
    upsert?: MessageReactionUpsertWithWhereUniqueWithoutUserInput | MessageReactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageReactionCreateManyUserInputEnvelope
    set?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    disconnect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    delete?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    connect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    update?: MessageReactionUpdateWithWhereUniqueWithoutUserInput | MessageReactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageReactionUpdateManyWithWhereWithoutUserInput | MessageReactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageReactionScalarWhereInput | MessageReactionScalarWhereInput[]
  }

  export type MessageReadReceiptUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageReadReceiptCreateWithoutUserInput, MessageReadReceiptUncheckedCreateWithoutUserInput> | MessageReadReceiptCreateWithoutUserInput[] | MessageReadReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageReadReceiptCreateOrConnectWithoutUserInput | MessageReadReceiptCreateOrConnectWithoutUserInput[]
    upsert?: MessageReadReceiptUpsertWithWhereUniqueWithoutUserInput | MessageReadReceiptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageReadReceiptCreateManyUserInputEnvelope
    set?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
    disconnect?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
    delete?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
    connect?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
    update?: MessageReadReceiptUpdateWithWhereUniqueWithoutUserInput | MessageReadReceiptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageReadReceiptUpdateManyWithWhereWithoutUserInput | MessageReadReceiptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageReadReceiptScalarWhereInput | MessageReadReceiptScalarWhereInput[]
  }

  export type PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: PushSubscriptionUpsertWithWhereUniqueWithoutUserInput | PushSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    set?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    disconnect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    delete?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    update?: PushSubscriptionUpdateWithWhereUniqueWithoutUserInput | PushSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PushSubscriptionUpdateManyWithWhereWithoutUserInput | PushSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCreatedTripsInput = {
    create?: XOR<UserCreateWithoutCreatedTripsInput, UserUncheckedCreateWithoutCreatedTripsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTripsInput
    connect?: UserWhereUniqueInput
  }

  export type TripMemberCreateNestedManyWithoutTripInput = {
    create?: XOR<TripMemberCreateWithoutTripInput, TripMemberUncheckedCreateWithoutTripInput> | TripMemberCreateWithoutTripInput[] | TripMemberUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripMemberCreateOrConnectWithoutTripInput | TripMemberCreateOrConnectWithoutTripInput[]
    createMany?: TripMemberCreateManyTripInputEnvelope
    connect?: TripMemberWhereUniqueInput | TripMemberWhereUniqueInput[]
  }

  export type InviteCreateNestedManyWithoutTripInput = {
    create?: XOR<InviteCreateWithoutTripInput, InviteUncheckedCreateWithoutTripInput> | InviteCreateWithoutTripInput[] | InviteUncheckedCreateWithoutTripInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutTripInput | InviteCreateOrConnectWithoutTripInput[]
    createMany?: InviteCreateManyTripInputEnvelope
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutTripInput = {
    create?: XOR<ActivityCreateWithoutTripInput, ActivityUncheckedCreateWithoutTripInput> | ActivityCreateWithoutTripInput[] | ActivityUncheckedCreateWithoutTripInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutTripInput | ActivityCreateOrConnectWithoutTripInput[]
    createMany?: ActivityCreateManyTripInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutTripInput = {
    create?: XOR<BookingCreateWithoutTripInput, BookingUncheckedCreateWithoutTripInput> | BookingCreateWithoutTripInput[] | BookingUncheckedCreateWithoutTripInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTripInput | BookingCreateOrConnectWithoutTripInput[]
    createMany?: BookingCreateManyTripInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type TripMessageCreateNestedManyWithoutTripInput = {
    create?: XOR<TripMessageCreateWithoutTripInput, TripMessageUncheckedCreateWithoutTripInput> | TripMessageCreateWithoutTripInput[] | TripMessageUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripMessageCreateOrConnectWithoutTripInput | TripMessageCreateOrConnectWithoutTripInput[]
    createMany?: TripMessageCreateManyTripInputEnvelope
    connect?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
  }

  export type MediaItemCreateNestedManyWithoutTripInput = {
    create?: XOR<MediaItemCreateWithoutTripInput, MediaItemUncheckedCreateWithoutTripInput> | MediaItemCreateWithoutTripInput[] | MediaItemUncheckedCreateWithoutTripInput[]
    connectOrCreate?: MediaItemCreateOrConnectWithoutTripInput | MediaItemCreateOrConnectWithoutTripInput[]
    createMany?: MediaItemCreateManyTripInputEnvelope
    connect?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutTripInput = {
    create?: XOR<NotificationCreateWithoutTripInput, NotificationUncheckedCreateWithoutTripInput> | NotificationCreateWithoutTripInput[] | NotificationUncheckedCreateWithoutTripInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTripInput | NotificationCreateOrConnectWithoutTripInput[]
    createMany?: NotificationCreateManyTripInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type TripMemberUncheckedCreateNestedManyWithoutTripInput = {
    create?: XOR<TripMemberCreateWithoutTripInput, TripMemberUncheckedCreateWithoutTripInput> | TripMemberCreateWithoutTripInput[] | TripMemberUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripMemberCreateOrConnectWithoutTripInput | TripMemberCreateOrConnectWithoutTripInput[]
    createMany?: TripMemberCreateManyTripInputEnvelope
    connect?: TripMemberWhereUniqueInput | TripMemberWhereUniqueInput[]
  }

  export type InviteUncheckedCreateNestedManyWithoutTripInput = {
    create?: XOR<InviteCreateWithoutTripInput, InviteUncheckedCreateWithoutTripInput> | InviteCreateWithoutTripInput[] | InviteUncheckedCreateWithoutTripInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutTripInput | InviteCreateOrConnectWithoutTripInput[]
    createMany?: InviteCreateManyTripInputEnvelope
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutTripInput = {
    create?: XOR<ActivityCreateWithoutTripInput, ActivityUncheckedCreateWithoutTripInput> | ActivityCreateWithoutTripInput[] | ActivityUncheckedCreateWithoutTripInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutTripInput | ActivityCreateOrConnectWithoutTripInput[]
    createMany?: ActivityCreateManyTripInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutTripInput = {
    create?: XOR<BookingCreateWithoutTripInput, BookingUncheckedCreateWithoutTripInput> | BookingCreateWithoutTripInput[] | BookingUncheckedCreateWithoutTripInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTripInput | BookingCreateOrConnectWithoutTripInput[]
    createMany?: BookingCreateManyTripInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type TripMessageUncheckedCreateNestedManyWithoutTripInput = {
    create?: XOR<TripMessageCreateWithoutTripInput, TripMessageUncheckedCreateWithoutTripInput> | TripMessageCreateWithoutTripInput[] | TripMessageUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripMessageCreateOrConnectWithoutTripInput | TripMessageCreateOrConnectWithoutTripInput[]
    createMany?: TripMessageCreateManyTripInputEnvelope
    connect?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
  }

  export type MediaItemUncheckedCreateNestedManyWithoutTripInput = {
    create?: XOR<MediaItemCreateWithoutTripInput, MediaItemUncheckedCreateWithoutTripInput> | MediaItemCreateWithoutTripInput[] | MediaItemUncheckedCreateWithoutTripInput[]
    connectOrCreate?: MediaItemCreateOrConnectWithoutTripInput | MediaItemCreateOrConnectWithoutTripInput[]
    createMany?: MediaItemCreateManyTripInputEnvelope
    connect?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutTripInput = {
    create?: XOR<NotificationCreateWithoutTripInput, NotificationUncheckedCreateWithoutTripInput> | NotificationCreateWithoutTripInput[] | NotificationUncheckedCreateWithoutTripInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTripInput | NotificationCreateOrConnectWithoutTripInput[]
    createMany?: NotificationCreateManyTripInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumTripStatusFieldUpdateOperationsInput = {
    set?: $Enums.TripStatus
  }

  export type UserUpdateOneRequiredWithoutCreatedTripsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedTripsInput, UserUncheckedCreateWithoutCreatedTripsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTripsInput
    upsert?: UserUpsertWithoutCreatedTripsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedTripsInput, UserUpdateWithoutCreatedTripsInput>, UserUncheckedUpdateWithoutCreatedTripsInput>
  }

  export type TripMemberUpdateManyWithoutTripNestedInput = {
    create?: XOR<TripMemberCreateWithoutTripInput, TripMemberUncheckedCreateWithoutTripInput> | TripMemberCreateWithoutTripInput[] | TripMemberUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripMemberCreateOrConnectWithoutTripInput | TripMemberCreateOrConnectWithoutTripInput[]
    upsert?: TripMemberUpsertWithWhereUniqueWithoutTripInput | TripMemberUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: TripMemberCreateManyTripInputEnvelope
    set?: TripMemberWhereUniqueInput | TripMemberWhereUniqueInput[]
    disconnect?: TripMemberWhereUniqueInput | TripMemberWhereUniqueInput[]
    delete?: TripMemberWhereUniqueInput | TripMemberWhereUniqueInput[]
    connect?: TripMemberWhereUniqueInput | TripMemberWhereUniqueInput[]
    update?: TripMemberUpdateWithWhereUniqueWithoutTripInput | TripMemberUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: TripMemberUpdateManyWithWhereWithoutTripInput | TripMemberUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: TripMemberScalarWhereInput | TripMemberScalarWhereInput[]
  }

  export type InviteUpdateManyWithoutTripNestedInput = {
    create?: XOR<InviteCreateWithoutTripInput, InviteUncheckedCreateWithoutTripInput> | InviteCreateWithoutTripInput[] | InviteUncheckedCreateWithoutTripInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutTripInput | InviteCreateOrConnectWithoutTripInput[]
    upsert?: InviteUpsertWithWhereUniqueWithoutTripInput | InviteUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: InviteCreateManyTripInputEnvelope
    set?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    disconnect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    delete?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    update?: InviteUpdateWithWhereUniqueWithoutTripInput | InviteUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: InviteUpdateManyWithWhereWithoutTripInput | InviteUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: InviteScalarWhereInput | InviteScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutTripNestedInput = {
    create?: XOR<ActivityCreateWithoutTripInput, ActivityUncheckedCreateWithoutTripInput> | ActivityCreateWithoutTripInput[] | ActivityUncheckedCreateWithoutTripInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutTripInput | ActivityCreateOrConnectWithoutTripInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutTripInput | ActivityUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: ActivityCreateManyTripInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutTripInput | ActivityUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutTripInput | ActivityUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutTripNestedInput = {
    create?: XOR<BookingCreateWithoutTripInput, BookingUncheckedCreateWithoutTripInput> | BookingCreateWithoutTripInput[] | BookingUncheckedCreateWithoutTripInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTripInput | BookingCreateOrConnectWithoutTripInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutTripInput | BookingUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: BookingCreateManyTripInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutTripInput | BookingUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutTripInput | BookingUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type TripMessageUpdateManyWithoutTripNestedInput = {
    create?: XOR<TripMessageCreateWithoutTripInput, TripMessageUncheckedCreateWithoutTripInput> | TripMessageCreateWithoutTripInput[] | TripMessageUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripMessageCreateOrConnectWithoutTripInput | TripMessageCreateOrConnectWithoutTripInput[]
    upsert?: TripMessageUpsertWithWhereUniqueWithoutTripInput | TripMessageUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: TripMessageCreateManyTripInputEnvelope
    set?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
    disconnect?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
    delete?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
    connect?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
    update?: TripMessageUpdateWithWhereUniqueWithoutTripInput | TripMessageUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: TripMessageUpdateManyWithWhereWithoutTripInput | TripMessageUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: TripMessageScalarWhereInput | TripMessageScalarWhereInput[]
  }

  export type MediaItemUpdateManyWithoutTripNestedInput = {
    create?: XOR<MediaItemCreateWithoutTripInput, MediaItemUncheckedCreateWithoutTripInput> | MediaItemCreateWithoutTripInput[] | MediaItemUncheckedCreateWithoutTripInput[]
    connectOrCreate?: MediaItemCreateOrConnectWithoutTripInput | MediaItemCreateOrConnectWithoutTripInput[]
    upsert?: MediaItemUpsertWithWhereUniqueWithoutTripInput | MediaItemUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: MediaItemCreateManyTripInputEnvelope
    set?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
    disconnect?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
    delete?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
    connect?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
    update?: MediaItemUpdateWithWhereUniqueWithoutTripInput | MediaItemUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: MediaItemUpdateManyWithWhereWithoutTripInput | MediaItemUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: MediaItemScalarWhereInput | MediaItemScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutTripNestedInput = {
    create?: XOR<NotificationCreateWithoutTripInput, NotificationUncheckedCreateWithoutTripInput> | NotificationCreateWithoutTripInput[] | NotificationUncheckedCreateWithoutTripInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTripInput | NotificationCreateOrConnectWithoutTripInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTripInput | NotificationUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: NotificationCreateManyTripInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTripInput | NotificationUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTripInput | NotificationUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type TripMemberUncheckedUpdateManyWithoutTripNestedInput = {
    create?: XOR<TripMemberCreateWithoutTripInput, TripMemberUncheckedCreateWithoutTripInput> | TripMemberCreateWithoutTripInput[] | TripMemberUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripMemberCreateOrConnectWithoutTripInput | TripMemberCreateOrConnectWithoutTripInput[]
    upsert?: TripMemberUpsertWithWhereUniqueWithoutTripInput | TripMemberUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: TripMemberCreateManyTripInputEnvelope
    set?: TripMemberWhereUniqueInput | TripMemberWhereUniqueInput[]
    disconnect?: TripMemberWhereUniqueInput | TripMemberWhereUniqueInput[]
    delete?: TripMemberWhereUniqueInput | TripMemberWhereUniqueInput[]
    connect?: TripMemberWhereUniqueInput | TripMemberWhereUniqueInput[]
    update?: TripMemberUpdateWithWhereUniqueWithoutTripInput | TripMemberUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: TripMemberUpdateManyWithWhereWithoutTripInput | TripMemberUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: TripMemberScalarWhereInput | TripMemberScalarWhereInput[]
  }

  export type InviteUncheckedUpdateManyWithoutTripNestedInput = {
    create?: XOR<InviteCreateWithoutTripInput, InviteUncheckedCreateWithoutTripInput> | InviteCreateWithoutTripInput[] | InviteUncheckedCreateWithoutTripInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutTripInput | InviteCreateOrConnectWithoutTripInput[]
    upsert?: InviteUpsertWithWhereUniqueWithoutTripInput | InviteUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: InviteCreateManyTripInputEnvelope
    set?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    disconnect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    delete?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    update?: InviteUpdateWithWhereUniqueWithoutTripInput | InviteUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: InviteUpdateManyWithWhereWithoutTripInput | InviteUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: InviteScalarWhereInput | InviteScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutTripNestedInput = {
    create?: XOR<ActivityCreateWithoutTripInput, ActivityUncheckedCreateWithoutTripInput> | ActivityCreateWithoutTripInput[] | ActivityUncheckedCreateWithoutTripInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutTripInput | ActivityCreateOrConnectWithoutTripInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutTripInput | ActivityUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: ActivityCreateManyTripInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutTripInput | ActivityUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutTripInput | ActivityUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutTripNestedInput = {
    create?: XOR<BookingCreateWithoutTripInput, BookingUncheckedCreateWithoutTripInput> | BookingCreateWithoutTripInput[] | BookingUncheckedCreateWithoutTripInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTripInput | BookingCreateOrConnectWithoutTripInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutTripInput | BookingUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: BookingCreateManyTripInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutTripInput | BookingUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutTripInput | BookingUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type TripMessageUncheckedUpdateManyWithoutTripNestedInput = {
    create?: XOR<TripMessageCreateWithoutTripInput, TripMessageUncheckedCreateWithoutTripInput> | TripMessageCreateWithoutTripInput[] | TripMessageUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripMessageCreateOrConnectWithoutTripInput | TripMessageCreateOrConnectWithoutTripInput[]
    upsert?: TripMessageUpsertWithWhereUniqueWithoutTripInput | TripMessageUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: TripMessageCreateManyTripInputEnvelope
    set?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
    disconnect?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
    delete?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
    connect?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
    update?: TripMessageUpdateWithWhereUniqueWithoutTripInput | TripMessageUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: TripMessageUpdateManyWithWhereWithoutTripInput | TripMessageUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: TripMessageScalarWhereInput | TripMessageScalarWhereInput[]
  }

  export type MediaItemUncheckedUpdateManyWithoutTripNestedInput = {
    create?: XOR<MediaItemCreateWithoutTripInput, MediaItemUncheckedCreateWithoutTripInput> | MediaItemCreateWithoutTripInput[] | MediaItemUncheckedCreateWithoutTripInput[]
    connectOrCreate?: MediaItemCreateOrConnectWithoutTripInput | MediaItemCreateOrConnectWithoutTripInput[]
    upsert?: MediaItemUpsertWithWhereUniqueWithoutTripInput | MediaItemUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: MediaItemCreateManyTripInputEnvelope
    set?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
    disconnect?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
    delete?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
    connect?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
    update?: MediaItemUpdateWithWhereUniqueWithoutTripInput | MediaItemUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: MediaItemUpdateManyWithWhereWithoutTripInput | MediaItemUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: MediaItemScalarWhereInput | MediaItemScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutTripNestedInput = {
    create?: XOR<NotificationCreateWithoutTripInput, NotificationUncheckedCreateWithoutTripInput> | NotificationCreateWithoutTripInput[] | NotificationUncheckedCreateWithoutTripInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTripInput | NotificationCreateOrConnectWithoutTripInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTripInput | NotificationUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: NotificationCreateManyTripInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTripInput | NotificationUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTripInput | NotificationUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type TripCreateNestedOneWithoutMembersInput = {
    create?: XOR<TripCreateWithoutMembersInput, TripUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TripCreateOrConnectWithoutMembersInput
    connect?: TripWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumMemberRoleFieldUpdateOperationsInput = {
    set?: $Enums.MemberRole
  }

  export type EnumMemberStatusFieldUpdateOperationsInput = {
    set?: $Enums.MemberStatus
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type TripUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<TripCreateWithoutMembersInput, TripUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TripCreateOrConnectWithoutMembersInput
    upsert?: TripUpsertWithoutMembersInput
    connect?: TripWhereUniqueInput
    update?: XOR<XOR<TripUpdateToOneWithWhereWithoutMembersInput, TripUpdateWithoutMembersInput>, TripUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput
    upsert?: UserUpsertWithoutMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMembershipsInput, UserUpdateWithoutMembershipsInput>, UserUncheckedUpdateWithoutMembershipsInput>
  }

  export type TripCreateNestedOneWithoutInvitesInput = {
    create?: XOR<TripCreateWithoutInvitesInput, TripUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: TripCreateOrConnectWithoutInvitesInput
    connect?: TripWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentInvitesInput = {
    create?: XOR<UserCreateWithoutSentInvitesInput, UserUncheckedCreateWithoutSentInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentInvitesInput
    connect?: UserWhereUniqueInput
  }

  export type InviteChannelCreateNestedManyWithoutInviteInput = {
    create?: XOR<InviteChannelCreateWithoutInviteInput, InviteChannelUncheckedCreateWithoutInviteInput> | InviteChannelCreateWithoutInviteInput[] | InviteChannelUncheckedCreateWithoutInviteInput[]
    connectOrCreate?: InviteChannelCreateOrConnectWithoutInviteInput | InviteChannelCreateOrConnectWithoutInviteInput[]
    createMany?: InviteChannelCreateManyInviteInputEnvelope
    connect?: InviteChannelWhereUniqueInput | InviteChannelWhereUniqueInput[]
  }

  export type InviteChannelUncheckedCreateNestedManyWithoutInviteInput = {
    create?: XOR<InviteChannelCreateWithoutInviteInput, InviteChannelUncheckedCreateWithoutInviteInput> | InviteChannelCreateWithoutInviteInput[] | InviteChannelUncheckedCreateWithoutInviteInput[]
    connectOrCreate?: InviteChannelCreateOrConnectWithoutInviteInput | InviteChannelCreateOrConnectWithoutInviteInput[]
    createMany?: InviteChannelCreateManyInviteInputEnvelope
    connect?: InviteChannelWhereUniqueInput | InviteChannelWhereUniqueInput[]
  }

  export type EnumInviteStatusFieldUpdateOperationsInput = {
    set?: $Enums.InviteStatus
  }

  export type TripUpdateOneRequiredWithoutInvitesNestedInput = {
    create?: XOR<TripCreateWithoutInvitesInput, TripUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: TripCreateOrConnectWithoutInvitesInput
    upsert?: TripUpsertWithoutInvitesInput
    connect?: TripWhereUniqueInput
    update?: XOR<XOR<TripUpdateToOneWithWhereWithoutInvitesInput, TripUpdateWithoutInvitesInput>, TripUncheckedUpdateWithoutInvitesInput>
  }

  export type UserUpdateOneRequiredWithoutSentInvitesNestedInput = {
    create?: XOR<UserCreateWithoutSentInvitesInput, UserUncheckedCreateWithoutSentInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentInvitesInput
    upsert?: UserUpsertWithoutSentInvitesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentInvitesInput, UserUpdateWithoutSentInvitesInput>, UserUncheckedUpdateWithoutSentInvitesInput>
  }

  export type InviteChannelUpdateManyWithoutInviteNestedInput = {
    create?: XOR<InviteChannelCreateWithoutInviteInput, InviteChannelUncheckedCreateWithoutInviteInput> | InviteChannelCreateWithoutInviteInput[] | InviteChannelUncheckedCreateWithoutInviteInput[]
    connectOrCreate?: InviteChannelCreateOrConnectWithoutInviteInput | InviteChannelCreateOrConnectWithoutInviteInput[]
    upsert?: InviteChannelUpsertWithWhereUniqueWithoutInviteInput | InviteChannelUpsertWithWhereUniqueWithoutInviteInput[]
    createMany?: InviteChannelCreateManyInviteInputEnvelope
    set?: InviteChannelWhereUniqueInput | InviteChannelWhereUniqueInput[]
    disconnect?: InviteChannelWhereUniqueInput | InviteChannelWhereUniqueInput[]
    delete?: InviteChannelWhereUniqueInput | InviteChannelWhereUniqueInput[]
    connect?: InviteChannelWhereUniqueInput | InviteChannelWhereUniqueInput[]
    update?: InviteChannelUpdateWithWhereUniqueWithoutInviteInput | InviteChannelUpdateWithWhereUniqueWithoutInviteInput[]
    updateMany?: InviteChannelUpdateManyWithWhereWithoutInviteInput | InviteChannelUpdateManyWithWhereWithoutInviteInput[]
    deleteMany?: InviteChannelScalarWhereInput | InviteChannelScalarWhereInput[]
  }

  export type InviteChannelUncheckedUpdateManyWithoutInviteNestedInput = {
    create?: XOR<InviteChannelCreateWithoutInviteInput, InviteChannelUncheckedCreateWithoutInviteInput> | InviteChannelCreateWithoutInviteInput[] | InviteChannelUncheckedCreateWithoutInviteInput[]
    connectOrCreate?: InviteChannelCreateOrConnectWithoutInviteInput | InviteChannelCreateOrConnectWithoutInviteInput[]
    upsert?: InviteChannelUpsertWithWhereUniqueWithoutInviteInput | InviteChannelUpsertWithWhereUniqueWithoutInviteInput[]
    createMany?: InviteChannelCreateManyInviteInputEnvelope
    set?: InviteChannelWhereUniqueInput | InviteChannelWhereUniqueInput[]
    disconnect?: InviteChannelWhereUniqueInput | InviteChannelWhereUniqueInput[]
    delete?: InviteChannelWhereUniqueInput | InviteChannelWhereUniqueInput[]
    connect?: InviteChannelWhereUniqueInput | InviteChannelWhereUniqueInput[]
    update?: InviteChannelUpdateWithWhereUniqueWithoutInviteInput | InviteChannelUpdateWithWhereUniqueWithoutInviteInput[]
    updateMany?: InviteChannelUpdateManyWithWhereWithoutInviteInput | InviteChannelUpdateManyWithWhereWithoutInviteInput[]
    deleteMany?: InviteChannelScalarWhereInput | InviteChannelScalarWhereInput[]
  }

  export type InviteCreateNestedOneWithoutChannelsInput = {
    create?: XOR<InviteCreateWithoutChannelsInput, InviteUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: InviteCreateOrConnectWithoutChannelsInput
    connect?: InviteWhereUniqueInput
  }

  export type InviteUpdateOneRequiredWithoutChannelsNestedInput = {
    create?: XOR<InviteCreateWithoutChannelsInput, InviteUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: InviteCreateOrConnectWithoutChannelsInput
    upsert?: InviteUpsertWithoutChannelsInput
    connect?: InviteWhereUniqueInput
    update?: XOR<XOR<InviteUpdateToOneWithWhereWithoutChannelsInput, InviteUpdateWithoutChannelsInput>, InviteUncheckedUpdateWithoutChannelsInput>
  }

  export type TripCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<TripCreateWithoutActivitiesInput, TripUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: TripCreateOrConnectWithoutActivitiesInput
    connect?: TripWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type VoteCreateNestedManyWithoutActivityInput = {
    create?: XOR<VoteCreateWithoutActivityInput, VoteUncheckedCreateWithoutActivityInput> | VoteCreateWithoutActivityInput[] | VoteUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutActivityInput | VoteCreateOrConnectWithoutActivityInput[]
    createMany?: VoteCreateManyActivityInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutActivityInput = {
    create?: XOR<BookingCreateWithoutActivityInput, BookingUncheckedCreateWithoutActivityInput> | BookingCreateWithoutActivityInput[] | BookingUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutActivityInput | BookingCreateOrConnectWithoutActivityInput[]
    createMany?: BookingCreateManyActivityInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type MediaItemCreateNestedManyWithoutActivityInput = {
    create?: XOR<MediaItemCreateWithoutActivityInput, MediaItemUncheckedCreateWithoutActivityInput> | MediaItemCreateWithoutActivityInput[] | MediaItemUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: MediaItemCreateOrConnectWithoutActivityInput | MediaItemCreateOrConnectWithoutActivityInput[]
    createMany?: MediaItemCreateManyActivityInputEnvelope
    connect?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
  }

  export type VoteUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<VoteCreateWithoutActivityInput, VoteUncheckedCreateWithoutActivityInput> | VoteCreateWithoutActivityInput[] | VoteUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutActivityInput | VoteCreateOrConnectWithoutActivityInput[]
    createMany?: VoteCreateManyActivityInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<BookingCreateWithoutActivityInput, BookingUncheckedCreateWithoutActivityInput> | BookingCreateWithoutActivityInput[] | BookingUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutActivityInput | BookingCreateOrConnectWithoutActivityInput[]
    createMany?: BookingCreateManyActivityInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type MediaItemUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<MediaItemCreateWithoutActivityInput, MediaItemUncheckedCreateWithoutActivityInput> | MediaItemCreateWithoutActivityInput[] | MediaItemUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: MediaItemCreateOrConnectWithoutActivityInput | MediaItemCreateOrConnectWithoutActivityInput[]
    createMany?: MediaItemCreateManyActivityInputEnvelope
    connect?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
  }

  export type TripUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<TripCreateWithoutActivitiesInput, TripUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: TripCreateOrConnectWithoutActivitiesInput
    upsert?: TripUpsertWithoutActivitiesInput
    connect?: TripWhereUniqueInput
    update?: XOR<XOR<TripUpdateToOneWithWhereWithoutActivitiesInput, TripUpdateWithoutActivitiesInput>, TripUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    upsert?: UserUpsertWithoutActivitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivitiesInput, UserUpdateWithoutActivitiesInput>, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type VoteUpdateManyWithoutActivityNestedInput = {
    create?: XOR<VoteCreateWithoutActivityInput, VoteUncheckedCreateWithoutActivityInput> | VoteCreateWithoutActivityInput[] | VoteUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutActivityInput | VoteCreateOrConnectWithoutActivityInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutActivityInput | VoteUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: VoteCreateManyActivityInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutActivityInput | VoteUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutActivityInput | VoteUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutActivityNestedInput = {
    create?: XOR<BookingCreateWithoutActivityInput, BookingUncheckedCreateWithoutActivityInput> | BookingCreateWithoutActivityInput[] | BookingUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutActivityInput | BookingCreateOrConnectWithoutActivityInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutActivityInput | BookingUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: BookingCreateManyActivityInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutActivityInput | BookingUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutActivityInput | BookingUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type MediaItemUpdateManyWithoutActivityNestedInput = {
    create?: XOR<MediaItemCreateWithoutActivityInput, MediaItemUncheckedCreateWithoutActivityInput> | MediaItemCreateWithoutActivityInput[] | MediaItemUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: MediaItemCreateOrConnectWithoutActivityInput | MediaItemCreateOrConnectWithoutActivityInput[]
    upsert?: MediaItemUpsertWithWhereUniqueWithoutActivityInput | MediaItemUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: MediaItemCreateManyActivityInputEnvelope
    set?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
    disconnect?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
    delete?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
    connect?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
    update?: MediaItemUpdateWithWhereUniqueWithoutActivityInput | MediaItemUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: MediaItemUpdateManyWithWhereWithoutActivityInput | MediaItemUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: MediaItemScalarWhereInput | MediaItemScalarWhereInput[]
  }

  export type VoteUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<VoteCreateWithoutActivityInput, VoteUncheckedCreateWithoutActivityInput> | VoteCreateWithoutActivityInput[] | VoteUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutActivityInput | VoteCreateOrConnectWithoutActivityInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutActivityInput | VoteUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: VoteCreateManyActivityInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutActivityInput | VoteUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutActivityInput | VoteUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<BookingCreateWithoutActivityInput, BookingUncheckedCreateWithoutActivityInput> | BookingCreateWithoutActivityInput[] | BookingUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutActivityInput | BookingCreateOrConnectWithoutActivityInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutActivityInput | BookingUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: BookingCreateManyActivityInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutActivityInput | BookingUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutActivityInput | BookingUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type MediaItemUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<MediaItemCreateWithoutActivityInput, MediaItemUncheckedCreateWithoutActivityInput> | MediaItemCreateWithoutActivityInput[] | MediaItemUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: MediaItemCreateOrConnectWithoutActivityInput | MediaItemCreateOrConnectWithoutActivityInput[]
    upsert?: MediaItemUpsertWithWhereUniqueWithoutActivityInput | MediaItemUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: MediaItemCreateManyActivityInputEnvelope
    set?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
    disconnect?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
    delete?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
    connect?: MediaItemWhereUniqueInput | MediaItemWhereUniqueInput[]
    update?: MediaItemUpdateWithWhereUniqueWithoutActivityInput | MediaItemUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: MediaItemUpdateManyWithWhereWithoutActivityInput | MediaItemUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: MediaItemScalarWhereInput | MediaItemScalarWhereInput[]
  }

  export type ActivityCreateNestedOneWithoutVotesInput = {
    create?: XOR<ActivityCreateWithoutVotesInput, ActivityUncheckedCreateWithoutVotesInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutVotesInput
    connect?: ActivityWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVotesInput = {
    create?: XOR<UserCreateWithoutVotesInput, UserUncheckedCreateWithoutVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVotesInput
    connect?: UserWhereUniqueInput
  }

  export type ActivityUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<ActivityCreateWithoutVotesInput, ActivityUncheckedCreateWithoutVotesInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutVotesInput
    upsert?: ActivityUpsertWithoutVotesInput
    connect?: ActivityWhereUniqueInput
    update?: XOR<XOR<ActivityUpdateToOneWithWhereWithoutVotesInput, ActivityUpdateWithoutVotesInput>, ActivityUncheckedUpdateWithoutVotesInput>
  }

  export type UserUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<UserCreateWithoutVotesInput, UserUncheckedCreateWithoutVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVotesInput
    upsert?: UserUpsertWithoutVotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVotesInput, UserUpdateWithoutVotesInput>, UserUncheckedUpdateWithoutVotesInput>
  }

  export type TripCreateNestedOneWithoutBookingsInput = {
    create?: XOR<TripCreateWithoutBookingsInput, TripUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: TripCreateOrConnectWithoutBookingsInput
    connect?: TripWhereUniqueInput
  }

  export type ActivityCreateNestedOneWithoutBookingsInput = {
    create?: XOR<ActivityCreateWithoutBookingsInput, ActivityUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutBookingsInput
    connect?: ActivityWhereUniqueInput
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type TripUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<TripCreateWithoutBookingsInput, TripUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: TripCreateOrConnectWithoutBookingsInput
    upsert?: TripUpsertWithoutBookingsInput
    connect?: TripWhereUniqueInput
    update?: XOR<XOR<TripUpdateToOneWithWhereWithoutBookingsInput, TripUpdateWithoutBookingsInput>, TripUncheckedUpdateWithoutBookingsInput>
  }

  export type ActivityUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<ActivityCreateWithoutBookingsInput, ActivityUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutBookingsInput
    upsert?: ActivityUpsertWithoutBookingsInput
    disconnect?: ActivityWhereInput | boolean
    delete?: ActivityWhereInput | boolean
    connect?: ActivityWhereUniqueInput
    update?: XOR<XOR<ActivityUpdateToOneWithWhereWithoutBookingsInput, ActivityUpdateWithoutBookingsInput>, ActivityUncheckedUpdateWithoutBookingsInput>
  }

  export type TripCreateNestedOneWithoutMessagesInput = {
    create?: XOR<TripCreateWithoutMessagesInput, TripUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: TripCreateOrConnectWithoutMessagesInput
    connect?: TripWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessagesInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type TripMessageCreateNestedOneWithoutEditsInput = {
    create?: XOR<TripMessageCreateWithoutEditsInput, TripMessageUncheckedCreateWithoutEditsInput>
    connectOrCreate?: TripMessageCreateOrConnectWithoutEditsInput
    connect?: TripMessageWhereUniqueInput
  }

  export type TripMessageCreateNestedManyWithoutParentInput = {
    create?: XOR<TripMessageCreateWithoutParentInput, TripMessageUncheckedCreateWithoutParentInput> | TripMessageCreateWithoutParentInput[] | TripMessageUncheckedCreateWithoutParentInput[]
    connectOrCreate?: TripMessageCreateOrConnectWithoutParentInput | TripMessageCreateOrConnectWithoutParentInput[]
    createMany?: TripMessageCreateManyParentInputEnvelope
    connect?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
  }

  export type MessageReactionCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageReactionCreateWithoutMessageInput, MessageReactionUncheckedCreateWithoutMessageInput> | MessageReactionCreateWithoutMessageInput[] | MessageReactionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReactionCreateOrConnectWithoutMessageInput | MessageReactionCreateOrConnectWithoutMessageInput[]
    createMany?: MessageReactionCreateManyMessageInputEnvelope
    connect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
  }

  export type MessageReadReceiptCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageReadReceiptCreateWithoutMessageInput, MessageReadReceiptUncheckedCreateWithoutMessageInput> | MessageReadReceiptCreateWithoutMessageInput[] | MessageReadReceiptUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReadReceiptCreateOrConnectWithoutMessageInput | MessageReadReceiptCreateOrConnectWithoutMessageInput[]
    createMany?: MessageReadReceiptCreateManyMessageInputEnvelope
    connect?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
  }

  export type TripMessageUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<TripMessageCreateWithoutParentInput, TripMessageUncheckedCreateWithoutParentInput> | TripMessageCreateWithoutParentInput[] | TripMessageUncheckedCreateWithoutParentInput[]
    connectOrCreate?: TripMessageCreateOrConnectWithoutParentInput | TripMessageCreateOrConnectWithoutParentInput[]
    createMany?: TripMessageCreateManyParentInputEnvelope
    connect?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
  }

  export type MessageReactionUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageReactionCreateWithoutMessageInput, MessageReactionUncheckedCreateWithoutMessageInput> | MessageReactionCreateWithoutMessageInput[] | MessageReactionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReactionCreateOrConnectWithoutMessageInput | MessageReactionCreateOrConnectWithoutMessageInput[]
    createMany?: MessageReactionCreateManyMessageInputEnvelope
    connect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
  }

  export type MessageReadReceiptUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageReadReceiptCreateWithoutMessageInput, MessageReadReceiptUncheckedCreateWithoutMessageInput> | MessageReadReceiptCreateWithoutMessageInput[] | MessageReadReceiptUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReadReceiptCreateOrConnectWithoutMessageInput | MessageReadReceiptCreateOrConnectWithoutMessageInput[]
    createMany?: MessageReadReceiptCreateManyMessageInputEnvelope
    connect?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
  }

  export type EnumMessageTypeFieldUpdateOperationsInput = {
    set?: $Enums.MessageType
  }

  export type TripUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<TripCreateWithoutMessagesInput, TripUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: TripCreateOrConnectWithoutMessagesInput
    upsert?: TripUpsertWithoutMessagesInput
    connect?: TripWhereUniqueInput
    update?: XOR<XOR<TripUpdateToOneWithWhereWithoutMessagesInput, TripUpdateWithoutMessagesInput>, TripUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    upsert?: UserUpsertWithoutMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesInput, UserUpdateWithoutMessagesInput>, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type TripMessageUpdateOneWithoutEditsNestedInput = {
    create?: XOR<TripMessageCreateWithoutEditsInput, TripMessageUncheckedCreateWithoutEditsInput>
    connectOrCreate?: TripMessageCreateOrConnectWithoutEditsInput
    upsert?: TripMessageUpsertWithoutEditsInput
    disconnect?: TripMessageWhereInput | boolean
    delete?: TripMessageWhereInput | boolean
    connect?: TripMessageWhereUniqueInput
    update?: XOR<XOR<TripMessageUpdateToOneWithWhereWithoutEditsInput, TripMessageUpdateWithoutEditsInput>, TripMessageUncheckedUpdateWithoutEditsInput>
  }

  export type TripMessageUpdateManyWithoutParentNestedInput = {
    create?: XOR<TripMessageCreateWithoutParentInput, TripMessageUncheckedCreateWithoutParentInput> | TripMessageCreateWithoutParentInput[] | TripMessageUncheckedCreateWithoutParentInput[]
    connectOrCreate?: TripMessageCreateOrConnectWithoutParentInput | TripMessageCreateOrConnectWithoutParentInput[]
    upsert?: TripMessageUpsertWithWhereUniqueWithoutParentInput | TripMessageUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: TripMessageCreateManyParentInputEnvelope
    set?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
    disconnect?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
    delete?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
    connect?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
    update?: TripMessageUpdateWithWhereUniqueWithoutParentInput | TripMessageUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: TripMessageUpdateManyWithWhereWithoutParentInput | TripMessageUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: TripMessageScalarWhereInput | TripMessageScalarWhereInput[]
  }

  export type MessageReactionUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageReactionCreateWithoutMessageInput, MessageReactionUncheckedCreateWithoutMessageInput> | MessageReactionCreateWithoutMessageInput[] | MessageReactionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReactionCreateOrConnectWithoutMessageInput | MessageReactionCreateOrConnectWithoutMessageInput[]
    upsert?: MessageReactionUpsertWithWhereUniqueWithoutMessageInput | MessageReactionUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageReactionCreateManyMessageInputEnvelope
    set?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    disconnect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    delete?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    connect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    update?: MessageReactionUpdateWithWhereUniqueWithoutMessageInput | MessageReactionUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageReactionUpdateManyWithWhereWithoutMessageInput | MessageReactionUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageReactionScalarWhereInput | MessageReactionScalarWhereInput[]
  }

  export type MessageReadReceiptUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageReadReceiptCreateWithoutMessageInput, MessageReadReceiptUncheckedCreateWithoutMessageInput> | MessageReadReceiptCreateWithoutMessageInput[] | MessageReadReceiptUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReadReceiptCreateOrConnectWithoutMessageInput | MessageReadReceiptCreateOrConnectWithoutMessageInput[]
    upsert?: MessageReadReceiptUpsertWithWhereUniqueWithoutMessageInput | MessageReadReceiptUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageReadReceiptCreateManyMessageInputEnvelope
    set?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
    disconnect?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
    delete?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
    connect?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
    update?: MessageReadReceiptUpdateWithWhereUniqueWithoutMessageInput | MessageReadReceiptUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageReadReceiptUpdateManyWithWhereWithoutMessageInput | MessageReadReceiptUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageReadReceiptScalarWhereInput | MessageReadReceiptScalarWhereInput[]
  }

  export type TripMessageUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<TripMessageCreateWithoutParentInput, TripMessageUncheckedCreateWithoutParentInput> | TripMessageCreateWithoutParentInput[] | TripMessageUncheckedCreateWithoutParentInput[]
    connectOrCreate?: TripMessageCreateOrConnectWithoutParentInput | TripMessageCreateOrConnectWithoutParentInput[]
    upsert?: TripMessageUpsertWithWhereUniqueWithoutParentInput | TripMessageUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: TripMessageCreateManyParentInputEnvelope
    set?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
    disconnect?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
    delete?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
    connect?: TripMessageWhereUniqueInput | TripMessageWhereUniqueInput[]
    update?: TripMessageUpdateWithWhereUniqueWithoutParentInput | TripMessageUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: TripMessageUpdateManyWithWhereWithoutParentInput | TripMessageUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: TripMessageScalarWhereInput | TripMessageScalarWhereInput[]
  }

  export type MessageReactionUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageReactionCreateWithoutMessageInput, MessageReactionUncheckedCreateWithoutMessageInput> | MessageReactionCreateWithoutMessageInput[] | MessageReactionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReactionCreateOrConnectWithoutMessageInput | MessageReactionCreateOrConnectWithoutMessageInput[]
    upsert?: MessageReactionUpsertWithWhereUniqueWithoutMessageInput | MessageReactionUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageReactionCreateManyMessageInputEnvelope
    set?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    disconnect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    delete?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    connect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    update?: MessageReactionUpdateWithWhereUniqueWithoutMessageInput | MessageReactionUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageReactionUpdateManyWithWhereWithoutMessageInput | MessageReactionUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageReactionScalarWhereInput | MessageReactionScalarWhereInput[]
  }

  export type MessageReadReceiptUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageReadReceiptCreateWithoutMessageInput, MessageReadReceiptUncheckedCreateWithoutMessageInput> | MessageReadReceiptCreateWithoutMessageInput[] | MessageReadReceiptUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReadReceiptCreateOrConnectWithoutMessageInput | MessageReadReceiptCreateOrConnectWithoutMessageInput[]
    upsert?: MessageReadReceiptUpsertWithWhereUniqueWithoutMessageInput | MessageReadReceiptUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageReadReceiptCreateManyMessageInputEnvelope
    set?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
    disconnect?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
    delete?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
    connect?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
    update?: MessageReadReceiptUpdateWithWhereUniqueWithoutMessageInput | MessageReadReceiptUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageReadReceiptUpdateManyWithWhereWithoutMessageInput | MessageReadReceiptUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageReadReceiptScalarWhereInput | MessageReadReceiptScalarWhereInput[]
  }

  export type TripMessageCreateNestedOneWithoutReactionsInput = {
    create?: XOR<TripMessageCreateWithoutReactionsInput, TripMessageUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: TripMessageCreateOrConnectWithoutReactionsInput
    connect?: TripMessageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessageReactionsInput = {
    create?: XOR<UserCreateWithoutMessageReactionsInput, UserUncheckedCreateWithoutMessageReactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageReactionsInput
    connect?: UserWhereUniqueInput
  }

  export type TripMessageUpdateOneRequiredWithoutReactionsNestedInput = {
    create?: XOR<TripMessageCreateWithoutReactionsInput, TripMessageUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: TripMessageCreateOrConnectWithoutReactionsInput
    upsert?: TripMessageUpsertWithoutReactionsInput
    connect?: TripMessageWhereUniqueInput
    update?: XOR<XOR<TripMessageUpdateToOneWithWhereWithoutReactionsInput, TripMessageUpdateWithoutReactionsInput>, TripMessageUncheckedUpdateWithoutReactionsInput>
  }

  export type UserUpdateOneRequiredWithoutMessageReactionsNestedInput = {
    create?: XOR<UserCreateWithoutMessageReactionsInput, UserUncheckedCreateWithoutMessageReactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageReactionsInput
    upsert?: UserUpsertWithoutMessageReactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessageReactionsInput, UserUpdateWithoutMessageReactionsInput>, UserUncheckedUpdateWithoutMessageReactionsInput>
  }

  export type TripMessageCreateNestedOneWithoutReadReceiptsInput = {
    create?: XOR<TripMessageCreateWithoutReadReceiptsInput, TripMessageUncheckedCreateWithoutReadReceiptsInput>
    connectOrCreate?: TripMessageCreateOrConnectWithoutReadReceiptsInput
    connect?: TripMessageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessageReadReceiptsInput = {
    create?: XOR<UserCreateWithoutMessageReadReceiptsInput, UserUncheckedCreateWithoutMessageReadReceiptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageReadReceiptsInput
    connect?: UserWhereUniqueInput
  }

  export type TripMessageUpdateOneRequiredWithoutReadReceiptsNestedInput = {
    create?: XOR<TripMessageCreateWithoutReadReceiptsInput, TripMessageUncheckedCreateWithoutReadReceiptsInput>
    connectOrCreate?: TripMessageCreateOrConnectWithoutReadReceiptsInput
    upsert?: TripMessageUpsertWithoutReadReceiptsInput
    connect?: TripMessageWhereUniqueInput
    update?: XOR<XOR<TripMessageUpdateToOneWithWhereWithoutReadReceiptsInput, TripMessageUpdateWithoutReadReceiptsInput>, TripMessageUncheckedUpdateWithoutReadReceiptsInput>
  }

  export type UserUpdateOneRequiredWithoutMessageReadReceiptsNestedInput = {
    create?: XOR<UserCreateWithoutMessageReadReceiptsInput, UserUncheckedCreateWithoutMessageReadReceiptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageReadReceiptsInput
    upsert?: UserUpsertWithoutMessageReadReceiptsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessageReadReceiptsInput, UserUpdateWithoutMessageReadReceiptsInput>, UserUncheckedUpdateWithoutMessageReadReceiptsInput>
  }

  export type TripCreateNestedOneWithoutMediaItemsInput = {
    create?: XOR<TripCreateWithoutMediaItemsInput, TripUncheckedCreateWithoutMediaItemsInput>
    connectOrCreate?: TripCreateOrConnectWithoutMediaItemsInput
    connect?: TripWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMediaItemsInput = {
    create?: XOR<UserCreateWithoutMediaItemsInput, UserUncheckedCreateWithoutMediaItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMediaItemsInput
    connect?: UserWhereUniqueInput
  }

  export type ActivityCreateNestedOneWithoutMediaItemsInput = {
    create?: XOR<ActivityCreateWithoutMediaItemsInput, ActivityUncheckedCreateWithoutMediaItemsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutMediaItemsInput
    connect?: ActivityWhereUniqueInput
  }

  export type TripUpdateOneRequiredWithoutMediaItemsNestedInput = {
    create?: XOR<TripCreateWithoutMediaItemsInput, TripUncheckedCreateWithoutMediaItemsInput>
    connectOrCreate?: TripCreateOrConnectWithoutMediaItemsInput
    upsert?: TripUpsertWithoutMediaItemsInput
    connect?: TripWhereUniqueInput
    update?: XOR<XOR<TripUpdateToOneWithWhereWithoutMediaItemsInput, TripUpdateWithoutMediaItemsInput>, TripUncheckedUpdateWithoutMediaItemsInput>
  }

  export type UserUpdateOneRequiredWithoutMediaItemsNestedInput = {
    create?: XOR<UserCreateWithoutMediaItemsInput, UserUncheckedCreateWithoutMediaItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMediaItemsInput
    upsert?: UserUpsertWithoutMediaItemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMediaItemsInput, UserUpdateWithoutMediaItemsInput>, UserUncheckedUpdateWithoutMediaItemsInput>
  }

  export type ActivityUpdateOneWithoutMediaItemsNestedInput = {
    create?: XOR<ActivityCreateWithoutMediaItemsInput, ActivityUncheckedCreateWithoutMediaItemsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutMediaItemsInput
    upsert?: ActivityUpsertWithoutMediaItemsInput
    disconnect?: ActivityWhereInput | boolean
    delete?: ActivityWhereInput | boolean
    connect?: ActivityWhereUniqueInput
    update?: XOR<XOR<ActivityUpdateToOneWithWhereWithoutMediaItemsInput, ActivityUpdateWithoutMediaItemsInput>, ActivityUncheckedUpdateWithoutMediaItemsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type TripCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<TripCreateWithoutNotificationsInput, TripUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: TripCreateOrConnectWithoutNotificationsInput
    connect?: TripWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type TripUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<TripCreateWithoutNotificationsInput, TripUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: TripCreateOrConnectWithoutNotificationsInput
    upsert?: TripUpsertWithoutNotificationsInput
    disconnect?: TripWhereInput | boolean
    delete?: TripWhereInput | boolean
    connect?: TripWhereUniqueInput
    update?: XOR<XOR<TripUpdateToOneWithWhereWithoutNotificationsInput, TripUpdateWithoutNotificationsInput>, TripUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutPushSubscriptionsInput = {
    create?: XOR<UserCreateWithoutPushSubscriptionsInput, UserUncheckedCreateWithoutPushSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPushSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPushSubscriptionsNestedInput = {
    create?: XOR<UserCreateWithoutPushSubscriptionsInput, UserUncheckedCreateWithoutPushSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPushSubscriptionsInput
    upsert?: UserUpsertWithoutPushSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPushSubscriptionsInput, UserUpdateWithoutPushSubscriptionsInput>, UserUncheckedUpdateWithoutPushSubscriptionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumTripStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TripStatus | EnumTripStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TripStatus[] | ListEnumTripStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TripStatus[] | ListEnumTripStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTripStatusFilter<$PrismaModel> | $Enums.TripStatus
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTripStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TripStatus | EnumTripStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TripStatus[] | ListEnumTripStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TripStatus[] | ListEnumTripStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTripStatusWithAggregatesFilter<$PrismaModel> | $Enums.TripStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTripStatusFilter<$PrismaModel>
    _max?: NestedEnumTripStatusFilter<$PrismaModel>
  }

  export type NestedEnumMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberRoleFilter<$PrismaModel> | $Enums.MemberRole
  }

  export type NestedEnumMemberStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberStatus | EnumMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberStatusFilter<$PrismaModel> | $Enums.MemberStatus
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.MemberRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberRoleFilter<$PrismaModel>
    _max?: NestedEnumMemberRoleFilter<$PrismaModel>
  }

  export type NestedEnumMemberStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberStatus | EnumMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberStatusWithAggregatesFilter<$PrismaModel> | $Enums.MemberStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberStatusFilter<$PrismaModel>
    _max?: NestedEnumMemberStatusFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumInviteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusFilter<$PrismaModel> | $Enums.InviteStatus
  }

  export type NestedEnumInviteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusWithAggregatesFilter<$PrismaModel> | $Enums.InviteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInviteStatusFilter<$PrismaModel>
    _max?: NestedEnumInviteStatusFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedEnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type TripMemberCreateWithoutUserInput = {
    id?: string
    role?: $Enums.MemberRole
    status?: $Enums.MemberStatus
    paymentStatus?: string | null
    paymentAmount?: Decimal | DecimalJsLike | number | string | null
    paymentConfirmedAt?: Date | string | null
    joinedAt?: Date | string
    trip: TripCreateNestedOneWithoutMembersInput
  }

  export type TripMemberUncheckedCreateWithoutUserInput = {
    id?: string
    tripId: string
    role?: $Enums.MemberRole
    status?: $Enums.MemberStatus
    paymentStatus?: string | null
    paymentAmount?: Decimal | DecimalJsLike | number | string | null
    paymentConfirmedAt?: Date | string | null
    joinedAt?: Date | string
  }

  export type TripMemberCreateOrConnectWithoutUserInput = {
    where: TripMemberWhereUniqueInput
    create: XOR<TripMemberCreateWithoutUserInput, TripMemberUncheckedCreateWithoutUserInput>
  }

  export type TripMemberCreateManyUserInputEnvelope = {
    data: TripMemberCreateManyUserInput | TripMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TripCreateWithoutTripMasterInput = {
    id?: string
    name: string
    description?: string | null
    destination?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverImage?: string | null
    status?: $Enums.TripStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TripMemberCreateNestedManyWithoutTripInput
    invites?: InviteCreateNestedManyWithoutTripInput
    activities?: ActivityCreateNestedManyWithoutTripInput
    bookings?: BookingCreateNestedManyWithoutTripInput
    messages?: TripMessageCreateNestedManyWithoutTripInput
    mediaItems?: MediaItemCreateNestedManyWithoutTripInput
    notifications?: NotificationCreateNestedManyWithoutTripInput
  }

  export type TripUncheckedCreateWithoutTripMasterInput = {
    id?: string
    name: string
    description?: string | null
    destination?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverImage?: string | null
    status?: $Enums.TripStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TripMemberUncheckedCreateNestedManyWithoutTripInput
    invites?: InviteUncheckedCreateNestedManyWithoutTripInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTripInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTripInput
    messages?: TripMessageUncheckedCreateNestedManyWithoutTripInput
    mediaItems?: MediaItemUncheckedCreateNestedManyWithoutTripInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripCreateOrConnectWithoutTripMasterInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutTripMasterInput, TripUncheckedCreateWithoutTripMasterInput>
  }

  export type TripCreateManyTripMasterInputEnvelope = {
    data: TripCreateManyTripMasterInput | TripCreateManyTripMasterInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutProposerInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startTime?: Date | string | null
    endTime?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    category: string
    votingEndsAt?: Date | string | null
    status?: string
    createdAt?: Date | string
    trip: TripCreateNestedOneWithoutActivitiesInput
    votes?: VoteCreateNestedManyWithoutActivityInput
    bookings?: BookingCreateNestedManyWithoutActivityInput
    mediaItems?: MediaItemCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutProposerInput = {
    id?: string
    tripId: string
    title: string
    description?: string | null
    location?: string | null
    startTime?: Date | string | null
    endTime?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    category: string
    votingEndsAt?: Date | string | null
    status?: string
    createdAt?: Date | string
    votes?: VoteUncheckedCreateNestedManyWithoutActivityInput
    bookings?: BookingUncheckedCreateNestedManyWithoutActivityInput
    mediaItems?: MediaItemUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutProposerInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutProposerInput, ActivityUncheckedCreateWithoutProposerInput>
  }

  export type ActivityCreateManyProposerInputEnvelope = {
    data: ActivityCreateManyProposerInput | ActivityCreateManyProposerInput[]
    skipDuplicates?: boolean
  }

  export type VoteCreateWithoutUserInput = {
    id?: string
    option: string
    activity: ActivityCreateNestedOneWithoutVotesInput
  }

  export type VoteUncheckedCreateWithoutUserInput = {
    id?: string
    activityId: string
    option: string
  }

  export type VoteCreateOrConnectWithoutUserInput = {
    where: VoteWhereUniqueInput
    create: XOR<VoteCreateWithoutUserInput, VoteUncheckedCreateWithoutUserInput>
  }

  export type VoteCreateManyUserInputEnvelope = {
    data: VoteCreateManyUserInput | VoteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TripMessageCreateWithoutUserInput = {
    id?: string
    content: string
    messageType?: $Enums.MessageType
    editedAt?: Date | string | null
    createdAt?: Date | string
    trip: TripCreateNestedOneWithoutMessagesInput
    parent?: TripMessageCreateNestedOneWithoutEditsInput
    edits?: TripMessageCreateNestedManyWithoutParentInput
    reactions?: MessageReactionCreateNestedManyWithoutMessageInput
    readReceipts?: MessageReadReceiptCreateNestedManyWithoutMessageInput
  }

  export type TripMessageUncheckedCreateWithoutUserInput = {
    id?: string
    tripId: string
    content: string
    messageType?: $Enums.MessageType
    editedAt?: Date | string | null
    parentId?: string | null
    createdAt?: Date | string
    edits?: TripMessageUncheckedCreateNestedManyWithoutParentInput
    reactions?: MessageReactionUncheckedCreateNestedManyWithoutMessageInput
    readReceipts?: MessageReadReceiptUncheckedCreateNestedManyWithoutMessageInput
  }

  export type TripMessageCreateOrConnectWithoutUserInput = {
    where: TripMessageWhereUniqueInput
    create: XOR<TripMessageCreateWithoutUserInput, TripMessageUncheckedCreateWithoutUserInput>
  }

  export type TripMessageCreateManyUserInputEnvelope = {
    data: TripMessageCreateManyUserInput | TripMessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MediaItemCreateWithoutUploaderInput = {
    id?: string
    type: string
    url: string
    thumbnailUrl?: string | null
    caption?: string | null
    createdAt?: Date | string
    trip: TripCreateNestedOneWithoutMediaItemsInput
    activity?: ActivityCreateNestedOneWithoutMediaItemsInput
  }

  export type MediaItemUncheckedCreateWithoutUploaderInput = {
    id?: string
    tripId: string
    type: string
    url: string
    thumbnailUrl?: string | null
    activityId?: string | null
    caption?: string | null
    createdAt?: Date | string
  }

  export type MediaItemCreateOrConnectWithoutUploaderInput = {
    where: MediaItemWhereUniqueInput
    create: XOR<MediaItemCreateWithoutUploaderInput, MediaItemUncheckedCreateWithoutUploaderInput>
  }

  export type MediaItemCreateManyUploaderInputEnvelope = {
    data: MediaItemCreateManyUploaderInput | MediaItemCreateManyUploaderInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    body: string
    actionUrl?: string | null
    read?: boolean
    createdAt?: Date | string
    trip?: TripCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    tripId?: string | null
    type: string
    title: string
    body: string
    actionUrl?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InviteCreateWithoutSentByInput = {
    id?: string
    token: string
    email?: string | null
    phone?: string | null
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    createdAt?: Date | string
    trip: TripCreateNestedOneWithoutInvitesInput
    channels?: InviteChannelCreateNestedManyWithoutInviteInput
  }

  export type InviteUncheckedCreateWithoutSentByInput = {
    id?: string
    tripId: string
    token: string
    email?: string | null
    phone?: string | null
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    createdAt?: Date | string
    channels?: InviteChannelUncheckedCreateNestedManyWithoutInviteInput
  }

  export type InviteCreateOrConnectWithoutSentByInput = {
    where: InviteWhereUniqueInput
    create: XOR<InviteCreateWithoutSentByInput, InviteUncheckedCreateWithoutSentByInput>
  }

  export type InviteCreateManySentByInputEnvelope = {
    data: InviteCreateManySentByInput | InviteCreateManySentByInput[]
    skipDuplicates?: boolean
  }

  export type MessageReactionCreateWithoutUserInput = {
    id?: string
    emoji: string
    message: TripMessageCreateNestedOneWithoutReactionsInput
  }

  export type MessageReactionUncheckedCreateWithoutUserInput = {
    id?: string
    messageId: string
    emoji: string
  }

  export type MessageReactionCreateOrConnectWithoutUserInput = {
    where: MessageReactionWhereUniqueInput
    create: XOR<MessageReactionCreateWithoutUserInput, MessageReactionUncheckedCreateWithoutUserInput>
  }

  export type MessageReactionCreateManyUserInputEnvelope = {
    data: MessageReactionCreateManyUserInput | MessageReactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageReadReceiptCreateWithoutUserInput = {
    id?: string
    readAt?: Date | string
    message: TripMessageCreateNestedOneWithoutReadReceiptsInput
  }

  export type MessageReadReceiptUncheckedCreateWithoutUserInput = {
    id?: string
    messageId: string
    readAt?: Date | string
  }

  export type MessageReadReceiptCreateOrConnectWithoutUserInput = {
    where: MessageReadReceiptWhereUniqueInput
    create: XOR<MessageReadReceiptCreateWithoutUserInput, MessageReadReceiptUncheckedCreateWithoutUserInput>
  }

  export type MessageReadReceiptCreateManyUserInputEnvelope = {
    data: MessageReadReceiptCreateManyUserInput | MessageReadReceiptCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PushSubscriptionCreateWithoutUserInput = {
    id?: string
    endpoint: string
    p256dh: string
    auth: string
    createdAt?: Date | string
  }

  export type PushSubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    endpoint: string
    p256dh: string
    auth: string
    createdAt?: Date | string
  }

  export type PushSubscriptionCreateOrConnectWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput
    create: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type PushSubscriptionCreateManyUserInputEnvelope = {
    data: PushSubscriptionCreateManyUserInput | PushSubscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TripMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: TripMemberWhereUniqueInput
    update: XOR<TripMemberUpdateWithoutUserInput, TripMemberUncheckedUpdateWithoutUserInput>
    create: XOR<TripMemberCreateWithoutUserInput, TripMemberUncheckedCreateWithoutUserInput>
  }

  export type TripMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: TripMemberWhereUniqueInput
    data: XOR<TripMemberUpdateWithoutUserInput, TripMemberUncheckedUpdateWithoutUserInput>
  }

  export type TripMemberUpdateManyWithWhereWithoutUserInput = {
    where: TripMemberScalarWhereInput
    data: XOR<TripMemberUpdateManyMutationInput, TripMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type TripMemberScalarWhereInput = {
    AND?: TripMemberScalarWhereInput | TripMemberScalarWhereInput[]
    OR?: TripMemberScalarWhereInput[]
    NOT?: TripMemberScalarWhereInput | TripMemberScalarWhereInput[]
    id?: StringFilter<"TripMember"> | string
    tripId?: StringFilter<"TripMember"> | string
    userId?: StringFilter<"TripMember"> | string
    role?: EnumMemberRoleFilter<"TripMember"> | $Enums.MemberRole
    status?: EnumMemberStatusFilter<"TripMember"> | $Enums.MemberStatus
    paymentStatus?: StringNullableFilter<"TripMember"> | string | null
    paymentAmount?: DecimalNullableFilter<"TripMember"> | Decimal | DecimalJsLike | number | string | null
    paymentConfirmedAt?: DateTimeNullableFilter<"TripMember"> | Date | string | null
    joinedAt?: DateTimeFilter<"TripMember"> | Date | string
  }

  export type TripUpsertWithWhereUniqueWithoutTripMasterInput = {
    where: TripWhereUniqueInput
    update: XOR<TripUpdateWithoutTripMasterInput, TripUncheckedUpdateWithoutTripMasterInput>
    create: XOR<TripCreateWithoutTripMasterInput, TripUncheckedCreateWithoutTripMasterInput>
  }

  export type TripUpdateWithWhereUniqueWithoutTripMasterInput = {
    where: TripWhereUniqueInput
    data: XOR<TripUpdateWithoutTripMasterInput, TripUncheckedUpdateWithoutTripMasterInput>
  }

  export type TripUpdateManyWithWhereWithoutTripMasterInput = {
    where: TripScalarWhereInput
    data: XOR<TripUpdateManyMutationInput, TripUncheckedUpdateManyWithoutTripMasterInput>
  }

  export type TripScalarWhereInput = {
    AND?: TripScalarWhereInput | TripScalarWhereInput[]
    OR?: TripScalarWhereInput[]
    NOT?: TripScalarWhereInput | TripScalarWhereInput[]
    id?: StringFilter<"Trip"> | string
    name?: StringFilter<"Trip"> | string
    description?: StringNullableFilter<"Trip"> | string | null
    destination?: StringNullableFilter<"Trip"> | string | null
    startDate?: DateTimeNullableFilter<"Trip"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Trip"> | Date | string | null
    coverImage?: StringNullableFilter<"Trip"> | string | null
    status?: EnumTripStatusFilter<"Trip"> | $Enums.TripStatus
    tripMasterId?: StringFilter<"Trip"> | string
    createdAt?: DateTimeFilter<"Trip"> | Date | string
    updatedAt?: DateTimeFilter<"Trip"> | Date | string
  }

  export type ActivityUpsertWithWhereUniqueWithoutProposerInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutProposerInput, ActivityUncheckedUpdateWithoutProposerInput>
    create: XOR<ActivityCreateWithoutProposerInput, ActivityUncheckedCreateWithoutProposerInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutProposerInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutProposerInput, ActivityUncheckedUpdateWithoutProposerInput>
  }

  export type ActivityUpdateManyWithWhereWithoutProposerInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutProposerInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    OR?: ActivityScalarWhereInput[]
    NOT?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    id?: StringFilter<"Activity"> | string
    tripId?: StringFilter<"Activity"> | string
    title?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    location?: StringNullableFilter<"Activity"> | string | null
    startTime?: DateTimeNullableFilter<"Activity"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Activity"> | Date | string | null
    cost?: DecimalNullableFilter<"Activity"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"Activity"> | string
    category?: StringFilter<"Activity"> | string
    proposedBy?: StringFilter<"Activity"> | string
    votingEndsAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    status?: StringFilter<"Activity"> | string
    createdAt?: DateTimeFilter<"Activity"> | Date | string
  }

  export type VoteUpsertWithWhereUniqueWithoutUserInput = {
    where: VoteWhereUniqueInput
    update: XOR<VoteUpdateWithoutUserInput, VoteUncheckedUpdateWithoutUserInput>
    create: XOR<VoteCreateWithoutUserInput, VoteUncheckedCreateWithoutUserInput>
  }

  export type VoteUpdateWithWhereUniqueWithoutUserInput = {
    where: VoteWhereUniqueInput
    data: XOR<VoteUpdateWithoutUserInput, VoteUncheckedUpdateWithoutUserInput>
  }

  export type VoteUpdateManyWithWhereWithoutUserInput = {
    where: VoteScalarWhereInput
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyWithoutUserInput>
  }

  export type VoteScalarWhereInput = {
    AND?: VoteScalarWhereInput | VoteScalarWhereInput[]
    OR?: VoteScalarWhereInput[]
    NOT?: VoteScalarWhereInput | VoteScalarWhereInput[]
    id?: StringFilter<"Vote"> | string
    activityId?: StringFilter<"Vote"> | string
    userId?: StringFilter<"Vote"> | string
    option?: StringFilter<"Vote"> | string
  }

  export type TripMessageUpsertWithWhereUniqueWithoutUserInput = {
    where: TripMessageWhereUniqueInput
    update: XOR<TripMessageUpdateWithoutUserInput, TripMessageUncheckedUpdateWithoutUserInput>
    create: XOR<TripMessageCreateWithoutUserInput, TripMessageUncheckedCreateWithoutUserInput>
  }

  export type TripMessageUpdateWithWhereUniqueWithoutUserInput = {
    where: TripMessageWhereUniqueInput
    data: XOR<TripMessageUpdateWithoutUserInput, TripMessageUncheckedUpdateWithoutUserInput>
  }

  export type TripMessageUpdateManyWithWhereWithoutUserInput = {
    where: TripMessageScalarWhereInput
    data: XOR<TripMessageUpdateManyMutationInput, TripMessageUncheckedUpdateManyWithoutUserInput>
  }

  export type TripMessageScalarWhereInput = {
    AND?: TripMessageScalarWhereInput | TripMessageScalarWhereInput[]
    OR?: TripMessageScalarWhereInput[]
    NOT?: TripMessageScalarWhereInput | TripMessageScalarWhereInput[]
    id?: StringFilter<"TripMessage"> | string
    tripId?: StringFilter<"TripMessage"> | string
    userId?: StringFilter<"TripMessage"> | string
    content?: StringFilter<"TripMessage"> | string
    messageType?: EnumMessageTypeFilter<"TripMessage"> | $Enums.MessageType
    editedAt?: DateTimeNullableFilter<"TripMessage"> | Date | string | null
    parentId?: StringNullableFilter<"TripMessage"> | string | null
    createdAt?: DateTimeFilter<"TripMessage"> | Date | string
  }

  export type MediaItemUpsertWithWhereUniqueWithoutUploaderInput = {
    where: MediaItemWhereUniqueInput
    update: XOR<MediaItemUpdateWithoutUploaderInput, MediaItemUncheckedUpdateWithoutUploaderInput>
    create: XOR<MediaItemCreateWithoutUploaderInput, MediaItemUncheckedCreateWithoutUploaderInput>
  }

  export type MediaItemUpdateWithWhereUniqueWithoutUploaderInput = {
    where: MediaItemWhereUniqueInput
    data: XOR<MediaItemUpdateWithoutUploaderInput, MediaItemUncheckedUpdateWithoutUploaderInput>
  }

  export type MediaItemUpdateManyWithWhereWithoutUploaderInput = {
    where: MediaItemScalarWhereInput
    data: XOR<MediaItemUpdateManyMutationInput, MediaItemUncheckedUpdateManyWithoutUploaderInput>
  }

  export type MediaItemScalarWhereInput = {
    AND?: MediaItemScalarWhereInput | MediaItemScalarWhereInput[]
    OR?: MediaItemScalarWhereInput[]
    NOT?: MediaItemScalarWhereInput | MediaItemScalarWhereInput[]
    id?: StringFilter<"MediaItem"> | string
    tripId?: StringFilter<"MediaItem"> | string
    uploaderId?: StringFilter<"MediaItem"> | string
    type?: StringFilter<"MediaItem"> | string
    url?: StringFilter<"MediaItem"> | string
    thumbnailUrl?: StringNullableFilter<"MediaItem"> | string | null
    activityId?: StringNullableFilter<"MediaItem"> | string | null
    caption?: StringNullableFilter<"MediaItem"> | string | null
    createdAt?: DateTimeFilter<"MediaItem"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    tripId?: StringNullableFilter<"Notification"> | string | null
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type InviteUpsertWithWhereUniqueWithoutSentByInput = {
    where: InviteWhereUniqueInput
    update: XOR<InviteUpdateWithoutSentByInput, InviteUncheckedUpdateWithoutSentByInput>
    create: XOR<InviteCreateWithoutSentByInput, InviteUncheckedCreateWithoutSentByInput>
  }

  export type InviteUpdateWithWhereUniqueWithoutSentByInput = {
    where: InviteWhereUniqueInput
    data: XOR<InviteUpdateWithoutSentByInput, InviteUncheckedUpdateWithoutSentByInput>
  }

  export type InviteUpdateManyWithWhereWithoutSentByInput = {
    where: InviteScalarWhereInput
    data: XOR<InviteUpdateManyMutationInput, InviteUncheckedUpdateManyWithoutSentByInput>
  }

  export type InviteScalarWhereInput = {
    AND?: InviteScalarWhereInput | InviteScalarWhereInput[]
    OR?: InviteScalarWhereInput[]
    NOT?: InviteScalarWhereInput | InviteScalarWhereInput[]
    id?: StringFilter<"Invite"> | string
    tripId?: StringFilter<"Invite"> | string
    token?: StringFilter<"Invite"> | string
    email?: StringNullableFilter<"Invite"> | string | null
    phone?: StringNullableFilter<"Invite"> | string | null
    status?: EnumInviteStatusFilter<"Invite"> | $Enums.InviteStatus
    expiresAt?: DateTimeFilter<"Invite"> | Date | string
    sentById?: StringFilter<"Invite"> | string
    createdAt?: DateTimeFilter<"Invite"> | Date | string
  }

  export type MessageReactionUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageReactionWhereUniqueInput
    update: XOR<MessageReactionUpdateWithoutUserInput, MessageReactionUncheckedUpdateWithoutUserInput>
    create: XOR<MessageReactionCreateWithoutUserInput, MessageReactionUncheckedCreateWithoutUserInput>
  }

  export type MessageReactionUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageReactionWhereUniqueInput
    data: XOR<MessageReactionUpdateWithoutUserInput, MessageReactionUncheckedUpdateWithoutUserInput>
  }

  export type MessageReactionUpdateManyWithWhereWithoutUserInput = {
    where: MessageReactionScalarWhereInput
    data: XOR<MessageReactionUpdateManyMutationInput, MessageReactionUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageReactionScalarWhereInput = {
    AND?: MessageReactionScalarWhereInput | MessageReactionScalarWhereInput[]
    OR?: MessageReactionScalarWhereInput[]
    NOT?: MessageReactionScalarWhereInput | MessageReactionScalarWhereInput[]
    id?: StringFilter<"MessageReaction"> | string
    messageId?: StringFilter<"MessageReaction"> | string
    userId?: StringFilter<"MessageReaction"> | string
    emoji?: StringFilter<"MessageReaction"> | string
  }

  export type MessageReadReceiptUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageReadReceiptWhereUniqueInput
    update: XOR<MessageReadReceiptUpdateWithoutUserInput, MessageReadReceiptUncheckedUpdateWithoutUserInput>
    create: XOR<MessageReadReceiptCreateWithoutUserInput, MessageReadReceiptUncheckedCreateWithoutUserInput>
  }

  export type MessageReadReceiptUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageReadReceiptWhereUniqueInput
    data: XOR<MessageReadReceiptUpdateWithoutUserInput, MessageReadReceiptUncheckedUpdateWithoutUserInput>
  }

  export type MessageReadReceiptUpdateManyWithWhereWithoutUserInput = {
    where: MessageReadReceiptScalarWhereInput
    data: XOR<MessageReadReceiptUpdateManyMutationInput, MessageReadReceiptUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageReadReceiptScalarWhereInput = {
    AND?: MessageReadReceiptScalarWhereInput | MessageReadReceiptScalarWhereInput[]
    OR?: MessageReadReceiptScalarWhereInput[]
    NOT?: MessageReadReceiptScalarWhereInput | MessageReadReceiptScalarWhereInput[]
    id?: StringFilter<"MessageReadReceipt"> | string
    messageId?: StringFilter<"MessageReadReceipt"> | string
    userId?: StringFilter<"MessageReadReceipt"> | string
    readAt?: DateTimeFilter<"MessageReadReceipt"> | Date | string
  }

  export type PushSubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput
    update: XOR<PushSubscriptionUpdateWithoutUserInput, PushSubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type PushSubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput
    data: XOR<PushSubscriptionUpdateWithoutUserInput, PushSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type PushSubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: PushSubscriptionScalarWhereInput
    data: XOR<PushSubscriptionUpdateManyMutationInput, PushSubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type PushSubscriptionScalarWhereInput = {
    AND?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
    OR?: PushSubscriptionScalarWhereInput[]
    NOT?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
    id?: StringFilter<"PushSubscription"> | string
    userId?: StringFilter<"PushSubscription"> | string
    endpoint?: StringFilter<"PushSubscription"> | string
    p256dh?: StringFilter<"PushSubscription"> | string
    auth?: StringFilter<"PushSubscription"> | string
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string
  }

  export type UserCreateWithoutCreatedTripsInput = {
    id?: string
    email: string
    name: string
    avatarUrl?: string | null
    phone?: string | null
    venmo?: string | null
    paypal?: string | null
    zelle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TripMemberCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutProposerInput
    votes?: VoteCreateNestedManyWithoutUserInput
    messages?: TripMessageCreateNestedManyWithoutUserInput
    mediaItems?: MediaItemCreateNestedManyWithoutUploaderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sentInvites?: InviteCreateNestedManyWithoutSentByInput
    messageReactions?: MessageReactionCreateNestedManyWithoutUserInput
    messageReadReceipts?: MessageReadReceiptCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedTripsInput = {
    id?: string
    email: string
    name: string
    avatarUrl?: string | null
    phone?: string | null
    venmo?: string | null
    paypal?: string | null
    zelle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TripMemberUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProposerInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
    messages?: TripMessageUncheckedCreateNestedManyWithoutUserInput
    mediaItems?: MediaItemUncheckedCreateNestedManyWithoutUploaderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sentInvites?: InviteUncheckedCreateNestedManyWithoutSentByInput
    messageReactions?: MessageReactionUncheckedCreateNestedManyWithoutUserInput
    messageReadReceipts?: MessageReadReceiptUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedTripsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedTripsInput, UserUncheckedCreateWithoutCreatedTripsInput>
  }

  export type TripMemberCreateWithoutTripInput = {
    id?: string
    role?: $Enums.MemberRole
    status?: $Enums.MemberStatus
    paymentStatus?: string | null
    paymentAmount?: Decimal | DecimalJsLike | number | string | null
    paymentConfirmedAt?: Date | string | null
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipsInput
  }

  export type TripMemberUncheckedCreateWithoutTripInput = {
    id?: string
    userId: string
    role?: $Enums.MemberRole
    status?: $Enums.MemberStatus
    paymentStatus?: string | null
    paymentAmount?: Decimal | DecimalJsLike | number | string | null
    paymentConfirmedAt?: Date | string | null
    joinedAt?: Date | string
  }

  export type TripMemberCreateOrConnectWithoutTripInput = {
    where: TripMemberWhereUniqueInput
    create: XOR<TripMemberCreateWithoutTripInput, TripMemberUncheckedCreateWithoutTripInput>
  }

  export type TripMemberCreateManyTripInputEnvelope = {
    data: TripMemberCreateManyTripInput | TripMemberCreateManyTripInput[]
    skipDuplicates?: boolean
  }

  export type InviteCreateWithoutTripInput = {
    id?: string
    token: string
    email?: string | null
    phone?: string | null
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    createdAt?: Date | string
    sentBy: UserCreateNestedOneWithoutSentInvitesInput
    channels?: InviteChannelCreateNestedManyWithoutInviteInput
  }

  export type InviteUncheckedCreateWithoutTripInput = {
    id?: string
    token: string
    email?: string | null
    phone?: string | null
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    sentById: string
    createdAt?: Date | string
    channels?: InviteChannelUncheckedCreateNestedManyWithoutInviteInput
  }

  export type InviteCreateOrConnectWithoutTripInput = {
    where: InviteWhereUniqueInput
    create: XOR<InviteCreateWithoutTripInput, InviteUncheckedCreateWithoutTripInput>
  }

  export type InviteCreateManyTripInputEnvelope = {
    data: InviteCreateManyTripInput | InviteCreateManyTripInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutTripInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startTime?: Date | string | null
    endTime?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    category: string
    votingEndsAt?: Date | string | null
    status?: string
    createdAt?: Date | string
    proposer: UserCreateNestedOneWithoutActivitiesInput
    votes?: VoteCreateNestedManyWithoutActivityInput
    bookings?: BookingCreateNestedManyWithoutActivityInput
    mediaItems?: MediaItemCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutTripInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startTime?: Date | string | null
    endTime?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    category: string
    proposedBy: string
    votingEndsAt?: Date | string | null
    status?: string
    createdAt?: Date | string
    votes?: VoteUncheckedCreateNestedManyWithoutActivityInput
    bookings?: BookingUncheckedCreateNestedManyWithoutActivityInput
    mediaItems?: MediaItemUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutTripInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutTripInput, ActivityUncheckedCreateWithoutTripInput>
  }

  export type ActivityCreateManyTripInputEnvelope = {
    data: ActivityCreateManyTripInput | ActivityCreateManyTripInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutTripInput = {
    id?: string
    bookedBy: string
    confirmationNum?: string | null
    status?: $Enums.BookingStatus
    receiptUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activity?: ActivityCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutTripInput = {
    id?: string
    activityId?: string | null
    bookedBy: string
    confirmationNum?: string | null
    status?: $Enums.BookingStatus
    receiptUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateOrConnectWithoutTripInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutTripInput, BookingUncheckedCreateWithoutTripInput>
  }

  export type BookingCreateManyTripInputEnvelope = {
    data: BookingCreateManyTripInput | BookingCreateManyTripInput[]
    skipDuplicates?: boolean
  }

  export type TripMessageCreateWithoutTripInput = {
    id?: string
    content: string
    messageType?: $Enums.MessageType
    editedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMessagesInput
    parent?: TripMessageCreateNestedOneWithoutEditsInput
    edits?: TripMessageCreateNestedManyWithoutParentInput
    reactions?: MessageReactionCreateNestedManyWithoutMessageInput
    readReceipts?: MessageReadReceiptCreateNestedManyWithoutMessageInput
  }

  export type TripMessageUncheckedCreateWithoutTripInput = {
    id?: string
    userId: string
    content: string
    messageType?: $Enums.MessageType
    editedAt?: Date | string | null
    parentId?: string | null
    createdAt?: Date | string
    edits?: TripMessageUncheckedCreateNestedManyWithoutParentInput
    reactions?: MessageReactionUncheckedCreateNestedManyWithoutMessageInput
    readReceipts?: MessageReadReceiptUncheckedCreateNestedManyWithoutMessageInput
  }

  export type TripMessageCreateOrConnectWithoutTripInput = {
    where: TripMessageWhereUniqueInput
    create: XOR<TripMessageCreateWithoutTripInput, TripMessageUncheckedCreateWithoutTripInput>
  }

  export type TripMessageCreateManyTripInputEnvelope = {
    data: TripMessageCreateManyTripInput | TripMessageCreateManyTripInput[]
    skipDuplicates?: boolean
  }

  export type MediaItemCreateWithoutTripInput = {
    id?: string
    type: string
    url: string
    thumbnailUrl?: string | null
    caption?: string | null
    createdAt?: Date | string
    uploader: UserCreateNestedOneWithoutMediaItemsInput
    activity?: ActivityCreateNestedOneWithoutMediaItemsInput
  }

  export type MediaItemUncheckedCreateWithoutTripInput = {
    id?: string
    uploaderId: string
    type: string
    url: string
    thumbnailUrl?: string | null
    activityId?: string | null
    caption?: string | null
    createdAt?: Date | string
  }

  export type MediaItemCreateOrConnectWithoutTripInput = {
    where: MediaItemWhereUniqueInput
    create: XOR<MediaItemCreateWithoutTripInput, MediaItemUncheckedCreateWithoutTripInput>
  }

  export type MediaItemCreateManyTripInputEnvelope = {
    data: MediaItemCreateManyTripInput | MediaItemCreateManyTripInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutTripInput = {
    id?: string
    type: string
    title: string
    body: string
    actionUrl?: string | null
    read?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutTripInput = {
    id?: string
    userId: string
    type: string
    title: string
    body: string
    actionUrl?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutTripInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutTripInput, NotificationUncheckedCreateWithoutTripInput>
  }

  export type NotificationCreateManyTripInputEnvelope = {
    data: NotificationCreateManyTripInput | NotificationCreateManyTripInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedTripsInput = {
    update: XOR<UserUpdateWithoutCreatedTripsInput, UserUncheckedUpdateWithoutCreatedTripsInput>
    create: XOR<UserCreateWithoutCreatedTripsInput, UserUncheckedCreateWithoutCreatedTripsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedTripsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedTripsInput, UserUncheckedUpdateWithoutCreatedTripsInput>
  }

  export type UserUpdateWithoutCreatedTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    venmo?: NullableStringFieldUpdateOperationsInput | string | null
    paypal?: NullableStringFieldUpdateOperationsInput | string | null
    zelle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TripMemberUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutProposerNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
    messages?: TripMessageUpdateManyWithoutUserNestedInput
    mediaItems?: MediaItemUpdateManyWithoutUploaderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sentInvites?: InviteUpdateManyWithoutSentByNestedInput
    messageReactions?: MessageReactionUpdateManyWithoutUserNestedInput
    messageReadReceipts?: MessageReadReceiptUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    venmo?: NullableStringFieldUpdateOperationsInput | string | null
    paypal?: NullableStringFieldUpdateOperationsInput | string | null
    zelle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TripMemberUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProposerNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
    messages?: TripMessageUncheckedUpdateManyWithoutUserNestedInput
    mediaItems?: MediaItemUncheckedUpdateManyWithoutUploaderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sentInvites?: InviteUncheckedUpdateManyWithoutSentByNestedInput
    messageReactions?: MessageReactionUncheckedUpdateManyWithoutUserNestedInput
    messageReadReceipts?: MessageReadReceiptUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TripMemberUpsertWithWhereUniqueWithoutTripInput = {
    where: TripMemberWhereUniqueInput
    update: XOR<TripMemberUpdateWithoutTripInput, TripMemberUncheckedUpdateWithoutTripInput>
    create: XOR<TripMemberCreateWithoutTripInput, TripMemberUncheckedCreateWithoutTripInput>
  }

  export type TripMemberUpdateWithWhereUniqueWithoutTripInput = {
    where: TripMemberWhereUniqueInput
    data: XOR<TripMemberUpdateWithoutTripInput, TripMemberUncheckedUpdateWithoutTripInput>
  }

  export type TripMemberUpdateManyWithWhereWithoutTripInput = {
    where: TripMemberScalarWhereInput
    data: XOR<TripMemberUpdateManyMutationInput, TripMemberUncheckedUpdateManyWithoutTripInput>
  }

  export type InviteUpsertWithWhereUniqueWithoutTripInput = {
    where: InviteWhereUniqueInput
    update: XOR<InviteUpdateWithoutTripInput, InviteUncheckedUpdateWithoutTripInput>
    create: XOR<InviteCreateWithoutTripInput, InviteUncheckedCreateWithoutTripInput>
  }

  export type InviteUpdateWithWhereUniqueWithoutTripInput = {
    where: InviteWhereUniqueInput
    data: XOR<InviteUpdateWithoutTripInput, InviteUncheckedUpdateWithoutTripInput>
  }

  export type InviteUpdateManyWithWhereWithoutTripInput = {
    where: InviteScalarWhereInput
    data: XOR<InviteUpdateManyMutationInput, InviteUncheckedUpdateManyWithoutTripInput>
  }

  export type ActivityUpsertWithWhereUniqueWithoutTripInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutTripInput, ActivityUncheckedUpdateWithoutTripInput>
    create: XOR<ActivityCreateWithoutTripInput, ActivityUncheckedCreateWithoutTripInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutTripInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutTripInput, ActivityUncheckedUpdateWithoutTripInput>
  }

  export type ActivityUpdateManyWithWhereWithoutTripInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutTripInput>
  }

  export type BookingUpsertWithWhereUniqueWithoutTripInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutTripInput, BookingUncheckedUpdateWithoutTripInput>
    create: XOR<BookingCreateWithoutTripInput, BookingUncheckedCreateWithoutTripInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutTripInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutTripInput, BookingUncheckedUpdateWithoutTripInput>
  }

  export type BookingUpdateManyWithWhereWithoutTripInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutTripInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: StringFilter<"Booking"> | string
    tripId?: StringFilter<"Booking"> | string
    activityId?: StringNullableFilter<"Booking"> | string | null
    bookedBy?: StringFilter<"Booking"> | string
    confirmationNum?: StringNullableFilter<"Booking"> | string | null
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    receiptUrl?: StringNullableFilter<"Booking"> | string | null
    notes?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
  }

  export type TripMessageUpsertWithWhereUniqueWithoutTripInput = {
    where: TripMessageWhereUniqueInput
    update: XOR<TripMessageUpdateWithoutTripInput, TripMessageUncheckedUpdateWithoutTripInput>
    create: XOR<TripMessageCreateWithoutTripInput, TripMessageUncheckedCreateWithoutTripInput>
  }

  export type TripMessageUpdateWithWhereUniqueWithoutTripInput = {
    where: TripMessageWhereUniqueInput
    data: XOR<TripMessageUpdateWithoutTripInput, TripMessageUncheckedUpdateWithoutTripInput>
  }

  export type TripMessageUpdateManyWithWhereWithoutTripInput = {
    where: TripMessageScalarWhereInput
    data: XOR<TripMessageUpdateManyMutationInput, TripMessageUncheckedUpdateManyWithoutTripInput>
  }

  export type MediaItemUpsertWithWhereUniqueWithoutTripInput = {
    where: MediaItemWhereUniqueInput
    update: XOR<MediaItemUpdateWithoutTripInput, MediaItemUncheckedUpdateWithoutTripInput>
    create: XOR<MediaItemCreateWithoutTripInput, MediaItemUncheckedCreateWithoutTripInput>
  }

  export type MediaItemUpdateWithWhereUniqueWithoutTripInput = {
    where: MediaItemWhereUniqueInput
    data: XOR<MediaItemUpdateWithoutTripInput, MediaItemUncheckedUpdateWithoutTripInput>
  }

  export type MediaItemUpdateManyWithWhereWithoutTripInput = {
    where: MediaItemScalarWhereInput
    data: XOR<MediaItemUpdateManyMutationInput, MediaItemUncheckedUpdateManyWithoutTripInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutTripInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutTripInput, NotificationUncheckedUpdateWithoutTripInput>
    create: XOR<NotificationCreateWithoutTripInput, NotificationUncheckedCreateWithoutTripInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutTripInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutTripInput, NotificationUncheckedUpdateWithoutTripInput>
  }

  export type NotificationUpdateManyWithWhereWithoutTripInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutTripInput>
  }

  export type TripCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    destination?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverImage?: string | null
    status?: $Enums.TripStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tripMaster: UserCreateNestedOneWithoutCreatedTripsInput
    invites?: InviteCreateNestedManyWithoutTripInput
    activities?: ActivityCreateNestedManyWithoutTripInput
    bookings?: BookingCreateNestedManyWithoutTripInput
    messages?: TripMessageCreateNestedManyWithoutTripInput
    mediaItems?: MediaItemCreateNestedManyWithoutTripInput
    notifications?: NotificationCreateNestedManyWithoutTripInput
  }

  export type TripUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    destination?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverImage?: string | null
    status?: $Enums.TripStatus
    tripMasterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invites?: InviteUncheckedCreateNestedManyWithoutTripInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTripInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTripInput
    messages?: TripMessageUncheckedCreateNestedManyWithoutTripInput
    mediaItems?: MediaItemUncheckedCreateNestedManyWithoutTripInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripCreateOrConnectWithoutMembersInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutMembersInput, TripUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutMembershipsInput = {
    id?: string
    email: string
    name: string
    avatarUrl?: string | null
    phone?: string | null
    venmo?: string | null
    paypal?: string | null
    zelle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdTrips?: TripCreateNestedManyWithoutTripMasterInput
    activities?: ActivityCreateNestedManyWithoutProposerInput
    votes?: VoteCreateNestedManyWithoutUserInput
    messages?: TripMessageCreateNestedManyWithoutUserInput
    mediaItems?: MediaItemCreateNestedManyWithoutUploaderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sentInvites?: InviteCreateNestedManyWithoutSentByInput
    messageReactions?: MessageReactionCreateNestedManyWithoutUserInput
    messageReadReceipts?: MessageReadReceiptCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMembershipsInput = {
    id?: string
    email: string
    name: string
    avatarUrl?: string | null
    phone?: string | null
    venmo?: string | null
    paypal?: string | null
    zelle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdTrips?: TripUncheckedCreateNestedManyWithoutTripMasterInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProposerInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
    messages?: TripMessageUncheckedCreateNestedManyWithoutUserInput
    mediaItems?: MediaItemUncheckedCreateNestedManyWithoutUploaderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sentInvites?: InviteUncheckedCreateNestedManyWithoutSentByInput
    messageReactions?: MessageReactionUncheckedCreateNestedManyWithoutUserInput
    messageReadReceipts?: MessageReadReceiptUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
  }

  export type TripUpsertWithoutMembersInput = {
    update: XOR<TripUpdateWithoutMembersInput, TripUncheckedUpdateWithoutMembersInput>
    create: XOR<TripCreateWithoutMembersInput, TripUncheckedCreateWithoutMembersInput>
    where?: TripWhereInput
  }

  export type TripUpdateToOneWithWhereWithoutMembersInput = {
    where?: TripWhereInput
    data: XOR<TripUpdateWithoutMembersInput, TripUncheckedUpdateWithoutMembersInput>
  }

  export type TripUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tripMaster?: UserUpdateOneRequiredWithoutCreatedTripsNestedInput
    invites?: InviteUpdateManyWithoutTripNestedInput
    activities?: ActivityUpdateManyWithoutTripNestedInput
    bookings?: BookingUpdateManyWithoutTripNestedInput
    messages?: TripMessageUpdateManyWithoutTripNestedInput
    mediaItems?: MediaItemUpdateManyWithoutTripNestedInput
    notifications?: NotificationUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    tripMasterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invites?: InviteUncheckedUpdateManyWithoutTripNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTripNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTripNestedInput
    messages?: TripMessageUncheckedUpdateManyWithoutTripNestedInput
    mediaItems?: MediaItemUncheckedUpdateManyWithoutTripNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTripNestedInput
  }

  export type UserUpsertWithoutMembershipsInput = {
    update: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>
  }

  export type UserUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    venmo?: NullableStringFieldUpdateOperationsInput | string | null
    paypal?: NullableStringFieldUpdateOperationsInput | string | null
    zelle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdTrips?: TripUpdateManyWithoutTripMasterNestedInput
    activities?: ActivityUpdateManyWithoutProposerNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
    messages?: TripMessageUpdateManyWithoutUserNestedInput
    mediaItems?: MediaItemUpdateManyWithoutUploaderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sentInvites?: InviteUpdateManyWithoutSentByNestedInput
    messageReactions?: MessageReactionUpdateManyWithoutUserNestedInput
    messageReadReceipts?: MessageReadReceiptUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    venmo?: NullableStringFieldUpdateOperationsInput | string | null
    paypal?: NullableStringFieldUpdateOperationsInput | string | null
    zelle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdTrips?: TripUncheckedUpdateManyWithoutTripMasterNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProposerNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
    messages?: TripMessageUncheckedUpdateManyWithoutUserNestedInput
    mediaItems?: MediaItemUncheckedUpdateManyWithoutUploaderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sentInvites?: InviteUncheckedUpdateManyWithoutSentByNestedInput
    messageReactions?: MessageReactionUncheckedUpdateManyWithoutUserNestedInput
    messageReadReceipts?: MessageReadReceiptUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TripCreateWithoutInvitesInput = {
    id?: string
    name: string
    description?: string | null
    destination?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverImage?: string | null
    status?: $Enums.TripStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tripMaster: UserCreateNestedOneWithoutCreatedTripsInput
    members?: TripMemberCreateNestedManyWithoutTripInput
    activities?: ActivityCreateNestedManyWithoutTripInput
    bookings?: BookingCreateNestedManyWithoutTripInput
    messages?: TripMessageCreateNestedManyWithoutTripInput
    mediaItems?: MediaItemCreateNestedManyWithoutTripInput
    notifications?: NotificationCreateNestedManyWithoutTripInput
  }

  export type TripUncheckedCreateWithoutInvitesInput = {
    id?: string
    name: string
    description?: string | null
    destination?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverImage?: string | null
    status?: $Enums.TripStatus
    tripMasterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TripMemberUncheckedCreateNestedManyWithoutTripInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTripInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTripInput
    messages?: TripMessageUncheckedCreateNestedManyWithoutTripInput
    mediaItems?: MediaItemUncheckedCreateNestedManyWithoutTripInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripCreateOrConnectWithoutInvitesInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutInvitesInput, TripUncheckedCreateWithoutInvitesInput>
  }

  export type UserCreateWithoutSentInvitesInput = {
    id?: string
    email: string
    name: string
    avatarUrl?: string | null
    phone?: string | null
    venmo?: string | null
    paypal?: string | null
    zelle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TripMemberCreateNestedManyWithoutUserInput
    createdTrips?: TripCreateNestedManyWithoutTripMasterInput
    activities?: ActivityCreateNestedManyWithoutProposerInput
    votes?: VoteCreateNestedManyWithoutUserInput
    messages?: TripMessageCreateNestedManyWithoutUserInput
    mediaItems?: MediaItemCreateNestedManyWithoutUploaderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messageReactions?: MessageReactionCreateNestedManyWithoutUserInput
    messageReadReceipts?: MessageReadReceiptCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSentInvitesInput = {
    id?: string
    email: string
    name: string
    avatarUrl?: string | null
    phone?: string | null
    venmo?: string | null
    paypal?: string | null
    zelle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TripMemberUncheckedCreateNestedManyWithoutUserInput
    createdTrips?: TripUncheckedCreateNestedManyWithoutTripMasterInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProposerInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
    messages?: TripMessageUncheckedCreateNestedManyWithoutUserInput
    mediaItems?: MediaItemUncheckedCreateNestedManyWithoutUploaderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messageReactions?: MessageReactionUncheckedCreateNestedManyWithoutUserInput
    messageReadReceipts?: MessageReadReceiptUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSentInvitesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentInvitesInput, UserUncheckedCreateWithoutSentInvitesInput>
  }

  export type InviteChannelCreateWithoutInviteInput = {
    id?: string
    channel: string
    externalId?: string | null
  }

  export type InviteChannelUncheckedCreateWithoutInviteInput = {
    id?: string
    channel: string
    externalId?: string | null
  }

  export type InviteChannelCreateOrConnectWithoutInviteInput = {
    where: InviteChannelWhereUniqueInput
    create: XOR<InviteChannelCreateWithoutInviteInput, InviteChannelUncheckedCreateWithoutInviteInput>
  }

  export type InviteChannelCreateManyInviteInputEnvelope = {
    data: InviteChannelCreateManyInviteInput | InviteChannelCreateManyInviteInput[]
    skipDuplicates?: boolean
  }

  export type TripUpsertWithoutInvitesInput = {
    update: XOR<TripUpdateWithoutInvitesInput, TripUncheckedUpdateWithoutInvitesInput>
    create: XOR<TripCreateWithoutInvitesInput, TripUncheckedCreateWithoutInvitesInput>
    where?: TripWhereInput
  }

  export type TripUpdateToOneWithWhereWithoutInvitesInput = {
    where?: TripWhereInput
    data: XOR<TripUpdateWithoutInvitesInput, TripUncheckedUpdateWithoutInvitesInput>
  }

  export type TripUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tripMaster?: UserUpdateOneRequiredWithoutCreatedTripsNestedInput
    members?: TripMemberUpdateManyWithoutTripNestedInput
    activities?: ActivityUpdateManyWithoutTripNestedInput
    bookings?: BookingUpdateManyWithoutTripNestedInput
    messages?: TripMessageUpdateManyWithoutTripNestedInput
    mediaItems?: MediaItemUpdateManyWithoutTripNestedInput
    notifications?: NotificationUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    tripMasterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TripMemberUncheckedUpdateManyWithoutTripNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTripNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTripNestedInput
    messages?: TripMessageUncheckedUpdateManyWithoutTripNestedInput
    mediaItems?: MediaItemUncheckedUpdateManyWithoutTripNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTripNestedInput
  }

  export type UserUpsertWithoutSentInvitesInput = {
    update: XOR<UserUpdateWithoutSentInvitesInput, UserUncheckedUpdateWithoutSentInvitesInput>
    create: XOR<UserCreateWithoutSentInvitesInput, UserUncheckedCreateWithoutSentInvitesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentInvitesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentInvitesInput, UserUncheckedUpdateWithoutSentInvitesInput>
  }

  export type UserUpdateWithoutSentInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    venmo?: NullableStringFieldUpdateOperationsInput | string | null
    paypal?: NullableStringFieldUpdateOperationsInput | string | null
    zelle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TripMemberUpdateManyWithoutUserNestedInput
    createdTrips?: TripUpdateManyWithoutTripMasterNestedInput
    activities?: ActivityUpdateManyWithoutProposerNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
    messages?: TripMessageUpdateManyWithoutUserNestedInput
    mediaItems?: MediaItemUpdateManyWithoutUploaderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messageReactions?: MessageReactionUpdateManyWithoutUserNestedInput
    messageReadReceipts?: MessageReadReceiptUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    venmo?: NullableStringFieldUpdateOperationsInput | string | null
    paypal?: NullableStringFieldUpdateOperationsInput | string | null
    zelle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TripMemberUncheckedUpdateManyWithoutUserNestedInput
    createdTrips?: TripUncheckedUpdateManyWithoutTripMasterNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProposerNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
    messages?: TripMessageUncheckedUpdateManyWithoutUserNestedInput
    mediaItems?: MediaItemUncheckedUpdateManyWithoutUploaderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messageReactions?: MessageReactionUncheckedUpdateManyWithoutUserNestedInput
    messageReadReceipts?: MessageReadReceiptUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InviteChannelUpsertWithWhereUniqueWithoutInviteInput = {
    where: InviteChannelWhereUniqueInput
    update: XOR<InviteChannelUpdateWithoutInviteInput, InviteChannelUncheckedUpdateWithoutInviteInput>
    create: XOR<InviteChannelCreateWithoutInviteInput, InviteChannelUncheckedCreateWithoutInviteInput>
  }

  export type InviteChannelUpdateWithWhereUniqueWithoutInviteInput = {
    where: InviteChannelWhereUniqueInput
    data: XOR<InviteChannelUpdateWithoutInviteInput, InviteChannelUncheckedUpdateWithoutInviteInput>
  }

  export type InviteChannelUpdateManyWithWhereWithoutInviteInput = {
    where: InviteChannelScalarWhereInput
    data: XOR<InviteChannelUpdateManyMutationInput, InviteChannelUncheckedUpdateManyWithoutInviteInput>
  }

  export type InviteChannelScalarWhereInput = {
    AND?: InviteChannelScalarWhereInput | InviteChannelScalarWhereInput[]
    OR?: InviteChannelScalarWhereInput[]
    NOT?: InviteChannelScalarWhereInput | InviteChannelScalarWhereInput[]
    id?: StringFilter<"InviteChannel"> | string
    inviteId?: StringFilter<"InviteChannel"> | string
    channel?: StringFilter<"InviteChannel"> | string
    externalId?: StringNullableFilter<"InviteChannel"> | string | null
  }

  export type InviteCreateWithoutChannelsInput = {
    id?: string
    token: string
    email?: string | null
    phone?: string | null
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    createdAt?: Date | string
    trip: TripCreateNestedOneWithoutInvitesInput
    sentBy: UserCreateNestedOneWithoutSentInvitesInput
  }

  export type InviteUncheckedCreateWithoutChannelsInput = {
    id?: string
    tripId: string
    token: string
    email?: string | null
    phone?: string | null
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    sentById: string
    createdAt?: Date | string
  }

  export type InviteCreateOrConnectWithoutChannelsInput = {
    where: InviteWhereUniqueInput
    create: XOR<InviteCreateWithoutChannelsInput, InviteUncheckedCreateWithoutChannelsInput>
  }

  export type InviteUpsertWithoutChannelsInput = {
    update: XOR<InviteUpdateWithoutChannelsInput, InviteUncheckedUpdateWithoutChannelsInput>
    create: XOR<InviteCreateWithoutChannelsInput, InviteUncheckedCreateWithoutChannelsInput>
    where?: InviteWhereInput
  }

  export type InviteUpdateToOneWithWhereWithoutChannelsInput = {
    where?: InviteWhereInput
    data: XOR<InviteUpdateWithoutChannelsInput, InviteUncheckedUpdateWithoutChannelsInput>
  }

  export type InviteUpdateWithoutChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trip?: TripUpdateOneRequiredWithoutInvitesNestedInput
    sentBy?: UserUpdateOneRequiredWithoutSentInvitesNestedInput
  }

  export type InviteUncheckedUpdateWithoutChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripCreateWithoutActivitiesInput = {
    id?: string
    name: string
    description?: string | null
    destination?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverImage?: string | null
    status?: $Enums.TripStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tripMaster: UserCreateNestedOneWithoutCreatedTripsInput
    members?: TripMemberCreateNestedManyWithoutTripInput
    invites?: InviteCreateNestedManyWithoutTripInput
    bookings?: BookingCreateNestedManyWithoutTripInput
    messages?: TripMessageCreateNestedManyWithoutTripInput
    mediaItems?: MediaItemCreateNestedManyWithoutTripInput
    notifications?: NotificationCreateNestedManyWithoutTripInput
  }

  export type TripUncheckedCreateWithoutActivitiesInput = {
    id?: string
    name: string
    description?: string | null
    destination?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverImage?: string | null
    status?: $Enums.TripStatus
    tripMasterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TripMemberUncheckedCreateNestedManyWithoutTripInput
    invites?: InviteUncheckedCreateNestedManyWithoutTripInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTripInput
    messages?: TripMessageUncheckedCreateNestedManyWithoutTripInput
    mediaItems?: MediaItemUncheckedCreateNestedManyWithoutTripInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripCreateOrConnectWithoutActivitiesInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutActivitiesInput, TripUncheckedCreateWithoutActivitiesInput>
  }

  export type UserCreateWithoutActivitiesInput = {
    id?: string
    email: string
    name: string
    avatarUrl?: string | null
    phone?: string | null
    venmo?: string | null
    paypal?: string | null
    zelle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TripMemberCreateNestedManyWithoutUserInput
    createdTrips?: TripCreateNestedManyWithoutTripMasterInput
    votes?: VoteCreateNestedManyWithoutUserInput
    messages?: TripMessageCreateNestedManyWithoutUserInput
    mediaItems?: MediaItemCreateNestedManyWithoutUploaderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sentInvites?: InviteCreateNestedManyWithoutSentByInput
    messageReactions?: MessageReactionCreateNestedManyWithoutUserInput
    messageReadReceipts?: MessageReadReceiptCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivitiesInput = {
    id?: string
    email: string
    name: string
    avatarUrl?: string | null
    phone?: string | null
    venmo?: string | null
    paypal?: string | null
    zelle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TripMemberUncheckedCreateNestedManyWithoutUserInput
    createdTrips?: TripUncheckedCreateNestedManyWithoutTripMasterInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
    messages?: TripMessageUncheckedCreateNestedManyWithoutUserInput
    mediaItems?: MediaItemUncheckedCreateNestedManyWithoutUploaderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sentInvites?: InviteUncheckedCreateNestedManyWithoutSentByInput
    messageReactions?: MessageReactionUncheckedCreateNestedManyWithoutUserInput
    messageReadReceipts?: MessageReadReceiptUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
  }

  export type VoteCreateWithoutActivityInput = {
    id?: string
    option: string
    user: UserCreateNestedOneWithoutVotesInput
  }

  export type VoteUncheckedCreateWithoutActivityInput = {
    id?: string
    userId: string
    option: string
  }

  export type VoteCreateOrConnectWithoutActivityInput = {
    where: VoteWhereUniqueInput
    create: XOR<VoteCreateWithoutActivityInput, VoteUncheckedCreateWithoutActivityInput>
  }

  export type VoteCreateManyActivityInputEnvelope = {
    data: VoteCreateManyActivityInput | VoteCreateManyActivityInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutActivityInput = {
    id?: string
    bookedBy: string
    confirmationNum?: string | null
    status?: $Enums.BookingStatus
    receiptUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trip: TripCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutActivityInput = {
    id?: string
    tripId: string
    bookedBy: string
    confirmationNum?: string | null
    status?: $Enums.BookingStatus
    receiptUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateOrConnectWithoutActivityInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutActivityInput, BookingUncheckedCreateWithoutActivityInput>
  }

  export type BookingCreateManyActivityInputEnvelope = {
    data: BookingCreateManyActivityInput | BookingCreateManyActivityInput[]
    skipDuplicates?: boolean
  }

  export type MediaItemCreateWithoutActivityInput = {
    id?: string
    type: string
    url: string
    thumbnailUrl?: string | null
    caption?: string | null
    createdAt?: Date | string
    trip: TripCreateNestedOneWithoutMediaItemsInput
    uploader: UserCreateNestedOneWithoutMediaItemsInput
  }

  export type MediaItemUncheckedCreateWithoutActivityInput = {
    id?: string
    tripId: string
    uploaderId: string
    type: string
    url: string
    thumbnailUrl?: string | null
    caption?: string | null
    createdAt?: Date | string
  }

  export type MediaItemCreateOrConnectWithoutActivityInput = {
    where: MediaItemWhereUniqueInput
    create: XOR<MediaItemCreateWithoutActivityInput, MediaItemUncheckedCreateWithoutActivityInput>
  }

  export type MediaItemCreateManyActivityInputEnvelope = {
    data: MediaItemCreateManyActivityInput | MediaItemCreateManyActivityInput[]
    skipDuplicates?: boolean
  }

  export type TripUpsertWithoutActivitiesInput = {
    update: XOR<TripUpdateWithoutActivitiesInput, TripUncheckedUpdateWithoutActivitiesInput>
    create: XOR<TripCreateWithoutActivitiesInput, TripUncheckedCreateWithoutActivitiesInput>
    where?: TripWhereInput
  }

  export type TripUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: TripWhereInput
    data: XOR<TripUpdateWithoutActivitiesInput, TripUncheckedUpdateWithoutActivitiesInput>
  }

  export type TripUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tripMaster?: UserUpdateOneRequiredWithoutCreatedTripsNestedInput
    members?: TripMemberUpdateManyWithoutTripNestedInput
    invites?: InviteUpdateManyWithoutTripNestedInput
    bookings?: BookingUpdateManyWithoutTripNestedInput
    messages?: TripMessageUpdateManyWithoutTripNestedInput
    mediaItems?: MediaItemUpdateManyWithoutTripNestedInput
    notifications?: NotificationUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    tripMasterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TripMemberUncheckedUpdateManyWithoutTripNestedInput
    invites?: InviteUncheckedUpdateManyWithoutTripNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTripNestedInput
    messages?: TripMessageUncheckedUpdateManyWithoutTripNestedInput
    mediaItems?: MediaItemUncheckedUpdateManyWithoutTripNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTripNestedInput
  }

  export type UserUpsertWithoutActivitiesInput = {
    update: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    venmo?: NullableStringFieldUpdateOperationsInput | string | null
    paypal?: NullableStringFieldUpdateOperationsInput | string | null
    zelle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TripMemberUpdateManyWithoutUserNestedInput
    createdTrips?: TripUpdateManyWithoutTripMasterNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
    messages?: TripMessageUpdateManyWithoutUserNestedInput
    mediaItems?: MediaItemUpdateManyWithoutUploaderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sentInvites?: InviteUpdateManyWithoutSentByNestedInput
    messageReactions?: MessageReactionUpdateManyWithoutUserNestedInput
    messageReadReceipts?: MessageReadReceiptUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    venmo?: NullableStringFieldUpdateOperationsInput | string | null
    paypal?: NullableStringFieldUpdateOperationsInput | string | null
    zelle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TripMemberUncheckedUpdateManyWithoutUserNestedInput
    createdTrips?: TripUncheckedUpdateManyWithoutTripMasterNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
    messages?: TripMessageUncheckedUpdateManyWithoutUserNestedInput
    mediaItems?: MediaItemUncheckedUpdateManyWithoutUploaderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sentInvites?: InviteUncheckedUpdateManyWithoutSentByNestedInput
    messageReactions?: MessageReactionUncheckedUpdateManyWithoutUserNestedInput
    messageReadReceipts?: MessageReadReceiptUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VoteUpsertWithWhereUniqueWithoutActivityInput = {
    where: VoteWhereUniqueInput
    update: XOR<VoteUpdateWithoutActivityInput, VoteUncheckedUpdateWithoutActivityInput>
    create: XOR<VoteCreateWithoutActivityInput, VoteUncheckedCreateWithoutActivityInput>
  }

  export type VoteUpdateWithWhereUniqueWithoutActivityInput = {
    where: VoteWhereUniqueInput
    data: XOR<VoteUpdateWithoutActivityInput, VoteUncheckedUpdateWithoutActivityInput>
  }

  export type VoteUpdateManyWithWhereWithoutActivityInput = {
    where: VoteScalarWhereInput
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyWithoutActivityInput>
  }

  export type BookingUpsertWithWhereUniqueWithoutActivityInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutActivityInput, BookingUncheckedUpdateWithoutActivityInput>
    create: XOR<BookingCreateWithoutActivityInput, BookingUncheckedCreateWithoutActivityInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutActivityInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutActivityInput, BookingUncheckedUpdateWithoutActivityInput>
  }

  export type BookingUpdateManyWithWhereWithoutActivityInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutActivityInput>
  }

  export type MediaItemUpsertWithWhereUniqueWithoutActivityInput = {
    where: MediaItemWhereUniqueInput
    update: XOR<MediaItemUpdateWithoutActivityInput, MediaItemUncheckedUpdateWithoutActivityInput>
    create: XOR<MediaItemCreateWithoutActivityInput, MediaItemUncheckedCreateWithoutActivityInput>
  }

  export type MediaItemUpdateWithWhereUniqueWithoutActivityInput = {
    where: MediaItemWhereUniqueInput
    data: XOR<MediaItemUpdateWithoutActivityInput, MediaItemUncheckedUpdateWithoutActivityInput>
  }

  export type MediaItemUpdateManyWithWhereWithoutActivityInput = {
    where: MediaItemScalarWhereInput
    data: XOR<MediaItemUpdateManyMutationInput, MediaItemUncheckedUpdateManyWithoutActivityInput>
  }

  export type ActivityCreateWithoutVotesInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startTime?: Date | string | null
    endTime?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    category: string
    votingEndsAt?: Date | string | null
    status?: string
    createdAt?: Date | string
    trip: TripCreateNestedOneWithoutActivitiesInput
    proposer: UserCreateNestedOneWithoutActivitiesInput
    bookings?: BookingCreateNestedManyWithoutActivityInput
    mediaItems?: MediaItemCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutVotesInput = {
    id?: string
    tripId: string
    title: string
    description?: string | null
    location?: string | null
    startTime?: Date | string | null
    endTime?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    category: string
    proposedBy: string
    votingEndsAt?: Date | string | null
    status?: string
    createdAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutActivityInput
    mediaItems?: MediaItemUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutVotesInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutVotesInput, ActivityUncheckedCreateWithoutVotesInput>
  }

  export type UserCreateWithoutVotesInput = {
    id?: string
    email: string
    name: string
    avatarUrl?: string | null
    phone?: string | null
    venmo?: string | null
    paypal?: string | null
    zelle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TripMemberCreateNestedManyWithoutUserInput
    createdTrips?: TripCreateNestedManyWithoutTripMasterInput
    activities?: ActivityCreateNestedManyWithoutProposerInput
    messages?: TripMessageCreateNestedManyWithoutUserInput
    mediaItems?: MediaItemCreateNestedManyWithoutUploaderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sentInvites?: InviteCreateNestedManyWithoutSentByInput
    messageReactions?: MessageReactionCreateNestedManyWithoutUserInput
    messageReadReceipts?: MessageReadReceiptCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVotesInput = {
    id?: string
    email: string
    name: string
    avatarUrl?: string | null
    phone?: string | null
    venmo?: string | null
    paypal?: string | null
    zelle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TripMemberUncheckedCreateNestedManyWithoutUserInput
    createdTrips?: TripUncheckedCreateNestedManyWithoutTripMasterInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProposerInput
    messages?: TripMessageUncheckedCreateNestedManyWithoutUserInput
    mediaItems?: MediaItemUncheckedCreateNestedManyWithoutUploaderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sentInvites?: InviteUncheckedCreateNestedManyWithoutSentByInput
    messageReactions?: MessageReactionUncheckedCreateNestedManyWithoutUserInput
    messageReadReceipts?: MessageReadReceiptUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVotesInput, UserUncheckedCreateWithoutVotesInput>
  }

  export type ActivityUpsertWithoutVotesInput = {
    update: XOR<ActivityUpdateWithoutVotesInput, ActivityUncheckedUpdateWithoutVotesInput>
    create: XOR<ActivityCreateWithoutVotesInput, ActivityUncheckedCreateWithoutVotesInput>
    where?: ActivityWhereInput
  }

  export type ActivityUpdateToOneWithWhereWithoutVotesInput = {
    where?: ActivityWhereInput
    data: XOR<ActivityUpdateWithoutVotesInput, ActivityUncheckedUpdateWithoutVotesInput>
  }

  export type ActivityUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    votingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trip?: TripUpdateOneRequiredWithoutActivitiesNestedInput
    proposer?: UserUpdateOneRequiredWithoutActivitiesNestedInput
    bookings?: BookingUpdateManyWithoutActivityNestedInput
    mediaItems?: MediaItemUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    proposedBy?: StringFieldUpdateOperationsInput | string
    votingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutActivityNestedInput
    mediaItems?: MediaItemUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type UserUpsertWithoutVotesInput = {
    update: XOR<UserUpdateWithoutVotesInput, UserUncheckedUpdateWithoutVotesInput>
    create: XOR<UserCreateWithoutVotesInput, UserUncheckedCreateWithoutVotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVotesInput, UserUncheckedUpdateWithoutVotesInput>
  }

  export type UserUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    venmo?: NullableStringFieldUpdateOperationsInput | string | null
    paypal?: NullableStringFieldUpdateOperationsInput | string | null
    zelle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TripMemberUpdateManyWithoutUserNestedInput
    createdTrips?: TripUpdateManyWithoutTripMasterNestedInput
    activities?: ActivityUpdateManyWithoutProposerNestedInput
    messages?: TripMessageUpdateManyWithoutUserNestedInput
    mediaItems?: MediaItemUpdateManyWithoutUploaderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sentInvites?: InviteUpdateManyWithoutSentByNestedInput
    messageReactions?: MessageReactionUpdateManyWithoutUserNestedInput
    messageReadReceipts?: MessageReadReceiptUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    venmo?: NullableStringFieldUpdateOperationsInput | string | null
    paypal?: NullableStringFieldUpdateOperationsInput | string | null
    zelle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TripMemberUncheckedUpdateManyWithoutUserNestedInput
    createdTrips?: TripUncheckedUpdateManyWithoutTripMasterNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProposerNestedInput
    messages?: TripMessageUncheckedUpdateManyWithoutUserNestedInput
    mediaItems?: MediaItemUncheckedUpdateManyWithoutUploaderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sentInvites?: InviteUncheckedUpdateManyWithoutSentByNestedInput
    messageReactions?: MessageReactionUncheckedUpdateManyWithoutUserNestedInput
    messageReadReceipts?: MessageReadReceiptUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TripCreateWithoutBookingsInput = {
    id?: string
    name: string
    description?: string | null
    destination?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverImage?: string | null
    status?: $Enums.TripStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tripMaster: UserCreateNestedOneWithoutCreatedTripsInput
    members?: TripMemberCreateNestedManyWithoutTripInput
    invites?: InviteCreateNestedManyWithoutTripInput
    activities?: ActivityCreateNestedManyWithoutTripInput
    messages?: TripMessageCreateNestedManyWithoutTripInput
    mediaItems?: MediaItemCreateNestedManyWithoutTripInput
    notifications?: NotificationCreateNestedManyWithoutTripInput
  }

  export type TripUncheckedCreateWithoutBookingsInput = {
    id?: string
    name: string
    description?: string | null
    destination?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverImage?: string | null
    status?: $Enums.TripStatus
    tripMasterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TripMemberUncheckedCreateNestedManyWithoutTripInput
    invites?: InviteUncheckedCreateNestedManyWithoutTripInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTripInput
    messages?: TripMessageUncheckedCreateNestedManyWithoutTripInput
    mediaItems?: MediaItemUncheckedCreateNestedManyWithoutTripInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripCreateOrConnectWithoutBookingsInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutBookingsInput, TripUncheckedCreateWithoutBookingsInput>
  }

  export type ActivityCreateWithoutBookingsInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startTime?: Date | string | null
    endTime?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    category: string
    votingEndsAt?: Date | string | null
    status?: string
    createdAt?: Date | string
    trip: TripCreateNestedOneWithoutActivitiesInput
    proposer: UserCreateNestedOneWithoutActivitiesInput
    votes?: VoteCreateNestedManyWithoutActivityInput
    mediaItems?: MediaItemCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutBookingsInput = {
    id?: string
    tripId: string
    title: string
    description?: string | null
    location?: string | null
    startTime?: Date | string | null
    endTime?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    category: string
    proposedBy: string
    votingEndsAt?: Date | string | null
    status?: string
    createdAt?: Date | string
    votes?: VoteUncheckedCreateNestedManyWithoutActivityInput
    mediaItems?: MediaItemUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutBookingsInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutBookingsInput, ActivityUncheckedCreateWithoutBookingsInput>
  }

  export type TripUpsertWithoutBookingsInput = {
    update: XOR<TripUpdateWithoutBookingsInput, TripUncheckedUpdateWithoutBookingsInput>
    create: XOR<TripCreateWithoutBookingsInput, TripUncheckedCreateWithoutBookingsInput>
    where?: TripWhereInput
  }

  export type TripUpdateToOneWithWhereWithoutBookingsInput = {
    where?: TripWhereInput
    data: XOR<TripUpdateWithoutBookingsInput, TripUncheckedUpdateWithoutBookingsInput>
  }

  export type TripUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tripMaster?: UserUpdateOneRequiredWithoutCreatedTripsNestedInput
    members?: TripMemberUpdateManyWithoutTripNestedInput
    invites?: InviteUpdateManyWithoutTripNestedInput
    activities?: ActivityUpdateManyWithoutTripNestedInput
    messages?: TripMessageUpdateManyWithoutTripNestedInput
    mediaItems?: MediaItemUpdateManyWithoutTripNestedInput
    notifications?: NotificationUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    tripMasterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TripMemberUncheckedUpdateManyWithoutTripNestedInput
    invites?: InviteUncheckedUpdateManyWithoutTripNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTripNestedInput
    messages?: TripMessageUncheckedUpdateManyWithoutTripNestedInput
    mediaItems?: MediaItemUncheckedUpdateManyWithoutTripNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTripNestedInput
  }

  export type ActivityUpsertWithoutBookingsInput = {
    update: XOR<ActivityUpdateWithoutBookingsInput, ActivityUncheckedUpdateWithoutBookingsInput>
    create: XOR<ActivityCreateWithoutBookingsInput, ActivityUncheckedCreateWithoutBookingsInput>
    where?: ActivityWhereInput
  }

  export type ActivityUpdateToOneWithWhereWithoutBookingsInput = {
    where?: ActivityWhereInput
    data: XOR<ActivityUpdateWithoutBookingsInput, ActivityUncheckedUpdateWithoutBookingsInput>
  }

  export type ActivityUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    votingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trip?: TripUpdateOneRequiredWithoutActivitiesNestedInput
    proposer?: UserUpdateOneRequiredWithoutActivitiesNestedInput
    votes?: VoteUpdateManyWithoutActivityNestedInput
    mediaItems?: MediaItemUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    proposedBy?: StringFieldUpdateOperationsInput | string
    votingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: VoteUncheckedUpdateManyWithoutActivityNestedInput
    mediaItems?: MediaItemUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type TripCreateWithoutMessagesInput = {
    id?: string
    name: string
    description?: string | null
    destination?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverImage?: string | null
    status?: $Enums.TripStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tripMaster: UserCreateNestedOneWithoutCreatedTripsInput
    members?: TripMemberCreateNestedManyWithoutTripInput
    invites?: InviteCreateNestedManyWithoutTripInput
    activities?: ActivityCreateNestedManyWithoutTripInput
    bookings?: BookingCreateNestedManyWithoutTripInput
    mediaItems?: MediaItemCreateNestedManyWithoutTripInput
    notifications?: NotificationCreateNestedManyWithoutTripInput
  }

  export type TripUncheckedCreateWithoutMessagesInput = {
    id?: string
    name: string
    description?: string | null
    destination?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverImage?: string | null
    status?: $Enums.TripStatus
    tripMasterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TripMemberUncheckedCreateNestedManyWithoutTripInput
    invites?: InviteUncheckedCreateNestedManyWithoutTripInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTripInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTripInput
    mediaItems?: MediaItemUncheckedCreateNestedManyWithoutTripInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripCreateOrConnectWithoutMessagesInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutMessagesInput, TripUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutMessagesInput = {
    id?: string
    email: string
    name: string
    avatarUrl?: string | null
    phone?: string | null
    venmo?: string | null
    paypal?: string | null
    zelle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TripMemberCreateNestedManyWithoutUserInput
    createdTrips?: TripCreateNestedManyWithoutTripMasterInput
    activities?: ActivityCreateNestedManyWithoutProposerInput
    votes?: VoteCreateNestedManyWithoutUserInput
    mediaItems?: MediaItemCreateNestedManyWithoutUploaderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sentInvites?: InviteCreateNestedManyWithoutSentByInput
    messageReactions?: MessageReactionCreateNestedManyWithoutUserInput
    messageReadReceipts?: MessageReadReceiptCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessagesInput = {
    id?: string
    email: string
    name: string
    avatarUrl?: string | null
    phone?: string | null
    venmo?: string | null
    paypal?: string | null
    zelle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TripMemberUncheckedCreateNestedManyWithoutUserInput
    createdTrips?: TripUncheckedCreateNestedManyWithoutTripMasterInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProposerInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
    mediaItems?: MediaItemUncheckedCreateNestedManyWithoutUploaderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sentInvites?: InviteUncheckedCreateNestedManyWithoutSentByInput
    messageReactions?: MessageReactionUncheckedCreateNestedManyWithoutUserInput
    messageReadReceipts?: MessageReadReceiptUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
  }

  export type TripMessageCreateWithoutEditsInput = {
    id?: string
    content: string
    messageType?: $Enums.MessageType
    editedAt?: Date | string | null
    createdAt?: Date | string
    trip: TripCreateNestedOneWithoutMessagesInput
    user: UserCreateNestedOneWithoutMessagesInput
    parent?: TripMessageCreateNestedOneWithoutEditsInput
    reactions?: MessageReactionCreateNestedManyWithoutMessageInput
    readReceipts?: MessageReadReceiptCreateNestedManyWithoutMessageInput
  }

  export type TripMessageUncheckedCreateWithoutEditsInput = {
    id?: string
    tripId: string
    userId: string
    content: string
    messageType?: $Enums.MessageType
    editedAt?: Date | string | null
    parentId?: string | null
    createdAt?: Date | string
    reactions?: MessageReactionUncheckedCreateNestedManyWithoutMessageInput
    readReceipts?: MessageReadReceiptUncheckedCreateNestedManyWithoutMessageInput
  }

  export type TripMessageCreateOrConnectWithoutEditsInput = {
    where: TripMessageWhereUniqueInput
    create: XOR<TripMessageCreateWithoutEditsInput, TripMessageUncheckedCreateWithoutEditsInput>
  }

  export type TripMessageCreateWithoutParentInput = {
    id?: string
    content: string
    messageType?: $Enums.MessageType
    editedAt?: Date | string | null
    createdAt?: Date | string
    trip: TripCreateNestedOneWithoutMessagesInput
    user: UserCreateNestedOneWithoutMessagesInput
    edits?: TripMessageCreateNestedManyWithoutParentInput
    reactions?: MessageReactionCreateNestedManyWithoutMessageInput
    readReceipts?: MessageReadReceiptCreateNestedManyWithoutMessageInput
  }

  export type TripMessageUncheckedCreateWithoutParentInput = {
    id?: string
    tripId: string
    userId: string
    content: string
    messageType?: $Enums.MessageType
    editedAt?: Date | string | null
    createdAt?: Date | string
    edits?: TripMessageUncheckedCreateNestedManyWithoutParentInput
    reactions?: MessageReactionUncheckedCreateNestedManyWithoutMessageInput
    readReceipts?: MessageReadReceiptUncheckedCreateNestedManyWithoutMessageInput
  }

  export type TripMessageCreateOrConnectWithoutParentInput = {
    where: TripMessageWhereUniqueInput
    create: XOR<TripMessageCreateWithoutParentInput, TripMessageUncheckedCreateWithoutParentInput>
  }

  export type TripMessageCreateManyParentInputEnvelope = {
    data: TripMessageCreateManyParentInput | TripMessageCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type MessageReactionCreateWithoutMessageInput = {
    id?: string
    emoji: string
    user: UserCreateNestedOneWithoutMessageReactionsInput
  }

  export type MessageReactionUncheckedCreateWithoutMessageInput = {
    id?: string
    userId: string
    emoji: string
  }

  export type MessageReactionCreateOrConnectWithoutMessageInput = {
    where: MessageReactionWhereUniqueInput
    create: XOR<MessageReactionCreateWithoutMessageInput, MessageReactionUncheckedCreateWithoutMessageInput>
  }

  export type MessageReactionCreateManyMessageInputEnvelope = {
    data: MessageReactionCreateManyMessageInput | MessageReactionCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type MessageReadReceiptCreateWithoutMessageInput = {
    id?: string
    readAt?: Date | string
    user: UserCreateNestedOneWithoutMessageReadReceiptsInput
  }

  export type MessageReadReceiptUncheckedCreateWithoutMessageInput = {
    id?: string
    userId: string
    readAt?: Date | string
  }

  export type MessageReadReceiptCreateOrConnectWithoutMessageInput = {
    where: MessageReadReceiptWhereUniqueInput
    create: XOR<MessageReadReceiptCreateWithoutMessageInput, MessageReadReceiptUncheckedCreateWithoutMessageInput>
  }

  export type MessageReadReceiptCreateManyMessageInputEnvelope = {
    data: MessageReadReceiptCreateManyMessageInput | MessageReadReceiptCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type TripUpsertWithoutMessagesInput = {
    update: XOR<TripUpdateWithoutMessagesInput, TripUncheckedUpdateWithoutMessagesInput>
    create: XOR<TripCreateWithoutMessagesInput, TripUncheckedCreateWithoutMessagesInput>
    where?: TripWhereInput
  }

  export type TripUpdateToOneWithWhereWithoutMessagesInput = {
    where?: TripWhereInput
    data: XOR<TripUpdateWithoutMessagesInput, TripUncheckedUpdateWithoutMessagesInput>
  }

  export type TripUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tripMaster?: UserUpdateOneRequiredWithoutCreatedTripsNestedInput
    members?: TripMemberUpdateManyWithoutTripNestedInput
    invites?: InviteUpdateManyWithoutTripNestedInput
    activities?: ActivityUpdateManyWithoutTripNestedInput
    bookings?: BookingUpdateManyWithoutTripNestedInput
    mediaItems?: MediaItemUpdateManyWithoutTripNestedInput
    notifications?: NotificationUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    tripMasterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TripMemberUncheckedUpdateManyWithoutTripNestedInput
    invites?: InviteUncheckedUpdateManyWithoutTripNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTripNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTripNestedInput
    mediaItems?: MediaItemUncheckedUpdateManyWithoutTripNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTripNestedInput
  }

  export type UserUpsertWithoutMessagesInput = {
    update: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    venmo?: NullableStringFieldUpdateOperationsInput | string | null
    paypal?: NullableStringFieldUpdateOperationsInput | string | null
    zelle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TripMemberUpdateManyWithoutUserNestedInput
    createdTrips?: TripUpdateManyWithoutTripMasterNestedInput
    activities?: ActivityUpdateManyWithoutProposerNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
    mediaItems?: MediaItemUpdateManyWithoutUploaderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sentInvites?: InviteUpdateManyWithoutSentByNestedInput
    messageReactions?: MessageReactionUpdateManyWithoutUserNestedInput
    messageReadReceipts?: MessageReadReceiptUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    venmo?: NullableStringFieldUpdateOperationsInput | string | null
    paypal?: NullableStringFieldUpdateOperationsInput | string | null
    zelle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TripMemberUncheckedUpdateManyWithoutUserNestedInput
    createdTrips?: TripUncheckedUpdateManyWithoutTripMasterNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProposerNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
    mediaItems?: MediaItemUncheckedUpdateManyWithoutUploaderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sentInvites?: InviteUncheckedUpdateManyWithoutSentByNestedInput
    messageReactions?: MessageReactionUncheckedUpdateManyWithoutUserNestedInput
    messageReadReceipts?: MessageReadReceiptUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TripMessageUpsertWithoutEditsInput = {
    update: XOR<TripMessageUpdateWithoutEditsInput, TripMessageUncheckedUpdateWithoutEditsInput>
    create: XOR<TripMessageCreateWithoutEditsInput, TripMessageUncheckedCreateWithoutEditsInput>
    where?: TripMessageWhereInput
  }

  export type TripMessageUpdateToOneWithWhereWithoutEditsInput = {
    where?: TripMessageWhereInput
    data: XOR<TripMessageUpdateWithoutEditsInput, TripMessageUncheckedUpdateWithoutEditsInput>
  }

  export type TripMessageUpdateWithoutEditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trip?: TripUpdateOneRequiredWithoutMessagesNestedInput
    user?: UserUpdateOneRequiredWithoutMessagesNestedInput
    parent?: TripMessageUpdateOneWithoutEditsNestedInput
    reactions?: MessageReactionUpdateManyWithoutMessageNestedInput
    readReceipts?: MessageReadReceiptUpdateManyWithoutMessageNestedInput
  }

  export type TripMessageUncheckedUpdateWithoutEditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: MessageReactionUncheckedUpdateManyWithoutMessageNestedInput
    readReceipts?: MessageReadReceiptUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type TripMessageUpsertWithWhereUniqueWithoutParentInput = {
    where: TripMessageWhereUniqueInput
    update: XOR<TripMessageUpdateWithoutParentInput, TripMessageUncheckedUpdateWithoutParentInput>
    create: XOR<TripMessageCreateWithoutParentInput, TripMessageUncheckedCreateWithoutParentInput>
  }

  export type TripMessageUpdateWithWhereUniqueWithoutParentInput = {
    where: TripMessageWhereUniqueInput
    data: XOR<TripMessageUpdateWithoutParentInput, TripMessageUncheckedUpdateWithoutParentInput>
  }

  export type TripMessageUpdateManyWithWhereWithoutParentInput = {
    where: TripMessageScalarWhereInput
    data: XOR<TripMessageUpdateManyMutationInput, TripMessageUncheckedUpdateManyWithoutParentInput>
  }

  export type MessageReactionUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageReactionWhereUniqueInput
    update: XOR<MessageReactionUpdateWithoutMessageInput, MessageReactionUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageReactionCreateWithoutMessageInput, MessageReactionUncheckedCreateWithoutMessageInput>
  }

  export type MessageReactionUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageReactionWhereUniqueInput
    data: XOR<MessageReactionUpdateWithoutMessageInput, MessageReactionUncheckedUpdateWithoutMessageInput>
  }

  export type MessageReactionUpdateManyWithWhereWithoutMessageInput = {
    where: MessageReactionScalarWhereInput
    data: XOR<MessageReactionUpdateManyMutationInput, MessageReactionUncheckedUpdateManyWithoutMessageInput>
  }

  export type MessageReadReceiptUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageReadReceiptWhereUniqueInput
    update: XOR<MessageReadReceiptUpdateWithoutMessageInput, MessageReadReceiptUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageReadReceiptCreateWithoutMessageInput, MessageReadReceiptUncheckedCreateWithoutMessageInput>
  }

  export type MessageReadReceiptUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageReadReceiptWhereUniqueInput
    data: XOR<MessageReadReceiptUpdateWithoutMessageInput, MessageReadReceiptUncheckedUpdateWithoutMessageInput>
  }

  export type MessageReadReceiptUpdateManyWithWhereWithoutMessageInput = {
    where: MessageReadReceiptScalarWhereInput
    data: XOR<MessageReadReceiptUpdateManyMutationInput, MessageReadReceiptUncheckedUpdateManyWithoutMessageInput>
  }

  export type TripMessageCreateWithoutReactionsInput = {
    id?: string
    content: string
    messageType?: $Enums.MessageType
    editedAt?: Date | string | null
    createdAt?: Date | string
    trip: TripCreateNestedOneWithoutMessagesInput
    user: UserCreateNestedOneWithoutMessagesInput
    parent?: TripMessageCreateNestedOneWithoutEditsInput
    edits?: TripMessageCreateNestedManyWithoutParentInput
    readReceipts?: MessageReadReceiptCreateNestedManyWithoutMessageInput
  }

  export type TripMessageUncheckedCreateWithoutReactionsInput = {
    id?: string
    tripId: string
    userId: string
    content: string
    messageType?: $Enums.MessageType
    editedAt?: Date | string | null
    parentId?: string | null
    createdAt?: Date | string
    edits?: TripMessageUncheckedCreateNestedManyWithoutParentInput
    readReceipts?: MessageReadReceiptUncheckedCreateNestedManyWithoutMessageInput
  }

  export type TripMessageCreateOrConnectWithoutReactionsInput = {
    where: TripMessageWhereUniqueInput
    create: XOR<TripMessageCreateWithoutReactionsInput, TripMessageUncheckedCreateWithoutReactionsInput>
  }

  export type UserCreateWithoutMessageReactionsInput = {
    id?: string
    email: string
    name: string
    avatarUrl?: string | null
    phone?: string | null
    venmo?: string | null
    paypal?: string | null
    zelle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TripMemberCreateNestedManyWithoutUserInput
    createdTrips?: TripCreateNestedManyWithoutTripMasterInput
    activities?: ActivityCreateNestedManyWithoutProposerInput
    votes?: VoteCreateNestedManyWithoutUserInput
    messages?: TripMessageCreateNestedManyWithoutUserInput
    mediaItems?: MediaItemCreateNestedManyWithoutUploaderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sentInvites?: InviteCreateNestedManyWithoutSentByInput
    messageReadReceipts?: MessageReadReceiptCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessageReactionsInput = {
    id?: string
    email: string
    name: string
    avatarUrl?: string | null
    phone?: string | null
    venmo?: string | null
    paypal?: string | null
    zelle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TripMemberUncheckedCreateNestedManyWithoutUserInput
    createdTrips?: TripUncheckedCreateNestedManyWithoutTripMasterInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProposerInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
    messages?: TripMessageUncheckedCreateNestedManyWithoutUserInput
    mediaItems?: MediaItemUncheckedCreateNestedManyWithoutUploaderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sentInvites?: InviteUncheckedCreateNestedManyWithoutSentByInput
    messageReadReceipts?: MessageReadReceiptUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessageReactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessageReactionsInput, UserUncheckedCreateWithoutMessageReactionsInput>
  }

  export type TripMessageUpsertWithoutReactionsInput = {
    update: XOR<TripMessageUpdateWithoutReactionsInput, TripMessageUncheckedUpdateWithoutReactionsInput>
    create: XOR<TripMessageCreateWithoutReactionsInput, TripMessageUncheckedCreateWithoutReactionsInput>
    where?: TripMessageWhereInput
  }

  export type TripMessageUpdateToOneWithWhereWithoutReactionsInput = {
    where?: TripMessageWhereInput
    data: XOR<TripMessageUpdateWithoutReactionsInput, TripMessageUncheckedUpdateWithoutReactionsInput>
  }

  export type TripMessageUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trip?: TripUpdateOneRequiredWithoutMessagesNestedInput
    user?: UserUpdateOneRequiredWithoutMessagesNestedInput
    parent?: TripMessageUpdateOneWithoutEditsNestedInput
    edits?: TripMessageUpdateManyWithoutParentNestedInput
    readReceipts?: MessageReadReceiptUpdateManyWithoutMessageNestedInput
  }

  export type TripMessageUncheckedUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    edits?: TripMessageUncheckedUpdateManyWithoutParentNestedInput
    readReceipts?: MessageReadReceiptUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type UserUpsertWithoutMessageReactionsInput = {
    update: XOR<UserUpdateWithoutMessageReactionsInput, UserUncheckedUpdateWithoutMessageReactionsInput>
    create: XOR<UserCreateWithoutMessageReactionsInput, UserUncheckedCreateWithoutMessageReactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessageReactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessageReactionsInput, UserUncheckedUpdateWithoutMessageReactionsInput>
  }

  export type UserUpdateWithoutMessageReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    venmo?: NullableStringFieldUpdateOperationsInput | string | null
    paypal?: NullableStringFieldUpdateOperationsInput | string | null
    zelle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TripMemberUpdateManyWithoutUserNestedInput
    createdTrips?: TripUpdateManyWithoutTripMasterNestedInput
    activities?: ActivityUpdateManyWithoutProposerNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
    messages?: TripMessageUpdateManyWithoutUserNestedInput
    mediaItems?: MediaItemUpdateManyWithoutUploaderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sentInvites?: InviteUpdateManyWithoutSentByNestedInput
    messageReadReceipts?: MessageReadReceiptUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessageReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    venmo?: NullableStringFieldUpdateOperationsInput | string | null
    paypal?: NullableStringFieldUpdateOperationsInput | string | null
    zelle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TripMemberUncheckedUpdateManyWithoutUserNestedInput
    createdTrips?: TripUncheckedUpdateManyWithoutTripMasterNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProposerNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
    messages?: TripMessageUncheckedUpdateManyWithoutUserNestedInput
    mediaItems?: MediaItemUncheckedUpdateManyWithoutUploaderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sentInvites?: InviteUncheckedUpdateManyWithoutSentByNestedInput
    messageReadReceipts?: MessageReadReceiptUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TripMessageCreateWithoutReadReceiptsInput = {
    id?: string
    content: string
    messageType?: $Enums.MessageType
    editedAt?: Date | string | null
    createdAt?: Date | string
    trip: TripCreateNestedOneWithoutMessagesInput
    user: UserCreateNestedOneWithoutMessagesInput
    parent?: TripMessageCreateNestedOneWithoutEditsInput
    edits?: TripMessageCreateNestedManyWithoutParentInput
    reactions?: MessageReactionCreateNestedManyWithoutMessageInput
  }

  export type TripMessageUncheckedCreateWithoutReadReceiptsInput = {
    id?: string
    tripId: string
    userId: string
    content: string
    messageType?: $Enums.MessageType
    editedAt?: Date | string | null
    parentId?: string | null
    createdAt?: Date | string
    edits?: TripMessageUncheckedCreateNestedManyWithoutParentInput
    reactions?: MessageReactionUncheckedCreateNestedManyWithoutMessageInput
  }

  export type TripMessageCreateOrConnectWithoutReadReceiptsInput = {
    where: TripMessageWhereUniqueInput
    create: XOR<TripMessageCreateWithoutReadReceiptsInput, TripMessageUncheckedCreateWithoutReadReceiptsInput>
  }

  export type UserCreateWithoutMessageReadReceiptsInput = {
    id?: string
    email: string
    name: string
    avatarUrl?: string | null
    phone?: string | null
    venmo?: string | null
    paypal?: string | null
    zelle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TripMemberCreateNestedManyWithoutUserInput
    createdTrips?: TripCreateNestedManyWithoutTripMasterInput
    activities?: ActivityCreateNestedManyWithoutProposerInput
    votes?: VoteCreateNestedManyWithoutUserInput
    messages?: TripMessageCreateNestedManyWithoutUserInput
    mediaItems?: MediaItemCreateNestedManyWithoutUploaderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sentInvites?: InviteCreateNestedManyWithoutSentByInput
    messageReactions?: MessageReactionCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessageReadReceiptsInput = {
    id?: string
    email: string
    name: string
    avatarUrl?: string | null
    phone?: string | null
    venmo?: string | null
    paypal?: string | null
    zelle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TripMemberUncheckedCreateNestedManyWithoutUserInput
    createdTrips?: TripUncheckedCreateNestedManyWithoutTripMasterInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProposerInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
    messages?: TripMessageUncheckedCreateNestedManyWithoutUserInput
    mediaItems?: MediaItemUncheckedCreateNestedManyWithoutUploaderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sentInvites?: InviteUncheckedCreateNestedManyWithoutSentByInput
    messageReactions?: MessageReactionUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessageReadReceiptsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessageReadReceiptsInput, UserUncheckedCreateWithoutMessageReadReceiptsInput>
  }

  export type TripMessageUpsertWithoutReadReceiptsInput = {
    update: XOR<TripMessageUpdateWithoutReadReceiptsInput, TripMessageUncheckedUpdateWithoutReadReceiptsInput>
    create: XOR<TripMessageCreateWithoutReadReceiptsInput, TripMessageUncheckedCreateWithoutReadReceiptsInput>
    where?: TripMessageWhereInput
  }

  export type TripMessageUpdateToOneWithWhereWithoutReadReceiptsInput = {
    where?: TripMessageWhereInput
    data: XOR<TripMessageUpdateWithoutReadReceiptsInput, TripMessageUncheckedUpdateWithoutReadReceiptsInput>
  }

  export type TripMessageUpdateWithoutReadReceiptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trip?: TripUpdateOneRequiredWithoutMessagesNestedInput
    user?: UserUpdateOneRequiredWithoutMessagesNestedInput
    parent?: TripMessageUpdateOneWithoutEditsNestedInput
    edits?: TripMessageUpdateManyWithoutParentNestedInput
    reactions?: MessageReactionUpdateManyWithoutMessageNestedInput
  }

  export type TripMessageUncheckedUpdateWithoutReadReceiptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    edits?: TripMessageUncheckedUpdateManyWithoutParentNestedInput
    reactions?: MessageReactionUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type UserUpsertWithoutMessageReadReceiptsInput = {
    update: XOR<UserUpdateWithoutMessageReadReceiptsInput, UserUncheckedUpdateWithoutMessageReadReceiptsInput>
    create: XOR<UserCreateWithoutMessageReadReceiptsInput, UserUncheckedCreateWithoutMessageReadReceiptsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessageReadReceiptsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessageReadReceiptsInput, UserUncheckedUpdateWithoutMessageReadReceiptsInput>
  }

  export type UserUpdateWithoutMessageReadReceiptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    venmo?: NullableStringFieldUpdateOperationsInput | string | null
    paypal?: NullableStringFieldUpdateOperationsInput | string | null
    zelle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TripMemberUpdateManyWithoutUserNestedInput
    createdTrips?: TripUpdateManyWithoutTripMasterNestedInput
    activities?: ActivityUpdateManyWithoutProposerNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
    messages?: TripMessageUpdateManyWithoutUserNestedInput
    mediaItems?: MediaItemUpdateManyWithoutUploaderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sentInvites?: InviteUpdateManyWithoutSentByNestedInput
    messageReactions?: MessageReactionUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessageReadReceiptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    venmo?: NullableStringFieldUpdateOperationsInput | string | null
    paypal?: NullableStringFieldUpdateOperationsInput | string | null
    zelle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TripMemberUncheckedUpdateManyWithoutUserNestedInput
    createdTrips?: TripUncheckedUpdateManyWithoutTripMasterNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProposerNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
    messages?: TripMessageUncheckedUpdateManyWithoutUserNestedInput
    mediaItems?: MediaItemUncheckedUpdateManyWithoutUploaderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sentInvites?: InviteUncheckedUpdateManyWithoutSentByNestedInput
    messageReactions?: MessageReactionUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TripCreateWithoutMediaItemsInput = {
    id?: string
    name: string
    description?: string | null
    destination?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverImage?: string | null
    status?: $Enums.TripStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tripMaster: UserCreateNestedOneWithoutCreatedTripsInput
    members?: TripMemberCreateNestedManyWithoutTripInput
    invites?: InviteCreateNestedManyWithoutTripInput
    activities?: ActivityCreateNestedManyWithoutTripInput
    bookings?: BookingCreateNestedManyWithoutTripInput
    messages?: TripMessageCreateNestedManyWithoutTripInput
    notifications?: NotificationCreateNestedManyWithoutTripInput
  }

  export type TripUncheckedCreateWithoutMediaItemsInput = {
    id?: string
    name: string
    description?: string | null
    destination?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverImage?: string | null
    status?: $Enums.TripStatus
    tripMasterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TripMemberUncheckedCreateNestedManyWithoutTripInput
    invites?: InviteUncheckedCreateNestedManyWithoutTripInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTripInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTripInput
    messages?: TripMessageUncheckedCreateNestedManyWithoutTripInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripCreateOrConnectWithoutMediaItemsInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutMediaItemsInput, TripUncheckedCreateWithoutMediaItemsInput>
  }

  export type UserCreateWithoutMediaItemsInput = {
    id?: string
    email: string
    name: string
    avatarUrl?: string | null
    phone?: string | null
    venmo?: string | null
    paypal?: string | null
    zelle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TripMemberCreateNestedManyWithoutUserInput
    createdTrips?: TripCreateNestedManyWithoutTripMasterInput
    activities?: ActivityCreateNestedManyWithoutProposerInput
    votes?: VoteCreateNestedManyWithoutUserInput
    messages?: TripMessageCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sentInvites?: InviteCreateNestedManyWithoutSentByInput
    messageReactions?: MessageReactionCreateNestedManyWithoutUserInput
    messageReadReceipts?: MessageReadReceiptCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMediaItemsInput = {
    id?: string
    email: string
    name: string
    avatarUrl?: string | null
    phone?: string | null
    venmo?: string | null
    paypal?: string | null
    zelle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TripMemberUncheckedCreateNestedManyWithoutUserInput
    createdTrips?: TripUncheckedCreateNestedManyWithoutTripMasterInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProposerInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
    messages?: TripMessageUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sentInvites?: InviteUncheckedCreateNestedManyWithoutSentByInput
    messageReactions?: MessageReactionUncheckedCreateNestedManyWithoutUserInput
    messageReadReceipts?: MessageReadReceiptUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMediaItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMediaItemsInput, UserUncheckedCreateWithoutMediaItemsInput>
  }

  export type ActivityCreateWithoutMediaItemsInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startTime?: Date | string | null
    endTime?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    category: string
    votingEndsAt?: Date | string | null
    status?: string
    createdAt?: Date | string
    trip: TripCreateNestedOneWithoutActivitiesInput
    proposer: UserCreateNestedOneWithoutActivitiesInput
    votes?: VoteCreateNestedManyWithoutActivityInput
    bookings?: BookingCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutMediaItemsInput = {
    id?: string
    tripId: string
    title: string
    description?: string | null
    location?: string | null
    startTime?: Date | string | null
    endTime?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    category: string
    proposedBy: string
    votingEndsAt?: Date | string | null
    status?: string
    createdAt?: Date | string
    votes?: VoteUncheckedCreateNestedManyWithoutActivityInput
    bookings?: BookingUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutMediaItemsInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutMediaItemsInput, ActivityUncheckedCreateWithoutMediaItemsInput>
  }

  export type TripUpsertWithoutMediaItemsInput = {
    update: XOR<TripUpdateWithoutMediaItemsInput, TripUncheckedUpdateWithoutMediaItemsInput>
    create: XOR<TripCreateWithoutMediaItemsInput, TripUncheckedCreateWithoutMediaItemsInput>
    where?: TripWhereInput
  }

  export type TripUpdateToOneWithWhereWithoutMediaItemsInput = {
    where?: TripWhereInput
    data: XOR<TripUpdateWithoutMediaItemsInput, TripUncheckedUpdateWithoutMediaItemsInput>
  }

  export type TripUpdateWithoutMediaItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tripMaster?: UserUpdateOneRequiredWithoutCreatedTripsNestedInput
    members?: TripMemberUpdateManyWithoutTripNestedInput
    invites?: InviteUpdateManyWithoutTripNestedInput
    activities?: ActivityUpdateManyWithoutTripNestedInput
    bookings?: BookingUpdateManyWithoutTripNestedInput
    messages?: TripMessageUpdateManyWithoutTripNestedInput
    notifications?: NotificationUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateWithoutMediaItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    tripMasterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TripMemberUncheckedUpdateManyWithoutTripNestedInput
    invites?: InviteUncheckedUpdateManyWithoutTripNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTripNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTripNestedInput
    messages?: TripMessageUncheckedUpdateManyWithoutTripNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTripNestedInput
  }

  export type UserUpsertWithoutMediaItemsInput = {
    update: XOR<UserUpdateWithoutMediaItemsInput, UserUncheckedUpdateWithoutMediaItemsInput>
    create: XOR<UserCreateWithoutMediaItemsInput, UserUncheckedCreateWithoutMediaItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMediaItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMediaItemsInput, UserUncheckedUpdateWithoutMediaItemsInput>
  }

  export type UserUpdateWithoutMediaItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    venmo?: NullableStringFieldUpdateOperationsInput | string | null
    paypal?: NullableStringFieldUpdateOperationsInput | string | null
    zelle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TripMemberUpdateManyWithoutUserNestedInput
    createdTrips?: TripUpdateManyWithoutTripMasterNestedInput
    activities?: ActivityUpdateManyWithoutProposerNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
    messages?: TripMessageUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sentInvites?: InviteUpdateManyWithoutSentByNestedInput
    messageReactions?: MessageReactionUpdateManyWithoutUserNestedInput
    messageReadReceipts?: MessageReadReceiptUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMediaItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    venmo?: NullableStringFieldUpdateOperationsInput | string | null
    paypal?: NullableStringFieldUpdateOperationsInput | string | null
    zelle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TripMemberUncheckedUpdateManyWithoutUserNestedInput
    createdTrips?: TripUncheckedUpdateManyWithoutTripMasterNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProposerNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
    messages?: TripMessageUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sentInvites?: InviteUncheckedUpdateManyWithoutSentByNestedInput
    messageReactions?: MessageReactionUncheckedUpdateManyWithoutUserNestedInput
    messageReadReceipts?: MessageReadReceiptUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ActivityUpsertWithoutMediaItemsInput = {
    update: XOR<ActivityUpdateWithoutMediaItemsInput, ActivityUncheckedUpdateWithoutMediaItemsInput>
    create: XOR<ActivityCreateWithoutMediaItemsInput, ActivityUncheckedCreateWithoutMediaItemsInput>
    where?: ActivityWhereInput
  }

  export type ActivityUpdateToOneWithWhereWithoutMediaItemsInput = {
    where?: ActivityWhereInput
    data: XOR<ActivityUpdateWithoutMediaItemsInput, ActivityUncheckedUpdateWithoutMediaItemsInput>
  }

  export type ActivityUpdateWithoutMediaItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    votingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trip?: TripUpdateOneRequiredWithoutActivitiesNestedInput
    proposer?: UserUpdateOneRequiredWithoutActivitiesNestedInput
    votes?: VoteUpdateManyWithoutActivityNestedInput
    bookings?: BookingUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutMediaItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    proposedBy?: StringFieldUpdateOperationsInput | string
    votingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: VoteUncheckedUpdateManyWithoutActivityNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    name: string
    avatarUrl?: string | null
    phone?: string | null
    venmo?: string | null
    paypal?: string | null
    zelle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TripMemberCreateNestedManyWithoutUserInput
    createdTrips?: TripCreateNestedManyWithoutTripMasterInput
    activities?: ActivityCreateNestedManyWithoutProposerInput
    votes?: VoteCreateNestedManyWithoutUserInput
    messages?: TripMessageCreateNestedManyWithoutUserInput
    mediaItems?: MediaItemCreateNestedManyWithoutUploaderInput
    sentInvites?: InviteCreateNestedManyWithoutSentByInput
    messageReactions?: MessageReactionCreateNestedManyWithoutUserInput
    messageReadReceipts?: MessageReadReceiptCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    name: string
    avatarUrl?: string | null
    phone?: string | null
    venmo?: string | null
    paypal?: string | null
    zelle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TripMemberUncheckedCreateNestedManyWithoutUserInput
    createdTrips?: TripUncheckedCreateNestedManyWithoutTripMasterInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProposerInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
    messages?: TripMessageUncheckedCreateNestedManyWithoutUserInput
    mediaItems?: MediaItemUncheckedCreateNestedManyWithoutUploaderInput
    sentInvites?: InviteUncheckedCreateNestedManyWithoutSentByInput
    messageReactions?: MessageReactionUncheckedCreateNestedManyWithoutUserInput
    messageReadReceipts?: MessageReadReceiptUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type TripCreateWithoutNotificationsInput = {
    id?: string
    name: string
    description?: string | null
    destination?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverImage?: string | null
    status?: $Enums.TripStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tripMaster: UserCreateNestedOneWithoutCreatedTripsInput
    members?: TripMemberCreateNestedManyWithoutTripInput
    invites?: InviteCreateNestedManyWithoutTripInput
    activities?: ActivityCreateNestedManyWithoutTripInput
    bookings?: BookingCreateNestedManyWithoutTripInput
    messages?: TripMessageCreateNestedManyWithoutTripInput
    mediaItems?: MediaItemCreateNestedManyWithoutTripInput
  }

  export type TripUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    description?: string | null
    destination?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverImage?: string | null
    status?: $Enums.TripStatus
    tripMasterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TripMemberUncheckedCreateNestedManyWithoutTripInput
    invites?: InviteUncheckedCreateNestedManyWithoutTripInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTripInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTripInput
    messages?: TripMessageUncheckedCreateNestedManyWithoutTripInput
    mediaItems?: MediaItemUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripCreateOrConnectWithoutNotificationsInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutNotificationsInput, TripUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    venmo?: NullableStringFieldUpdateOperationsInput | string | null
    paypal?: NullableStringFieldUpdateOperationsInput | string | null
    zelle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TripMemberUpdateManyWithoutUserNestedInput
    createdTrips?: TripUpdateManyWithoutTripMasterNestedInput
    activities?: ActivityUpdateManyWithoutProposerNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
    messages?: TripMessageUpdateManyWithoutUserNestedInput
    mediaItems?: MediaItemUpdateManyWithoutUploaderNestedInput
    sentInvites?: InviteUpdateManyWithoutSentByNestedInput
    messageReactions?: MessageReactionUpdateManyWithoutUserNestedInput
    messageReadReceipts?: MessageReadReceiptUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    venmo?: NullableStringFieldUpdateOperationsInput | string | null
    paypal?: NullableStringFieldUpdateOperationsInput | string | null
    zelle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TripMemberUncheckedUpdateManyWithoutUserNestedInput
    createdTrips?: TripUncheckedUpdateManyWithoutTripMasterNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProposerNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
    messages?: TripMessageUncheckedUpdateManyWithoutUserNestedInput
    mediaItems?: MediaItemUncheckedUpdateManyWithoutUploaderNestedInput
    sentInvites?: InviteUncheckedUpdateManyWithoutSentByNestedInput
    messageReactions?: MessageReactionUncheckedUpdateManyWithoutUserNestedInput
    messageReadReceipts?: MessageReadReceiptUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TripUpsertWithoutNotificationsInput = {
    update: XOR<TripUpdateWithoutNotificationsInput, TripUncheckedUpdateWithoutNotificationsInput>
    create: XOR<TripCreateWithoutNotificationsInput, TripUncheckedCreateWithoutNotificationsInput>
    where?: TripWhereInput
  }

  export type TripUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: TripWhereInput
    data: XOR<TripUpdateWithoutNotificationsInput, TripUncheckedUpdateWithoutNotificationsInput>
  }

  export type TripUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tripMaster?: UserUpdateOneRequiredWithoutCreatedTripsNestedInput
    members?: TripMemberUpdateManyWithoutTripNestedInput
    invites?: InviteUpdateManyWithoutTripNestedInput
    activities?: ActivityUpdateManyWithoutTripNestedInput
    bookings?: BookingUpdateManyWithoutTripNestedInput
    messages?: TripMessageUpdateManyWithoutTripNestedInput
    mediaItems?: MediaItemUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    tripMasterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TripMemberUncheckedUpdateManyWithoutTripNestedInput
    invites?: InviteUncheckedUpdateManyWithoutTripNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTripNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTripNestedInput
    messages?: TripMessageUncheckedUpdateManyWithoutTripNestedInput
    mediaItems?: MediaItemUncheckedUpdateManyWithoutTripNestedInput
  }

  export type UserCreateWithoutPushSubscriptionsInput = {
    id?: string
    email: string
    name: string
    avatarUrl?: string | null
    phone?: string | null
    venmo?: string | null
    paypal?: string | null
    zelle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TripMemberCreateNestedManyWithoutUserInput
    createdTrips?: TripCreateNestedManyWithoutTripMasterInput
    activities?: ActivityCreateNestedManyWithoutProposerInput
    votes?: VoteCreateNestedManyWithoutUserInput
    messages?: TripMessageCreateNestedManyWithoutUserInput
    mediaItems?: MediaItemCreateNestedManyWithoutUploaderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sentInvites?: InviteCreateNestedManyWithoutSentByInput
    messageReactions?: MessageReactionCreateNestedManyWithoutUserInput
    messageReadReceipts?: MessageReadReceiptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPushSubscriptionsInput = {
    id?: string
    email: string
    name: string
    avatarUrl?: string | null
    phone?: string | null
    venmo?: string | null
    paypal?: string | null
    zelle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TripMemberUncheckedCreateNestedManyWithoutUserInput
    createdTrips?: TripUncheckedCreateNestedManyWithoutTripMasterInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProposerInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
    messages?: TripMessageUncheckedCreateNestedManyWithoutUserInput
    mediaItems?: MediaItemUncheckedCreateNestedManyWithoutUploaderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sentInvites?: InviteUncheckedCreateNestedManyWithoutSentByInput
    messageReactions?: MessageReactionUncheckedCreateNestedManyWithoutUserInput
    messageReadReceipts?: MessageReadReceiptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPushSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPushSubscriptionsInput, UserUncheckedCreateWithoutPushSubscriptionsInput>
  }

  export type UserUpsertWithoutPushSubscriptionsInput = {
    update: XOR<UserUpdateWithoutPushSubscriptionsInput, UserUncheckedUpdateWithoutPushSubscriptionsInput>
    create: XOR<UserCreateWithoutPushSubscriptionsInput, UserUncheckedCreateWithoutPushSubscriptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPushSubscriptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPushSubscriptionsInput, UserUncheckedUpdateWithoutPushSubscriptionsInput>
  }

  export type UserUpdateWithoutPushSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    venmo?: NullableStringFieldUpdateOperationsInput | string | null
    paypal?: NullableStringFieldUpdateOperationsInput | string | null
    zelle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TripMemberUpdateManyWithoutUserNestedInput
    createdTrips?: TripUpdateManyWithoutTripMasterNestedInput
    activities?: ActivityUpdateManyWithoutProposerNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
    messages?: TripMessageUpdateManyWithoutUserNestedInput
    mediaItems?: MediaItemUpdateManyWithoutUploaderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sentInvites?: InviteUpdateManyWithoutSentByNestedInput
    messageReactions?: MessageReactionUpdateManyWithoutUserNestedInput
    messageReadReceipts?: MessageReadReceiptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPushSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    venmo?: NullableStringFieldUpdateOperationsInput | string | null
    paypal?: NullableStringFieldUpdateOperationsInput | string | null
    zelle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TripMemberUncheckedUpdateManyWithoutUserNestedInput
    createdTrips?: TripUncheckedUpdateManyWithoutTripMasterNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProposerNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
    messages?: TripMessageUncheckedUpdateManyWithoutUserNestedInput
    mediaItems?: MediaItemUncheckedUpdateManyWithoutUploaderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sentInvites?: InviteUncheckedUpdateManyWithoutSentByNestedInput
    messageReactions?: MessageReactionUncheckedUpdateManyWithoutUserNestedInput
    messageReadReceipts?: MessageReadReceiptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TripMemberCreateManyUserInput = {
    id?: string
    tripId: string
    role?: $Enums.MemberRole
    status?: $Enums.MemberStatus
    paymentStatus?: string | null
    paymentAmount?: Decimal | DecimalJsLike | number | string | null
    paymentConfirmedAt?: Date | string | null
    joinedAt?: Date | string
  }

  export type TripCreateManyTripMasterInput = {
    id?: string
    name: string
    description?: string | null
    destination?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverImage?: string | null
    status?: $Enums.TripStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityCreateManyProposerInput = {
    id?: string
    tripId: string
    title: string
    description?: string | null
    location?: string | null
    startTime?: Date | string | null
    endTime?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    category: string
    votingEndsAt?: Date | string | null
    status?: string
    createdAt?: Date | string
  }

  export type VoteCreateManyUserInput = {
    id?: string
    activityId: string
    option: string
  }

  export type TripMessageCreateManyUserInput = {
    id?: string
    tripId: string
    content: string
    messageType?: $Enums.MessageType
    editedAt?: Date | string | null
    parentId?: string | null
    createdAt?: Date | string
  }

  export type MediaItemCreateManyUploaderInput = {
    id?: string
    tripId: string
    type: string
    url: string
    thumbnailUrl?: string | null
    activityId?: string | null
    caption?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    tripId?: string | null
    type: string
    title: string
    body: string
    actionUrl?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type InviteCreateManySentByInput = {
    id?: string
    tripId: string
    token: string
    email?: string | null
    phone?: string | null
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type MessageReactionCreateManyUserInput = {
    id?: string
    messageId: string
    emoji: string
  }

  export type MessageReadReceiptCreateManyUserInput = {
    id?: string
    messageId: string
    readAt?: Date | string
  }

  export type PushSubscriptionCreateManyUserInput = {
    id?: string
    endpoint: string
    p256dh: string
    auth: string
    createdAt?: Date | string
  }

  export type TripMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trip?: TripUpdateOneRequiredWithoutMembersNestedInput
  }

  export type TripMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripUpdateWithoutTripMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TripMemberUpdateManyWithoutTripNestedInput
    invites?: InviteUpdateManyWithoutTripNestedInput
    activities?: ActivityUpdateManyWithoutTripNestedInput
    bookings?: BookingUpdateManyWithoutTripNestedInput
    messages?: TripMessageUpdateManyWithoutTripNestedInput
    mediaItems?: MediaItemUpdateManyWithoutTripNestedInput
    notifications?: NotificationUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateWithoutTripMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TripMemberUncheckedUpdateManyWithoutTripNestedInput
    invites?: InviteUncheckedUpdateManyWithoutTripNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTripNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTripNestedInput
    messages?: TripMessageUncheckedUpdateManyWithoutTripNestedInput
    mediaItems?: MediaItemUncheckedUpdateManyWithoutTripNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateManyWithoutTripMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutProposerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    votingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trip?: TripUpdateOneRequiredWithoutActivitiesNestedInput
    votes?: VoteUpdateManyWithoutActivityNestedInput
    bookings?: BookingUpdateManyWithoutActivityNestedInput
    mediaItems?: MediaItemUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutProposerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    votingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: VoteUncheckedUpdateManyWithoutActivityNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutActivityNestedInput
    mediaItems?: MediaItemUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateManyWithoutProposerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    votingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    option?: StringFieldUpdateOperationsInput | string
    activity?: ActivityUpdateOneRequiredWithoutVotesNestedInput
  }

  export type VoteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: StringFieldUpdateOperationsInput | string
    option?: StringFieldUpdateOperationsInput | string
  }

  export type VoteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: StringFieldUpdateOperationsInput | string
    option?: StringFieldUpdateOperationsInput | string
  }

  export type TripMessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trip?: TripUpdateOneRequiredWithoutMessagesNestedInput
    parent?: TripMessageUpdateOneWithoutEditsNestedInput
    edits?: TripMessageUpdateManyWithoutParentNestedInput
    reactions?: MessageReactionUpdateManyWithoutMessageNestedInput
    readReceipts?: MessageReadReceiptUpdateManyWithoutMessageNestedInput
  }

  export type TripMessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    edits?: TripMessageUncheckedUpdateManyWithoutParentNestedInput
    reactions?: MessageReactionUncheckedUpdateManyWithoutMessageNestedInput
    readReceipts?: MessageReadReceiptUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type TripMessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaItemUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trip?: TripUpdateOneRequiredWithoutMediaItemsNestedInput
    activity?: ActivityUpdateOneWithoutMediaItemsNestedInput
  }

  export type MediaItemUncheckedUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaItemUncheckedUpdateManyWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trip?: TripUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteUpdateWithoutSentByInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trip?: TripUpdateOneRequiredWithoutInvitesNestedInput
    channels?: InviteChannelUpdateManyWithoutInviteNestedInput
  }

  export type InviteUncheckedUpdateWithoutSentByInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channels?: InviteChannelUncheckedUpdateManyWithoutInviteNestedInput
  }

  export type InviteUncheckedUpdateManyWithoutSentByInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    message?: TripMessageUpdateOneRequiredWithoutReactionsNestedInput
  }

  export type MessageReactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
  }

  export type MessageReactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
  }

  export type MessageReadReceiptUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: TripMessageUpdateOneRequiredWithoutReadReceiptsNestedInput
  }

  export type MessageReadReceiptUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadReceiptUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripMemberCreateManyTripInput = {
    id?: string
    userId: string
    role?: $Enums.MemberRole
    status?: $Enums.MemberStatus
    paymentStatus?: string | null
    paymentAmount?: Decimal | DecimalJsLike | number | string | null
    paymentConfirmedAt?: Date | string | null
    joinedAt?: Date | string
  }

  export type InviteCreateManyTripInput = {
    id?: string
    token: string
    email?: string | null
    phone?: string | null
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    sentById: string
    createdAt?: Date | string
  }

  export type ActivityCreateManyTripInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startTime?: Date | string | null
    endTime?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    category: string
    proposedBy: string
    votingEndsAt?: Date | string | null
    status?: string
    createdAt?: Date | string
  }

  export type BookingCreateManyTripInput = {
    id?: string
    activityId?: string | null
    bookedBy: string
    confirmationNum?: string | null
    status?: $Enums.BookingStatus
    receiptUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TripMessageCreateManyTripInput = {
    id?: string
    userId: string
    content: string
    messageType?: $Enums.MessageType
    editedAt?: Date | string | null
    parentId?: string | null
    createdAt?: Date | string
  }

  export type MediaItemCreateManyTripInput = {
    id?: string
    uploaderId: string
    type: string
    url: string
    thumbnailUrl?: string | null
    activityId?: string | null
    caption?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateManyTripInput = {
    id?: string
    userId: string
    type: string
    title: string
    body: string
    actionUrl?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type TripMemberUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type TripMemberUncheckedUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripMemberUncheckedUpdateManyWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentBy?: UserUpdateOneRequiredWithoutSentInvitesNestedInput
    channels?: InviteChannelUpdateManyWithoutInviteNestedInput
  }

  export type InviteUncheckedUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channels?: InviteChannelUncheckedUpdateManyWithoutInviteNestedInput
  }

  export type InviteUncheckedUpdateManyWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    votingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposer?: UserUpdateOneRequiredWithoutActivitiesNestedInput
    votes?: VoteUpdateManyWithoutActivityNestedInput
    bookings?: BookingUpdateManyWithoutActivityNestedInput
    mediaItems?: MediaItemUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    proposedBy?: StringFieldUpdateOperationsInput | string
    votingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: VoteUncheckedUpdateManyWithoutActivityNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutActivityNestedInput
    mediaItems?: MediaItemUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateManyWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    proposedBy?: StringFieldUpdateOperationsInput | string
    votingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookedBy?: StringFieldUpdateOperationsInput | string
    confirmationNum?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    bookedBy?: StringFieldUpdateOperationsInput | string
    confirmationNum?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    bookedBy?: StringFieldUpdateOperationsInput | string
    confirmationNum?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripMessageUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMessagesNestedInput
    parent?: TripMessageUpdateOneWithoutEditsNestedInput
    edits?: TripMessageUpdateManyWithoutParentNestedInput
    reactions?: MessageReactionUpdateManyWithoutMessageNestedInput
    readReceipts?: MessageReadReceiptUpdateManyWithoutMessageNestedInput
  }

  export type TripMessageUncheckedUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    edits?: TripMessageUncheckedUpdateManyWithoutParentNestedInput
    reactions?: MessageReactionUncheckedUpdateManyWithoutMessageNestedInput
    readReceipts?: MessageReadReceiptUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type TripMessageUncheckedUpdateManyWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaItemUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneRequiredWithoutMediaItemsNestedInput
    activity?: ActivityUpdateOneWithoutMediaItemsNestedInput
  }

  export type MediaItemUncheckedUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploaderId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaItemUncheckedUpdateManyWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploaderId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteChannelCreateManyInviteInput = {
    id?: string
    channel: string
    externalId?: string | null
  }

  export type InviteChannelUpdateWithoutInviteInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InviteChannelUncheckedUpdateWithoutInviteInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InviteChannelUncheckedUpdateManyWithoutInviteInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VoteCreateManyActivityInput = {
    id?: string
    userId: string
    option: string
  }

  export type BookingCreateManyActivityInput = {
    id?: string
    tripId: string
    bookedBy: string
    confirmationNum?: string | null
    status?: $Enums.BookingStatus
    receiptUrl?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaItemCreateManyActivityInput = {
    id?: string
    tripId: string
    uploaderId: string
    type: string
    url: string
    thumbnailUrl?: string | null
    caption?: string | null
    createdAt?: Date | string
  }

  export type VoteUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    option?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutVotesNestedInput
  }

  export type VoteUncheckedUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    option?: StringFieldUpdateOperationsInput | string
  }

  export type VoteUncheckedUpdateManyWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    option?: StringFieldUpdateOperationsInput | string
  }

  export type BookingUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookedBy?: StringFieldUpdateOperationsInput | string
    confirmationNum?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trip?: TripUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    bookedBy?: StringFieldUpdateOperationsInput | string
    confirmationNum?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    bookedBy?: StringFieldUpdateOperationsInput | string
    confirmationNum?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaItemUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trip?: TripUpdateOneRequiredWithoutMediaItemsNestedInput
    uploader?: UserUpdateOneRequiredWithoutMediaItemsNestedInput
  }

  export type MediaItemUncheckedUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    uploaderId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaItemUncheckedUpdateManyWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    uploaderId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripMessageCreateManyParentInput = {
    id?: string
    tripId: string
    userId: string
    content: string
    messageType?: $Enums.MessageType
    editedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageReactionCreateManyMessageInput = {
    id?: string
    userId: string
    emoji: string
  }

  export type MessageReadReceiptCreateManyMessageInput = {
    id?: string
    userId: string
    readAt?: Date | string
  }

  export type TripMessageUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trip?: TripUpdateOneRequiredWithoutMessagesNestedInput
    user?: UserUpdateOneRequiredWithoutMessagesNestedInput
    edits?: TripMessageUpdateManyWithoutParentNestedInput
    reactions?: MessageReactionUpdateManyWithoutMessageNestedInput
    readReceipts?: MessageReadReceiptUpdateManyWithoutMessageNestedInput
  }

  export type TripMessageUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    edits?: TripMessageUncheckedUpdateManyWithoutParentNestedInput
    reactions?: MessageReactionUncheckedUpdateManyWithoutMessageNestedInput
    readReceipts?: MessageReadReceiptUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type TripMessageUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReactionUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutMessageReactionsNestedInput
  }

  export type MessageReactionUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
  }

  export type MessageReactionUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
  }

  export type MessageReadReceiptUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMessageReadReceiptsNestedInput
  }

  export type MessageReadReceiptUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadReceiptUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TripCountOutputTypeDefaultArgs instead
     */
    export type TripCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TripCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InviteCountOutputTypeDefaultArgs instead
     */
    export type InviteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InviteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivityCountOutputTypeDefaultArgs instead
     */
    export type ActivityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TripMessageCountOutputTypeDefaultArgs instead
     */
    export type TripMessageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TripMessageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TripDefaultArgs instead
     */
    export type TripArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TripDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TripMemberDefaultArgs instead
     */
    export type TripMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TripMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InviteDefaultArgs instead
     */
    export type InviteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InviteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InviteChannelDefaultArgs instead
     */
    export type InviteChannelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InviteChannelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivityDefaultArgs instead
     */
    export type ActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VoteDefaultArgs instead
     */
    export type VoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingDefaultArgs instead
     */
    export type BookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TripMessageDefaultArgs instead
     */
    export type TripMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TripMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageReactionDefaultArgs instead
     */
    export type MessageReactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageReactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageReadReceiptDefaultArgs instead
     */
    export type MessageReadReceiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageReadReceiptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MediaItemDefaultArgs instead
     */
    export type MediaItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PushSubscriptionDefaultArgs instead
     */
    export type PushSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PushSubscriptionDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}